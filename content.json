{"meta":{"title":"오늘도 끄적끄적","subtitle":null,"description":null,"author":"양권성","url":"http://perfectacle.github.io"},"pages":[{"title":"페이지를 찾을 수 없음","date":"2016-11-10T09:06:26.000Z","updated":"2017-07-31T12:34:54.000Z","comments":true,"path":"404.html","permalink":"http://perfectacle.github.io/404.html","excerpt":"","text":"페이지를 찾을 수 없습니다.페이지가 삭제되었거나 URL을 확인해주세요."},{"title":"양권성이란...?","date":"2016-11-10T09:06:26.000Z","updated":"2017-09-17T16:57:31.000Z","comments":true,"path":"about/index.html","permalink":"http://perfectacle.github.io/about/index.html","excerpt":"","text":"Java8, Spring Boot, JPA ES2015+, Typescript, Node.js, React Git 자전거, 재즈, 힙합 위 사항에 관심이 많습니다. 자작물은 아래와 같습니다. 떡밥밥 keyword-crawler dynamic-table-generator check-browsers async-to-sync perf-chk hexo-theme-overdose-starter 호기심이 많아 항상 디버깅과 테스트하는 것을 좋아합니다.이 블로그도 저의 호기심을 정리해놓기 위해 만들었습니다.여러분의 따뜻한 댓글이 저로 하여금 의지를 더 불타게 만듭니다.블로그를 구독하시고자하시는 분들은 아래 RSS Feed를 구독하시면 되겠습니다.https://perfectacle.github.io/atom.xml감사합니다."}],"posts":[{"title":"(Spring) 스프링 부트 - Gradle의 Profile(dev/production)을 구분지어보자.","slug":"Spring-boot-gradle-profile","date":"2017-09-22T16:06:20.000Z","updated":"2017-09-23T03:21:32.000Z","comments":true,"path":"2017/09/23/Spring-boot-gradle-profile/","link":"","permalink":"http://perfectacle.github.io/2017/09/23/Spring-boot-gradle-profile/","excerpt":"","text":"메이븐은 기본적으로 빌드할 때 프로필을 지정할 수 있는 것 같은데 gradle은 직접 삽질을 하면서 깨달았다.다음의 글들을 보고 Spring boot 1.5.7과 Gradle 3.x(아마)? 에 맞게, 내 입맛에 맞게 각색해보았다. Gradle 배포 환경 별 설정파일 분리 Gradle에서 서버별 패키징 하기 Profile 구성하기기본적인 스프링 부트 프로젝트는 다음과 같은 구조를 가질 것이다.123456789101112+ project명 + src + main + java + package명 - Application.java + resources - application.properties + test- build.gradle- gradlew- gradlew.bat 이를 다음과 같이 나눠보자.1234567891011121314151617+ project + src + main + java + package - Application.java + resources - application-core.properties + resources-env + dev - application.properties + prod - application.properties + test- build.gradle- gradlew- gradlew.bat …/resources에는 공통적으로 쓰는 설정들이 들어가면 된다.application-core.properties에는 테스트 삼아서 다음과 같이 저장해주자.12spring.profiles.active=corecore=core …/resources-env/dev에는 개발에 필요한 파일들만 들어가면 된다.application.properties에는 테스트 삼아서 다음과 같이 지정해주자.1test=dev …/resources-env/prod에는 개발에 필요한 파일들만 들어가면 된다.application.properties에는 테스트 삼아서 다음과 같이 지정해주자.1test=prod build.gradle 수정하기123456789ext.profile = (!project.hasProperty('profile') || !profile) ? 'dev' : profilesourceSets &#123; main &#123; resources &#123; srcDirs \"src/main/resources\", \"src/main/resources-env/$&#123;profile&#125;\" &#125; &#125;&#125; profile 속성의 기본값은 dev이고 그 값에 따라서 리소스 폴더를 지정하는 것이다.resources 폴더는 공통적으로 쓰이는 설정 파일들이기 때문에 공통적으로 들어가면 된다. 샘플 예제는 다음과 같다.12345678910111213141516171819202122232425262728293031323334353637383940buildscript &#123; ext &#123; springBootVersion = '1.5.7.RELEASE' &#125; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(\"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;\") &#125;&#125;apply plugin: 'java'apply plugin: 'eclipse'apply plugin: 'org.springframework.boot'// 이 위치 전에 profile을 구분하는 구문이 오면 오류가 난다.group = 'com.example'version = '0.0.1-SNAPSHOT'sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile('org.springframework.boot:spring-boot-starter') testCompile('org.springframework.boot:spring-boot-starter-test')&#125;ext.profile = (!project.hasProperty('profile') || !profile) ? 'dev' : profilesourceSets &#123; main &#123; resources &#123; srcDirs \"src/main/resources\", \"src/main/resources-env/$&#123;profile&#125;\" &#125; &#125;&#125; properties를 사용하는 스프링 빈 만들기project/src/main/java/package명 아래에 Bean.java를 만들어주자.123456789101112131415@Componentpublic class Bean &#123; @Value(\"$&#123;core&#125;\") private String core; @Value(\"$&#123;test&#125;\") private String test; @PostConstruct private void method() &#123; System.out.println(\"--------------------------------\"); System.out.println(core); System.out.println(\"--------------------------------\"); System.out.println(test); System.out.println(\"--------------------------------\"); &#125;&#125; @PostConstruct 어노테이션을 사용해서 간단하게 스프링 컨텍스트?가 로딩된 이후에 메소드를 실행하게 했다.또한 스프링 빈으로 등록해야 profile에 있는 값을 불러올 수 있으므로 @Component 어노테이션을 사용했다.@Value 어노테이션은 profile에 등록된 값을 얻어오는 녀석이다. 실행하기당연히 터미널에서 프로젝트 디렉토리로 이동해야한다. Gradle CLI 사용하기1234#! prodSPRING_PROFILES_ACTIVE=core gradle clean bootRun -Pprofile=prod#! devSPRING_PROFILES_ACTIVE=core gradle clean bootRun …/resources 디렉토리 내의 properties 파일을 뒤져서 spring.profiles.active가 core인 녀석을 찾아서 적용시킨다는 내용이다.또한 profile이라는 매개변수에 prod를 인자로 넘긴다는 뜻이다.profile의 기본값을 dev로 지정해줬기 때문에 dev용 bootRun에서는 빼줘도 된다. Gradlew 사용하기1234#! prodSPRING_PROFILES_ACTIVE=core ./gradlew clean bootRun -Pprofile=prod#! devSPRING_PROFILES_ACTIVE=core ./gradlew clean bootRun graldew는 Gradle CLI 설치 안 한 사람, 혹은 Gradle의 버전에 의존하지 않고 항상 동일한 Gradle 버전으로 빌드/실행고 싶을 때 매우 유용하다.gradlew를 이용하기 위해서는 gradle/wrapper 디렉도리에 있는 gradle-wrapper.properties와 gradle-wrapper.jar 파일이 필요하다.따라서 해당 디렉토리를 .gitignore에 등록하는 불상사를 일으키지 말자. IDE 사용하기IDE를 사용하면 GUI라는 친숙한 환경, 클릭 한 번으로 여러 환경 변수와 설정을 넣어서 실행할 수 있다는 장점이 있다.물론 AWS나 CLI만 지원하는 환경이라면 위의 두 방법을 활용해야할 것이다.인텔리제이(갓텔리제이)를 찬양 경배하므로 갓텔리제이로 설명.Name에는 프로덕션용으로 bootRun prod를 넣어주고, Gradle project에 project 이름(자동완성 됨)을 입력하고,우측 상단의 Single instance only를 체크해서 서버는 하나만 뜨게 하자.(중복 실행 방지, 포트 충돌 방지)tasks에는 실행할 태스크를 입력하면 되는데 bootRun이 spring boot를 실행하는 태스크이다.그리고 Arguments에 해당 인자를 넘겨야 prod profile이 적용되고,Environment Variables에 SPRING_PROFILES_ACTIVE=core까지 지정해줘서 core profile까지 사용하도록 하자.또한 task가 실행되기 전에 clean task를 실행해야하므로 좌하단에 보이는 노란색 박스에 있는 + 버튼을 눌러주자.production과 동일한데 Arguments에 인자를 넘길 필요가 없다.왜냐하면 dev profile이 기본값이기 때문이다. 위 방법으로 실행해보면 prod/dev에 따라 다른 결과가 나오는 부분도 있고 core에서 불러온 값은 항상 동일하다. 빌드하기SPRING_PROFILES_ACTIVE=core가 빠진 이유는 빌드할 때는 리소스(profile이 담긴) 디렉토리는 지정할 수 있지만profile 파일 자체를 지정할 수는 없기 때문이고, 실행할 때 넘겨줘야한다. Gradle CLI 사용하기 1234#! prodgradle clean build -Pprofile=prod#! devgradle clean build Gradlew 사용하기(Gradle CLI 설치 안 한 사람) 1234#! prod./gradlew clean build -Pprofile=prod#! dev./gradlew clean build IDE 사용하기실행하기의 IDE 사용하기 파트를 참고해서 내용을 채워넣자.실행하기의 IDE 사용하기 파트를 참고해서 내용을 채워넣자. 왜 이렇게 빌드해야하는 걸까?다른 방식으로 하게되면 개발용/프로덕션용 리소스(+코어 리소스는 필수이므로 제외) 두 개 다 포함되게 된다.그럼 개발 서버의 jar 파일이 털렸을 때 압축파일만 풀면 프로덕션 DB 정보 등등까지 알아낼 수 있게 된다.따라서 보안 측면에서 이렇게 좀 귀찮게(?) 빌드해야하는 것이다. 빌드한 결과물을 실행하기서버에 jar(던 war던) 파일을 배포해서 실행을 할 때는 다음과 같이 하면 된다.1java -jar -Dspring.profiles.active=core application.jar 테스트 코드 작성하기test 디렉토리로 가서 기본적으로 만들어진 테스트 클래스를 다음과 같이 수정해주자.123456789101112131415@ActiveProfiles(\"core\")@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Value(\"$&#123;core&#125;\") private String core; @Value(\"$&#123;test&#125;\") private String test; @Test public void contextLoads() &#123; assertThat(core, is(\"core\")); assertThat(test, is(\"dev\")); &#125;&#125; class 이름은 본인이 만든 거에 맞게 설정하고, 테스트 툴은 JUnit4를 사용하였다.(스프링 부트 기본 내장)@ActiveProfiles를 넣어서 spring.profiles.active=core인 profile을 찾는 것이다.또한 테스트를 실행할 때 profile 매개변수를 넘기지 않았으므로(모든 테스트에 다 넘기려면 ㅎㄷㄷ…) 기본값인 dev profile이 적용된다.스프링 컨텍스트가 제대로 로드됐는지 확인하기 위해 @Value 어노테이션으로 profile에 저장된 값을 불러오고 그걸 검증하는 테스트 코드를 짜봤다. 이거 때문에 총 삽질한 시간만 8시간 이상은 되는 것 같다.또 정리만 3시간 이상을… 또르르… ㅠㅠ","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"http://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Gradle","slug":"Gradle","permalink":"http://perfectacle.github.io/tags/Gradle/"}]},{"title":"(Spring) 스프링 부트 - get/post 리퀘스트를 다뤄보자.","slug":"Spring-boot-get-post-mapping","date":"2017-09-18T15:50:51.000Z","updated":"2017-09-18T23:51:28.000Z","comments":true,"path":"2017/09/19/Spring-boot-get-post-mapping/","link":"","permalink":"http://perfectacle.github.io/2017/09/19/Spring-boot-get-post-mapping/","excerpt":"","text":"근본없이 궁금한 부분만 찾아서 공부하다보니 아직 정리가 덜 된 글이다 보니 그 점은 감안하고 보길 바란다. 컨트롤러를 만들자Node.js(+Express)의 Router와 매우 유사한 것 같다.URI와 http method, parameter만 매핑해주는 녀석이다.1234567891011121314151617181920212223242526import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(value = \"/api\")public class Controller &#123; @GetMapping(\"/\") public Person sayHello( @RequestParam String name, @RequestParam int age, @RequestParam(required = false) String hobby ) &#123; Person person = new Person(); person.setHobby(hobby); person.setName(name); person.setAge(age); return person; &#125; @PostMapping(\"/\") public void sayHello( @RequestBody Person person ) &#123; System.out.println(person.getAge()); System.out.println(person.getHobby()); &#125;&#125; @RestController에 대한 설명은 링크를 참조하자. get일 때는 파라미터를 URI에 실어서 보내고, post일 때는 body에 실어보내면 된다.나는 큰 착각을 한 게 post로 보낼 때는 대부분 json으로 보내는 경우가 많다보니json의 프로퍼티와 컨트롤러에 매핑된 함수의 파라미터가 유사할 줄 알았다.하지만 요청 json과 유사한 형태의 VO(Value Object)? TO(Transfer Object)? DO(Domain Object)?를 만들어야하는데 셋 중에 뭐가 맞는 말인지 모르겠다. VO? TO? DO?여튼 만들어보자.Person이라는 클래스를 만들면 된다.12345678910111213141516171819202122232425public class Person &#123; private String name; private int age; private String hobby; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; 이와 매핑되는 리퀘스트 json은 다음과 같을 것이다.12345&#123; \"name\": \"양간장\", \"age\": 20, \"hobby\": \"자전거 타기\"&#125; 요청/응답하기실제 서버를 띄우고 이제 포스트맨을 가지고 장난질을 해보자. 요청 헤더: get http://localhost:8080/api/?name=양권성&amp;age=22응답:1234&#123; \"age\": 22, \"hobby\": null&#125; 왜 name은 안 뜨는 걸지 골똘히 고민해보자. 요청 헤더: post http://localhost:8080/api/ Content-Type=application/json요청 바디:12345&#123; \"name\": \"양간장\", \"age\": 20, \"hobby\": \"자전거 타기\"&#125; 결론Request Body에 json으로 데이터를 실어 보낼 때 주의해야한다.무조건 DO(아니면 VO 또는 TO)를 만들고 그걸 파라미터로 받자.multipart나 FormData로 전송하는 경우는 나중에 다뤄봐야겠다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"http://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://perfectacle.github.io/tags/Spring-Boot/"}]},{"title":"(Spring) 스프링 부트 - properties 값을 불러와보자","slug":"Spring-boot-properties-use","date":"2017-09-17T16:15:10.000Z","updated":"2017-09-18T15:31:07.000Z","comments":true,"path":"2017/09/18/Spring-boot-properties-use/","link":"","permalink":"http://perfectacle.github.io/2017/09/18/Spring-boot-properties-use/","excerpt":"","text":"근본없이 궁금한 부분만 찾아서 공부하다보니 아직 정리가 덜 된 글이다 보니 그 점은 감안하고 보길 바란다. propertiesNode.js로 서버를 구성하다보면 포트 등등의 설정 정보를 json으로 저장하듯이 스프링 부트에서는 properties 파일을 사용하는 것 같다.물론 YAML 파일로도 만들 수 있는 것 같은데 일단 아는 게 properties 파일이다보니 그걸로 진행해보겠다.우선 스프링 부트를 만들면 기본 파일인 application.properties 파일을 아래와 같이 구성해보자.1key=&quot;asdf&quot; properties 사용하는 클래스 만들기이제 이걸 사용하는 클래스를 만들어보자.12345678910111213141516import org.springframework.stereotype.Component;import org.springframework.beans.factory.annotation.Value;@Componentpublic class Tests &#123; @Value(\"$&#123;key&#125;\") private String key; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125;&#125; 눈여겨 볼 어노테이션이 두 개 있다. Component스프링에서 관리하는 빈이라는 걸 알려주기 위한 어노테이션인 것 같다.자바 빈과 스프링 빈은 차이가 있다.자바 빈은 기본 생성자가 있고, getter, setter 메소드가 있고 등등의 특징이 있는 클래스인 것 같다.스프링 빈은 스프링 컨테이너(?)에 의해 관리되는 객체들을 스프링 빈이라고 부르는 것 같다.(자세한 설명은 Difference JavaBean and Spring bean을 참고하자.)여튼 properties에 있는 값을 사용하려면 둘이 스프링에 의해 같이 관리돼야하기 때문에클래스를 스프링 빈으로 등록해야하는 것 같다.자세하게는 모르겠다 ㅠㅠ@Bean vs @Component을 보면 둘 사이에도 명확한 차이가 있는 것 같은데 링크를 참조해보자. (나도 잘 모르니 ㅠㅠ) Valueproperties의 어느 속성을 적용할지 정하는 것 같다. 테스트 코드로 테스트 하기1234567891011121314151617import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.inject.Inject;import static org.hamcrest.core.Is.is;import static org.junit.Assert.*;@RunWith(SpringRunner.class)@SpringBootTestpublic class TestsTest &#123; @Inject private Tests tests; @Test public void test() &#123; assertThat(\"asdf\", is(tests.getKey())); &#125;&#125; Test test = new Test();와 같은 방식 대신에 @Inject 어노테이션을 사용했다.@Autowired와 동일한 역할을 한다고 한다.다만 Inject는 자바에서 지원하는 표준 어노테이션이고, Autowired는 스프링에서 지원해주는 것 같다.build.gradle의 dependency에 compile(&#39;javax.inject:javax.inject:1&#39;) 을 추가하면 된다.자세한 설명은 아래 링크를…Spring MVC 어노테이션 기반 설정 - 2 . @Autowired 결론중요한 것은 @Component, @Value, @Inject(@Autowired) 라는 점을 생각하자!","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"http://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://perfectacle.github.io/tags/Spring-Boot/"}]},{"title":"(Spring) 자바 빈즈 객체를 XML 파일로 관리하면서 DI하기 - @Autowired","slug":"spring-di-v3","date":"2017-09-04T16:02:25.000Z","updated":"2017-09-04T16:17:17.000Z","comments":true,"path":"2017/09/05/spring-di-v3/","link":"","permalink":"http://perfectacle.github.io/2017/09/05/spring-di-v3/","excerpt":"","text":"Car 클래스를 수정해보자.12345678910public class Car &#123; @Autowired private Tire tire33; public Tire getTire() &#123; return tire33; &#125; public void setTire(Tire tire) &#123; this.tire33 = tire; &#125;&#125; 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd\"&gt; &lt;context:annotation-config /&gt; &lt;bean id=\"tire33\" class=\"KoreanTire\"/&gt; &lt;bean id=\"americanTire\" class=\"AmericanTire\"/&gt; &lt;bean id=\"car\" class=\"Car\"/&gt;&lt;/beans&gt; @Autowired 한 멤버 변수와 bean의 id가 매칭되는 걸 볼 수 있다.또한 을 추가해줘야하고, property 태그의 생략이 가능하다. 참조 블로그 - 스프링을 통한 의존성 주입 - @Autowired 를 통한 속성 주입","categories":[{"name":"Back-end","slug":"Back-end","permalink":"http://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"http://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"http://perfectacle.github.io/tags/DI/"}]},{"title":"(Spring) 자바 빈즈 객체를 XML 파일로 관리하면서 DI하기 - property 태그","slug":"spring-di-v2","date":"2017-09-04T15:35:53.000Z","updated":"2017-09-04T16:16:49.000Z","comments":true,"path":"2017/09/05/spring-di-v2/","link":"","permalink":"http://perfectacle.github.io/2017/09/05/spring-di-v2/","excerpt":"","text":"beans.xml 파일을 수정해보자.12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"koreanTire\" class=\"KoreanTire\"/&gt; &lt;bean id=\"americanTire\" class=\"AmericanTire\"/&gt; &lt;bean id=\"car\" class=\"Car\"&gt; &lt;property name=\"tire2\" ref=\"koreanTire\"/&gt; &lt;/bean&gt;&lt;/beans&gt; beans의 property는 getter/setter와 매핑이 된다.Car.java를 수정해보자.1234567891011121314// Car.javapublic class Car &#123; private Tire tire; public Car() &#123;&#125; public Car(Tire tire) &#123; this.tire = tire; &#125; public Tire getTire2() &#123; return tire; &#125; public void setTire2(Tire tire) &#123; this.tire = tire; &#125;&#125; Driver.java를 수정해보자.123456789101112// Driver.javaimport org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Driver &#123; public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext(\"/src/beans.xml\"); Car car = (Car)context.getBean(\"car\"); car.getTire2().wheel(); &#125;&#125; property를 지정했기 때문에 koreanTire가 DI됐다. 참조 블로그 - 스프링을 통한 의존성 주입 - 스프링 설정 파일(xml)에서 속성 주입","categories":[{"name":"Back-end","slug":"Back-end","permalink":"http://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"http://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"http://perfectacle.github.io/tags/DI/"}]},{"title":"(Spring) 자바 빈즈 객체를 XML 파일로 관리하면서 DI하기 - 기본","slug":"spring-di-v1","date":"2017-09-03T15:35:22.000Z","updated":"2017-09-04T16:16:06.000Z","comments":true,"path":"2017/09/04/spring-di-v1/","link":"","permalink":"http://perfectacle.github.io/2017/09/04/spring-di-v1/","excerpt":"","text":"일반 자바를 가지고 DI를 해본 v3에서는 Car 클래스를 자바 빈즈 스펙을 제대로 준수해서 만들지 않았다.따라서 한 번 자바 빈즈 스펙에 맞춰 바꿔보자.12345678910111213public class Car &#123; private Tire tire; public Car() &#123;&#125; public Car(Tire tire) &#123; this.tire = tire; &#125; public Tire getTire() &#123; return tire; &#125; public void setTire(Tire tire) &#123; this.tire = tire; &#125;&#125; getter/setter와 기본 생성자가 있어야 자바 빈즈 스펙을 준수한 것이었는데 저번에는 기본 생성자가 없어서 추가했다.그럼 이제 beans.xml 파일을 만들고 자바 빈즈 객체들을 등록해보자.12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"tire\" class=\"KoreanTire\"/&gt; &lt;bean id=\"americanTire\" class=\"AmericanTire\"/&gt; &lt;bean id=\"car\" class=\"Car\"/&gt;&lt;/beans&gt; id 부분에는 식별할 수 있는 이름을 적고, class에는 패키지와 클래스명 포함 풀 경로를 적어주면 된다. 1234567891011121314// Driver.javaimport org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Driver &#123; public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext(\"/src/beans.xml\"); Car car = (Car)context.getBean(\"car\"); Tire tire = (Tire)context.getBean(\"tire\"); car.setTire(tire); car.getTire().wheel(); &#125;&#125; xml에서 id가 tire인 애만 바꾸면 컴파일을 다시 하지 않아도 타이어의 교체가 가능해진다.하지만 여기서 코드가 더 줄어들을 수 있다.v2에서 확인해보자~ 참조 블로그 - 스프링을 통한 의존성 주입 - XML 파일 사용","categories":[{"name":"Back-end","slug":"Back-end","permalink":"http://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"http://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"http://perfectacle.github.io/tags/DI/"}]},{"title":"Dependency Injection(의존성 주입)을 알아보자 - 생성자 함수","slug":"di-v2","date":"2017-09-03T15:20:46.000Z","updated":"2017-09-04T16:14:23.000Z","comments":true,"path":"2017/09/04/di-v2/","link":"","permalink":"http://perfectacle.github.io/2017/09/04/di-v2/","excerpt":"","text":"v1에는 재사용 가능한 코드가 있음에도 불구하고 미묘(?)한 차이 때문에 계속 각국의 타이어를 장착한 자동차 클래스를 만들어야하는 단점이 있었다.이는 자동차를 만들 때 이미 타이어를 만드는 방법이 결정되어 있기 때문에 발생하는 문제이다.(자동차(전체)가 타이어(부분)에 의존하고 있는 코드)즉, 자동차를 만들 때 타이어를 만드는 방법을 결정하면 되는 사항이다.(의존하는 부분(타이어)을 전체(자동차)에 주입시키는 패턴) 1234// Tire.javapublic interface Tire &#123; void wheel();&#125; 123456// KoreanTire.javapublic class KoreanTire implements Tire &#123; public void wheel() &#123; System.out.println(\"구르다\"); &#125;&#125; 123456// AmericanTrie.javapublic class AmericanTire implements Tire &#123; public void wheel() &#123; System.out.println(\"wheel\"); &#125;&#125; 1234567// Car.javapublic class Car &#123; Tire tire; Car(Tire tire) &#123; // 매개변수의 다형성을 사용 this.tire = tire; &#125;&#125; 12345678910111213public class Driver &#123; public static void main(String[] args) &#123; KoreanTire koreanTire = new KoreanTire(); AmericanTire americanTire = new AmericanTire(); Car car = new Car(koreanTire); car.tire.wheel(); // 구르다 car.tire = americanTire; // 아래와 같은 것도 되니 바로 멤버 변수에 접근해서 설정하는 것은 추천하지 않는다. // car.tire = null; car.tire.wheel(); // wheel &#125;&#125; 이렇게 되면 Tire 클래스들만 쭉쭉 추가하면 되고 Car 클래스는 각국 별로 만들 필요가 없어지게 된다.또한 tire 교체도 가능하지만 올바른 값이 들어왔는지 유효성 검사할 방법이 없다.그럼 v3에서는 이러한 문제점을 개선해보도록 하자. 참조 블로그 - 생성자를 통한 의존성 주입","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"http://perfectacle.github.io/categories/Middle-end/"},{"name":"Pattern","slug":"Middle-end/Pattern","permalink":"http://perfectacle.github.io/categories/Middle-end/Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"DI","slug":"DI","permalink":"http://perfectacle.github.io/tags/DI/"}]},{"title":"Dependency Injection(의존성 주입)을 알아보자 - setter","slug":"di-v3","date":"2017-09-03T15:20:46.000Z","updated":"2017-09-04T16:14:56.000Z","comments":true,"path":"2017/09/04/di-v3/","link":"","permalink":"http://perfectacle.github.io/2017/09/04/di-v3/","excerpt":"","text":"v2에는 자동차를 생산할 때 어떤 타이어를 만들지 정할 수 있고 새로운 타이어로 교체도 가능했다.하지만 올바른 값이 들어왔는지 유효성 검사할 방법이 없다.사실 변경할 수는 있지만 안전하지 않고 그닥 권장하는 방법이 아니다.123456789101112131415161718// Car.javapublic class Car &#123; private Tire tire; Car(Tire tire) &#123; this.tire = tire; &#125; // setter로 유효성 검사를 위해선 어쩔 수 없이(?) tire를 얻기 위해선 getter를 써야함. public Tire getTire() &#123; return tire; &#125; // setter로 다음과 같이 유효성 검사가 가능해짐. public void setTire(Tire tire) &#123; if(tire == null) throw new NullPointerException(); this.tire = tire; &#125;&#125; 1234567891011// Driver.javapublic class Driver &#123; public static void main(String[] args) &#123; KoreanTire koreanTire = new KoreanTire(); AmericanTire americanTire = new AmericanTire(); Car car = new Car(koreanTire); car.getTire().wheel(); // 구르다 car.setTire(americanTire); car.getTire().wheel(); // wheel &#125;&#125; setter를 사용해 좀 더 안전하게(?) 타이어를 교체할 수 있게 되었다.대부분 getter/setter를 사용하는 이유는 아마 다음과 같을 것이다. 자바 빈즈 스펙이기 때문 유효성 검사나 get 하기 전에 처리할 내용이 있기 때문아마 생각 없이 1번 때문에, 아니면 getter와 setter가 그냥 습관이 된 경우가 대부분일 것이다.순수 자바라면 여기서 끝냈을테지만, 이 방법도 타이어를 교체하려면 계속 컴파일 해야한다는 단점이 있다.스프링으로 이런 자바 빈즈 객체를 XML 파일로 관리해서 DI 하는 방법을 쓰면 컴파일 하지 않고 타이어를 교체할 수 있다. 참조 블로그 - 속성을 통한 의존성 주입","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"http://perfectacle.github.io/categories/Middle-end/"},{"name":"Pattern","slug":"Middle-end/Pattern","permalink":"http://perfectacle.github.io/categories/Middle-end/Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"DI","slug":"DI","permalink":"http://perfectacle.github.io/tags/DI/"}]},{"title":"Dependency Injection(의존성 주입)을 알아보자 - 막코딩 하기","slug":"di-v1","date":"2017-09-03T15:05:54.000Z","updated":"2017-09-04T16:14:23.000Z","comments":true,"path":"2017/09/04/di-v1/","link":"","permalink":"http://perfectacle.github.io/2017/09/04/di-v1/","excerpt":"","text":"이 글은 의존성 주입을 전혀 적용하지 않은, 의존성 주입이 뭔지 모르는 상태로 짠 코드이다.우선 문제점을 먼저 파악해봐야 뭐가 되지 않을까 싶어서 막코딩을 해봤다고 가정해보자.우선 미국산 타이어가 장착된 자동차, 한국산 타이어가 장착된 자동차를 만들어야한다고 생각해보자.그럼 우선 미국산, 한국산 타이어 클래스 두 개가 필요할 것이다.123456// KoreanTire.javapublic class KoreanTire &#123; public void wheel() &#123; System.out.println(\"구르다\"); &#125;&#125; 123456// AmericanTrie.javapublic class AmericanTrie &#123; public void wheel() &#123; System.out.println(\"wheel\"); &#125;&#125; 그리고 각각 미국산 타이어를 장착한 자동차, 한국산 타이어를 장착한 자동차 클래스 두 개를 만들면 끝난다.1234567// KoreanCar.javapublic class KoreanCar &#123; KoreanTire koreanTire; KoreanCar() &#123; koreanTire = new KoreanTire(); &#125;&#125; 1234567// AmericanCar.javapublic class AmericanCar &#123; AmericanTire AmericanTire; AmericanCar() &#123; AmericanTire = new AmericanTire(); &#125;&#125; 그리고 이제 이 차를 운전할 사람들을 만들어보자.(한국차를 구매한다고 가정)1234567// Driver.javapublic class Driver &#123; public static void main(String[] args) &#123; KoreanCar koreanCar = new KoreanCar(); koreanCar.koreanTire.wheel(); // 구르다 &#125;&#125; 프로그램은 완성됐고 개발은 끝났다.하지만 영국, 일본, 중국, 태국, 방글라데시, 보스니아 헤르체고비나 등등의 타이어를 장착한 자동차를 만들어야한다면…?클래스는 기하 급수적으로 늘어날 것이고 동일한 코드들이 반복되는데도 불구하고 재사용이 불가능한 코드이므로 계속 자동차, 드라이버 클래스들을 만들어야한다.이런 코드를 보고 유연하지 못하다고 한다. (사교성이 안 좋은 코드이기도 하다 ㅎㅎ…)그럼 v2에서는 이러한 문제점을 개선해보도록 하자. 참조 블로그 - 프로그래밍에서 의존성이란?","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"http://perfectacle.github.io/categories/Middle-end/"},{"name":"Pattern","slug":"Middle-end/Pattern","permalink":"http://perfectacle.github.io/categories/Middle-end/Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"DI","slug":"DI","permalink":"http://perfectacle.github.io/tags/DI/"}]},{"title":"(JazzHop) redpest - Sleepy time beats","slug":"jazz-hop-sleepy-time-beats","date":"2017-08-28T13:07:11.000Z","updated":"2017-08-28T13:15:11.000Z","comments":true,"path":"2017/08/28/jazz-hop-sleepy-time-beats/","link":"","permalink":"http://perfectacle.github.io/2017/08/28/jazz-hop-sleepy-time-beats/","excerpt":"","text":"봄의 향그러운 느낌을 한껏 품은 비트다.들으면 잠이 쏟아질 것 같지만 1시간을 넘게 들어도 잠이 안 올 때는 잘 안 온다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"음악","slug":"기타/음악","permalink":"http://perfectacle.github.io/categories/기타/음악/"}],"tags":[{"name":"Jazz","slug":"Jazz","permalink":"http://perfectacle.github.io/tags/Jazz/"},{"name":"Hiphop","slug":"Hiphop","permalink":"http://perfectacle.github.io/tags/Hiphop/"},{"name":"JazzHop","slug":"JazzHop","permalink":"http://perfectacle.github.io/tags/JazzHop/"},{"name":"Lofi","slug":"Lofi","permalink":"http://perfectacle.github.io/tags/Lofi/"},{"name":"Chill","slug":"Chill","permalink":"http://perfectacle.github.io/tags/Chill/"},{"name":"Sleepy","slug":"Sleepy","permalink":"http://perfectacle.github.io/tags/Sleepy/"}]},{"title":"자바 vs 자바스크립트","slug":"java-vs-javascript","date":"2017-08-19T11:43:58.000Z","updated":"2017-08-28T13:09:53.000Z","comments":true,"path":"2017/08/19/java-vs-javascript/","link":"","permalink":"http://perfectacle.github.io/2017/08/19/java-vs-javascript/","excerpt":"","text":"이 글은 자바와 자바스크립트를 혼동하는 사람, 차이점이 궁금한 사람 등을 위하여 쓴 글입니다.또한 자바스크립트는 다른 언어에 비해 어떤 단점이 있으며 그 단점들을 어떻게 극복해야할지에 대해 다뤄봤습니다. 하고 싶은 말 세 줄 요약. 자바스크립트 !== 자바(자바 != 자바스크립트), 자바와 자바스크립트는 같지 않다.두 언어 간에는 접점이 크지 않고, 자바스크립트는 자바의 인기에 편승할 목적(마케팅 목적)으로 이름을 지은 것 뿐입니다. 자바 커뮤니티 가서 자바스크립트 질문하거나 자바스크립트 커뮤니티 가서 자바 질문을 하는 건 자제해주세요.하지 말라는 건 아닌데 질문자 분께서 원하시는 답(틀린 답을 얻을 수도 있고), 양질의 답을 얻을 가능성, 그리고 빠른 응답을 받기가 힘드실 수 있습니다. 제발 자바 스크립트(Java Script)라고 적어서 혼란을 초래하지 말아주세요.제발 제발 부탁드립니다. 가끔 보면 화(…)가 날 때도 있습니다.위와 같이 쓰시는 분들 때문에 이런 혼란이 더 초래되는 것 같습니다.새로 배우시는 분들께 잘못된 인식을 심어주는 것도 굉장히 위험하다고 보니 제발 부탁드리겠습니다. 목차 자바스크립트의 어원 자바스크립트의 탄생 목적 자바의 탄생 배경 Oak 자바 자바스크립트는 인터프리트 언어이다?? 자바는 컴파일 언어다?? 자바스크립트 언어와 자바의 공통점?? 왜 자바스크립트 보고 구리다고 할까?? 자바스크립트는 멀티 패러다임 언어이다. 객체 지향 프로그래밍 관점에서의 자바스크립트 함수형 프로그래밍 관점에서의 자바스크립트 자바스크립트는 더 이상 예전의 자바스크립트가 아니다. 자바스크립트를 배우기 전에 잘 만들어진 프로그래밍 언어를 먼저 배우는 것을 추천하는 이유 자바스크립트의 어원자바스크립트가 처음 개발할 때부터 자바스크립트였던 건 아니었다.초기에 자바스크립트는 Mocha라는 이름으로 개발되다 추후에 Livescript라는 이름으로 변경되었다.그러다 자바라는 언어가 인기가 많아지자 그 인기에 편승할 목적, 즉 마케팅 목적으로 자바스크립트라는 이름으로 변경 후 세상에 나오게 되었다.당시 자바의 개발사인 썬 마이크로시스템과 자바스크립트의 개발사인 넷 스케이프 사는 ‘자바 라이센스’를 공동으로 소유하고 있어서 이런 일이 가능하였다. 자바스크립트의 탄생 목적해당 언어의 탄생 목적을 보면 어떤 경우에 해당 언어를 써야할지가 명확해진다.과거 웹사이트는 사용자와 상호 작용이 불가능했으며, 페이지가 상당히 정적인 모습을 띄었다.따라서 다음과 같은 것들이 불가능하였다. 자바스크립트의 탄생 목적은 이렇듯 페이지의 동적 제어였다.다른 프로그래밍 언어(Java, C 등등)의 경우 하나의 완성된 프로그램을 만들 목적으로 만들어진 언어에 비해 그 목적 자체가 달랐다.하지만 자바스크립트라는 언어에서 보듯이 자바스크립트는 스크립트 언어이다.스크립트 언어는 일반적인 프로그래밍 언어와 달리 하나의 완성된 프로그램보다는 프로그램 사이에 들어가는, 기존의 프로그램들을 제어하거나 보조하는 용도로 많이 쓰인다. 자바의 탄생 배경Oak(오크)가전제품에 탑재될 소프트웨어를 만들어야해서 C++을 확장해서 사용하려 했지만 C++로는 부적합하였다.따라서 C++의 장점을 도입, 단점을 보완한 Oak라는 언어를 만들게 되었다.Oak는 운영체제에 독립적이라는 장점이 있어 멀티 플랫폼을 지원할 수 있었다.따라서 가전제품이나 PDA와 같은 소형 기기에 탑재될 목적으로 Oak라는 언어를 만들고 있었다. 자바여러 종류의 운영체제를 사용하는 컴퓨터들이 통신하는 인터넷이 등장하자운영체제에 독립적인 Oak가 이에 적합하다고 판단하여 Oak를인터넷에 적합하도록 그 개발 방향을 바꾸면서 이름을 Java로 변경하였다.따라서 백엔드, 서버 쪽 진영을 보면 그렇게 자바를 많이 쓰는 이유가 자바가 웹에 적합한 언어이기 때문이다.또한 오래 전 만들어졌기 때문에 안정성과 다양한 커뮤니티가 형성된 것도 한 몫하는 것 같다. 자바스크립트는 인터프리트 언어이다??(자알쓰) JIT 컴파일을 참조하자. 자바는 컴파일 언어다??컴파일하면 소스 코드를 기계어로 변환하는 과정이라고 알고 있는데, 엄밀히 말하면 자바는 소스코드를 기계어로 변환하지 않는다.자바는 소스 코드를 각 자바 바이트 코드로 변환한다.그 이후 JVM(Java Virtual Machine)이 그 자바 바이트 코드를 기계어로 변환한다.즉 실행할 때 마다 매번 자바 바이트 코드를 기계어로 변환하는 JIT 컴파일 방식을 취한다. 자바스크립트 언어와 자바의 공통점??자바와 자바스크립트가 공통점이 많아서 자바스크립트라고 이름을 붙였다고 주장을 할 수도 있다.하지만 그 정도 공통점은 C와 Java 사이에도 있는 공통점과 같이 다른 프로그래밍 언어 사이에서도 존재하는 프로그래밍 언어라면 가지고 있어야할 당연한 개념들이다.자바스크립트는 하나의 특정 언어보다는 여러 언어 사이에서 다양한 개념을 차용한 언어이다. 자바에서는 문법과 ‘원시 값 vs 객체 관계’ 스키마와 오크에서는 일급 객체인 함수 셀프에서는 프로토타입 상속 펄과 파이썬에서는 문자열, 배열, 정규표현식을 빌려왔다. 왜 자바스크립트 보고 구리다고 할까??기존에 다른 프로그래밍 언어(Java, C 등등)을 배웠던 사람은 자바스크립트를 배울 때 매우 어려워한다.개념이 어렵다기 보다는 다른 프로그래밍 언어와 공통된 규칙을 어기는 경우, 당연히 그렇게 동작할 것이라고 생각한 경우를 배신(?)한 경우가 많다.그래서 깊은 공부 없이 자바스크립트를 학습 후 기존의 프로그래밍 언어와 같이 사용했을 때는 다음과 같은 문제점이 존재한다. 함수 단위의 스코프아래 글도 참고해보자.(자알쓰) Scope Part. 1(자알쓰) Scope Part. 2 12345var i = 2;for(var i=1; i&lt;10; i++) &#123; console.log(i);&#125;console.log(i); // 2가 아니라 10 기존 프로그래밍 언어에서는 당연히 변수의 스코프는 {}블록 단위였다.즉 당연하다고 생각한 변수 스코프를 무심코 썼다간 큰 코 다치기 쉽상이다.이를 위해서는 아래와 같이 작업해야한다.12345678910111213141516171819202122232425// Solution #1// 변수 이름을 다르게 하기var i = 2;for(var j=1; j&lt;10; j++) &#123; console.log(j);&#125;console.log(i); // 2// Solution #2// 즉시 실행 함수(IIFE)를 활용하여 별도의 함수 스코프를 생성var i = 2;(function() &#123; for(var i=1; i&lt;10; i++) &#123; console.log(i); &#125;&#125;());console.log(i); // 2// Solution #3// ES2015에 도입된 개념인 블록 단위의 스코프를 지원하는 const/let을 사용const i = 2;for(let i=1; i&lt;10; i++) &#123; console.log(i);&#125;console.log(2); 하지만 이와 반대로 자바는 블록 단위의 스코프이다. 모듈화 미지원아래 글도 참고해보자.(자알쓰) 모듈화 Part. 1(자알쓰) 모듈화 Part. 2JavaScript 표준을 위한 움직임: CommonJS와 AMD자바스크립트의 모든 코드는 전역 스코프를 사용한다.따라서 아래와 같은 경우에는 다음과 같은 문제점이 존재한다. 123456789&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"a.js\"&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt;&lt;script src=\"c.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678// a.jsvar a = 'as';// b.jsvar a = 'df';// c.jsconsole.log(a[0]); // 'd' 스크립트 태그 삽입 순서에 따라 a 값이 바뀌게 되고 a 값의 안정성을 보장할 수 없다.저 값이 어디로 어떻게 튈지 몰라서 에러를 유발하는 코드가 될 수도 있다.만약 누군가가 a에 3이라는 값을 넣었으면 3은 숫자이고 인덱스로 접근이 불가능하니 오류가 나기 마련이다.따라서 다음과 같이 해결해야한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Solution #1// 네임스페이스 패턴을 활용하기// a.jsvar a = a || &#123;&#125;;a.a = 'as';// b.jsvar b = b || &#123;&#125;;b.a = 'df';// c.jsconsole.log(a.a[0]); // 'a'// Solution #2// ES2015의 모듈 문법인 import/export Syntax 사용하기// 지원하는 브라우저/Node가 없으므로 Webpack 등등의 Module Bundler의 사용이 필수적임.// a.jsexport const a = 'as';// b.jsexport const a = 'df';// c.jsimport &#123;a&#125; from 'a.js';console.log(a[0]); // 'a'// Solution #3// Node.js에서는 CommonJS 방식으로 모듈화를 구현할 수 있음.// a.jsexports.a = 'as';// b.jsexports.a = 'df';// c.jsconst &#123;a&#125; = require('a.js');console.log(a[0]); // 'a'// Solution #4// 브라우저에서는 모든 파일을 다운로드 받아야한다는 특수성 때문에 비동기로 모듈을 로딩해야한다. // 이를 위한 모듈화 방법으로는 AMD 방식이 있으며 이를 구현한 라이브러리는 RequireJS가 있다. // http://requirejs.org 를 참조하자. 1번 솔루션인 네임스페이스 패턴은 전역 스코프를 더럽힌다는 단점(전역 스코프에 변수 a와 b가 두둥실 떠다니게 됨.)이 존재한다.외부에서 참조하려면 어쩔 수 없이 전역 스코프에서 모듈을 구현해야하지만 외부에서 참조할 일 없는 변수는자바스크립트의 함수 단위의 스코프를 활용한 즉시 실행 함수 패턴(IIFE, Immediately Invoked Function Expressions)를 사용하면 된다.12345678910// a.js(function() &#123; var a = 2; console.log(a);&#125;());// b.js(function() &#123; console.log(a); // Uncaught ReferenceError: a is not defined&#125;()); 즉 a.js와 b.js는 서로 다른 스코프를 가지게 된다는 의미이고 전역 스코프가 아닌 로컬 스코프(함수는 별도의 스코프를 형성하므로)를 사용하게 되는 격이다.위에서 보이는 문제점들은 전부 스코프가 너무 넓다는 문제점들이다.스코프가 너무 넓으면 여러 곳에서 접근이 가능하고, 여러곳에서 접근이 가능하다는 소리는 내가 작성한 코드를 다른 개발자가 쉽게 수정이 가능하단 뜻이며그 코드로 인해 프로그램이 뻗을 수도 있으므로 스코프는 좁은 것이 최대한 코드의 안정성을 보장할 수 있는 길이라고 할 수 있을 것 같다. 하지만 자바에서는 모듈화를 클래스나 패키지를 통해 구현할 수 있는 것으로 알고 있다. 호이스팅(자알쓰) Hoisting을 참고하자.자바에서는 호이스팅이란 개념이 존재하지 않는다.&nbsp; 동적 타입자바스크립트는 기본적으로 변수를 만들 때 변수의 타입을 지정하지 않는다.따라서 해당 변수에는 문자열이 담겼다가 숫자가 담길 수도 있다.처음에는 이러한 유연함 때문에 변수의 타입을 생각하지 않고 코딩하기 때문에 코딩이 더 빨리 되는 것 같아서 좋다.하지만 몇 달 후, 내가 짠 코드도 보기 이해하기 힘든데 남이 짠 코드를 유지보수 해야하는 경우,혹은 앱의 규모가 대규모로 커지는 경우에는 과연 변수에 어떤 값이 담겼는지 잘 알아낼 수 있을까?? 12345678910111213// 3개월 전에 작성한 util.jsvar util = util || &#123;&#125;;util.a = function(a) &#123; return +a; // 숫자로 변환하여 반환&#125;// 3개월 후에 내가 수정하거나 작성해야할 app.jsvar b = util.a('aa');// 나는 util.a의 결과가 배열인 줄 알고 splice 메소드를 썼다.// 하지만 util.a의 결과는 숫자이고 숫자에는 splice 메소드가 존재하지 않으니 에러가 뜰 것이다.// 만약 정적 타입 언어였다면 util.a의 반환값이 숫자인 것을 알고 당연히 에러라고 에디터에 밑줄을 그어줄테지만// 변수의 타입이 존재하지 않는 자바스크립트 같은 경우에는 실행했을 때만, 즉 런타임 시에만 오류를 알 수 있다는 단점이 존재한다.console.log(a.splice(0)); 자바는 정적 타입의 언어, 즉 변수를 생성할 때 어떤 타입의 변수인지 선언해야하고 죽었다 깨어나도 변수의 타입은 바뀌지 않는다. var 없이 변수 선언하기이런 코드 보면 조금 극혐하는 편이다.스코프는 좁을 수록 코드가 안전해진다고 알고 있는데 오히려 스코프를 넓히는 코딩 패턴이다.다음 코드를 살펴보자. 123456789101112131415161718var a = function() &#123; // 변수 a를 var 없이 선언했다. // 일단 현재 스코프에 변수 a가 없으므로 상위 스코프로 이동한다. // 그리고 그 스코프에 존재하는 변수 a의 값을 재할당한다. a = 3; var b = function() &#123; // 변수 b를 var 없이 선언했다. // 일단 현재 스코프에 변수 b가 없으므로 상위 스코프로 이동한다. // 그리고 그 스코프에 존재하는 변수 b의 값을 재할당한다. b = 2; &#125;; b(); console.log(b); // 함수 b 실행 이후 b는 더이상 함수가 아닌 숫자 2이다.&#125;;var b = 3;a();console.log(a); // 함수 a 실행 이후 a는 더이상 함수가 아닌 숫자 3이다.console.log(b); // 얘는 3 그대로이다. 어떤 글들을 보면 var 없으면 전역에 변수를 생성한다고 하는데 그게 아니라 스코프 하나씩 위로 타고 올라가서 있는지 없는지 파악 후해당 변수가 존재하는 스코프(없으면 전역까지 가서 생성)에 변수를 재할당 하는 것이다.여튼 이런 실수를 방지하려면 Strict Mode를 무조건 사용하자.ES2015+라면 Strict Mode를 사용할 필요가 없다. 자바는 이렇게 변수를 생성하는 키워드를 생략해서 변수를 생성할 수 없다. 자바스크립트는 멀티 패러다임 언어이다.자바스크립트는 여러 언어로부터 개념을 빌려온 언어이다.셀프에서는 프로토타입 상속 개념을 빌려왔기 때문에 객체 지향 언어에서 말하는 상속의 개념도 구현할 수 있다.따라서 자바스크립트는 객체 지향 프로그래밍이 가능하다.또한 스키마와 오크에서는 일급 객체인 함수 개념을 빌려왔기 때문에 함수형 프로그래밍도 가능하다. 객체 지향 프로그래밍 관점에서의 자바스크립트123456789101112131415161718var Parent = function(name) &#123; if(!name) throw '이름을 입력하시오'; this.name = name;&#125;;Parent.prototype.sayMyName = function() &#123; console.log(this.name);&#125;;var Child = function(name, age) &#123; if(!name) throw '이름을 입력하시오'; if(!age) throw '나이를 입력하시오'; Parent.call(this, name); // 부모의 생성자 함수 호출 this.age = age;&#125;;Child.prototype = new Parent();var c = new Child('양권성', 99);c.sayMyName(); // '양권성' 하지만 이마저도 다음과 같은 문제점이 존재한다.여기서 말하는 멤버는 변수+메소드를 뜻한다. static 멤버가 존재하지 않는다.인스턴스(객체)를 생성하기 이전에 사용 가능한 static 멤버가 존재하지 않는다.ES2015의 class syntax(말이 class지, 그 내부를 들여다보면 여전히 함수를 통해 객체를 생성하고 있다.)가 도입되면서 static 멤버의 사용도 가능해졌다. 123456789const Person = class &#123; static sayHello() &#123; console.log('hello'); &#125; // static 변수는 아직 Stage-2 단계이다. // static b = 'b';&#125;;Person.sayHello(); // hello private 멤버를 만들지 못한다.private 멤버가 없다면 아래와 같은 문제점들이 존재하게 된다. 1234567891011var Person = function(name, age) &#123; if(!name) throw '이름을 입력하시오'; if(!age) throw '나이를 입력하시오'; this.age = age; this.name = name;&#125;;var p = new Person('양권성', null); // 정상적으로 오류를 뿜어냄.var p2 = new Person('양권성', 25);p2.age = null; // age를 재할당 했을 때는 오류를 잡아낼 수가 없음. 이를 위해서는 ES2015의 class, 유일한 값을 만들어내는 Symbol, 외부에서 접근 불가능한 별도의 스코프를 만들어냄과 동시에 실행하는 즉시 실행 함수 패턴,내부 스코프에 있는 변수(private 변수)들을 접근하기 위해 클로저 사용, private 변수들에 대한 유효성 검사(?)를 위한 getter/setter 메소드가 사용되었다.사실 Reflect.ownKeys나 Object.getOwnPropertySymbols를 이용하면 Symbol로 만든 private 변수에 접근이 가능하지만,private 접근 지정자가 존재하는 자바에도 Reflect를 사용하면 Private Filed에 접근하기가 가능하다고 한다.Reflect를 사용 했을 때도 private 멤버들을 숨기고 싶다면 ES6 Class에서 private member를 정의하는 방법를 참조하자.12345678910111213141516171819202122232425262728293031323334353637383940const Person = (() =&gt; &#123; // 즉시 실행 함수 패턴을 사용하여 별도의 스코프를 생성함과 동시에 함수를 실행. // 리턴문 밖에 있는 애들은 getter와 setter를 제외하고는 직접적인 접근이 불가능해서 private이라고 말할 수 있음. // 클로저를 사용한 것임. const _name = Symbol('name'); const _age = Symbol('age'); return class &#123; constructor(name, age) &#123; if(!name) throw '이름을 입력하시오'; if(!age) throw '나이를 입력하시오'; this[_name] = name; this[_age] = age; &#125; get name() &#123; return this[_name]; &#125; set name(name) &#123; if(!name) throw '이름을 입력하시오'; this[_name] = name; &#125; get age() &#123; return this[_age]; &#125; set age(age) &#123; if(!age) throw '나이를 입력하시오'; this[_age] = age; &#125; &#125;;&#125;)();const p = new Person('양권성', null); // 정상적으로 오류를 뿜어냄.const p2 = new Person('양권성', 25);p2.age = null; // age를 재할당 했을 때 또한 오류를 잡아냄.// 아래 방법으로 private 멤버에 접근이 가능하긴 하다.console.log(Object.getOwnPropertySymbols(p2));console.log(Reflect.ownKeys(p2)); 자바는 이런 static 멤버, private 접근 지정자, 메소드 오버라이딩, 오버로딩 등등과 같이 자바스크립트에서 지원하는 것은 물론 지원하지 않는 객체 지향 개념들도 모두 지원하고 있는 언어이다. 함수형 프로그래밍 관점에서의 자바스크립트두말하면 입아프니 함수형 프로그래밍(JS)이란…?을 참고하자.자바에서는 자바8에 Lambda가 출현한 이후 함수형 프로그래밍이 가능해졌는지 모르겠지만 그 이전에는 불가능한 것으로 알고 있다.왜냐하면 자바에서는 함수가 일급 객체가 아니기 때문에 함수의 매개변수로 넘길 수 없기 때문이다. 자바스크립트는 더 이상 예전의 자바스크립트가 아니다.예전에 자스의 출현 목적은 페이지의 동적 제어였지만 브라우저를 탈출한 JS(Node.js)의 출현과 ES2015의 탄생 이후로이런 걸 자바스크립트로 할 수 있다고??와 같은 걸 많이 할 수 있게 되었다. 서버 구현(Node.js) 파일 읽고 쓰기(Node.js) CLI 프로그램 만들기 (예) babel, webpack 등등) 모바일 앱 만들기(Ionic2, React Native) 데스크탑 앱 만들기(Electron) 크롤링 하기(PhantomJS, JSDom 등등) 기타 등등 이제 자바스크립트는 어엿한 프로그래밍 언어의 반열에 올랐다고 볼 수 있고, 그 목적도 이제 페이지의 동적 제어에 벗어나서 프로그래밍 언어 관점으로 바라보고 학습할 자세가 필요하다. 자바스크립트를 배우기 전에 잘 만들어진 프로그래밍 언어를 먼저 배우는 것을 추천하는 이유ES2015의 출현으로 자바스크립트의 많은 단점들이 보완됐지만 여전히 단점들(동적 타입, 인터페이스의 부재, 다른 언어의 좋은 개념들 등등)이 존재한다.ES5 시절에는 아주 홍수 같이 많았다.(호이스팅, 모듈화, 함수단위 스코프 등등)이런 문제점은 누가 짚어주지 않는 이상 모르는 경우가 허다하다.하지만 만약 자바나 C 같은 이런 단점들이 존재하지 않는 언어들을 먼저 배웠다면 어? 동적 타입 언어네? 정적 타입으로 도와주는 라이브러리가 없나?모듈화는 어떻게 구현해야할까? 등등과 같은 고민들을 누가 말해주지 않더라도 혼자서라도 해볼 가능성이 조금이라도 올라가며 누군가 설명을 해주면 쉽게 이해가 가능하다.또한 자바 등등과 같이 잘 만들어지지 않은 언어를 배우지 않다보면 캡슐화, private 멤버의 필요성을 느낄 수가 없게 된다.정통 프로그래밍 언어를 배웠다면 이게 없으면 당연히 문제라고 생각해볼만한 개념들이 자바스크립트에는 상당히 많다.물론 그 배경에는 짧은 개발 기간과 페이지 동적 제어라는 목적 때문이었겠지만…","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"}]},{"title":"자바스크립트 학습 방법","slug":"js-how-to-learn","date":"2017-08-08T12:30:06.000Z","updated":"2017-08-09T09:16:20.000Z","comments":true,"path":"2017/08/08/js-how-to-learn/","link":"","permalink":"http://perfectacle.github.io/2017/08/08/js-how-to-learn/","excerpt":"","text":"이 포스트는 제가 다년간 자바스크립트를 설렁 설렁 공부하다 작년 1년동안 빡시게 공부해온 경험을 토대로 작성한 글입니다.따라서 이 글을 읽으시는 분들께서는 본인과 맞지 않는 부분도 존재할 수 있으니 그 점은 참고하고 적절한 필터링을 하시면 되겠습니다. 목차 들어가기에 앞서 역사를 먼저 알아보자 자바스크립트는 자바가 아니다 HTML, CSS의 연장선 상으로 자바스크립트를 바라보지 말자 JS를 브라우저와 떼놓고 생각하자 JS는 더이상 Toy Language(장난감 가지고 놀듯 쉽고 깊이 없이 배워도 되는 언어)가 아니다. 어떻게 공부해야할까? 1. 잘 만들어졌다고 알려진 언어들을 먼저 공부하자 1-1. 그게 싫다면 쉽게 쉽게 쓰여진 책을 먼저 읽자 2. 소문난 책들을 위주로 읽자, 단 jQuery 빼고 2-1. MDN, Stackoverflow와 친해지자 2-2. ES5를 끝내고 ES2015+를 할 필요가 없다 3. NPM과 Babel을 배우자 4. ES2015+가 익숙해졌다면 Typescript를 공부해보자 번외편 1. 코드 검사 도구를 사용하자. 2. Task Runner를 배우자 3. Module Bundler를 배우자 4. TDD를 공부하자 마치며 들어가기에 앞서먼저 들입다 자바스크립트 공부를 하지 말고 아래 내가 열거한 사항들을 먼저 보고 공부를 해보자.나의 다년간의 노하우가 녹아있으니 쏙쏙 빼먹길 바란다.이러한 노하우들을 보고 실제 자바스크립트를 어떻게 공부해야할지에 대해 알아보자.또한 에이전시/쇼핑몰에 종사하는 분들은 ES2015+를 실무에서 접할 기회가 적기 때문에 2-1. MDN, Stackoverflow와 친해지자 파트까지만 공부해도 실무에서는 전혀 무리가 없을 것이다.하지만 스타트업, 자사 서비스/대규모 JS 앱을 개발하는 환경에 종사하는 분들은 ES2015+를 실무에서 매우 빈번하게 사용하고 있을 것이므로 그 이후 챕터까지 모두 공부하는 걸 추천한다. 역사를 먼저 알아보자해당 프로그래밍 언어가 어떤 문제를 해결하기 위해 나왔는지 등등에 대해 파악을 하게 되면 좀 더 해당 언어를 잘 쓸 수 있게 된다.먼저 초기 브라우저에는 페이지를 보여주기만 할 뿐, 유저와 상호작용을 하지 못했다.유저가 값을 입력하는게 불가능하다보니 그에 대한 응답도 불가능했던 것이다.따라서 페이지의 동적인 처리를 위해서 자바스크립트가 나왔다고 해도 과언이 아니다.당시에 자바스크립트는 하나의 프로그램을 만드는 목적 보다도 ID에 공백을 넣은 경우, 메뉴에 마우스를 올린 경우 등등의 동적인 처리가 주된 목적이었다.따라서 하나의 완성된 프로그램을 만들기에는 다소 부족한 점도 많았고, 10일이라는 짧은 개발 시간 탓에 설계 상 버그 등등이 많다.이러한 점들은 자알쓰에서 하나하나 정리하고 있으니 해당 포스트를 참고해보자. 자바스크립트는 자바가 아니다가끔 보면 자바스크립트 커뮤니티에 자바 질문을 올리는 사람들이 있다.자바 스크립트(Java Script)가 아니라 자바스크립트(Javascript)다. 둘은 엄연히 다르다.왜 이런 이름이 붙었는지에 대해서 간단히 알아보자.자바스크립트의 이름의 변천사는 모카(Mocha) - 라이브스크립트(Livescript) - 자바스크립트(Javascript)이다.자바스크립트는 다음과 같은 언어에서 영향을 받았다. 자바에서는 문법과 ‘원시 값 vs 객체 관계’ 스키마와 오크에서는 일급 객체인 함수 셀프에서는 프로토타입 상속 펄과 파이썬에서는 문자열, 배열, 정규표현식을 빌려왔다. 또한 워낙 여러 언어로부터 영향을 받은 덕에 함수형 프로그래밍(일급 객체인 함수)과 객체지향 프로그래밍(객체, 상속)을 함께 사용하곤 한다. 따라서 자바스크립트는 자바와 직접적인 연관 관계가 커서 그렇게 이름이 붙은 게 아니라 자바의 인기에 탑승하려는 노이즈마케팅 전략을 사용한 게 아닐까 싶다. HTML, CSS의 연장선 상으로 자바스크립트를 바라보지 말자많은 사람들이 HTML, CSS를 배우고 그 이후에 홈페이지를 동적으로 제어할 목적으로 자바스크립트를 배운다.자바스크립트는 프로그래밍 언어이다.C언어와 같은 프로그래밍 언어를 배운다고 하면 C언어를 배우지 그 전에 컴퓨터 사이언스를 굳이 배우고 시작할 필요는 없다.배우면 좋지만 배우지 않고 시작해도 상관이 없다는 뜻이다.즉, 그 말은 병행해도 된다는 뜻이며 HTML을 배우지 않고 JS를 먼저 배워도 된다는 뜻이다. JS를 브라우저와 떼놓고 생각하자브라우저에서 제공하는 JS는 크게 세 파트로 나눌 수가 있다. DOM(Document Object Model)자바스크립트에 자주 사용하는 document.getElementById()와 같이 document 객체에 해당하는 내용들을 지칭한다. BOM(Browser Object Model)자바스크립트에서 자주 사용하는 window.alert()와 같이 window 객체에 해당하는 내용들을 지칭한다. ES(ECMAScript) 오잉? 브라우저에서 제공하는 JS? 그럼 다른 곳에서도 JS를 쓸 수 있단 말인가?그렇다. Node.js에서도 JS를 쓸 수 있으며 브라우저에서는 할 수 없었던 여러가지를 할 수 있게 되었다. File I/O파일의 입/출력과 관련된 내용이다. 서버 API서버를 구축하는 것 등등에 관한 내용이다. ES(ECMAScript) 기타 등등 너무 많음. 따라서 우리는 먼저 ES를 마스터해야한다.Node.js와 Browser라는 플랫폼에서 공통적으로 쓸 수 있는 내용이기도 하며 ES에 해당하는 내용들이여타 프로그래밍 언어들(C, Java 등등)이 가지고 있어야할 내용들(변수, 함수, 자료형, 조건문, 반복문 등등)이 포함된 내용이기 때문에프로그래밍 언어 관점에서 자바스크립트를 배우려면 ES를 먼저 파야한다. 자바스크립트를 브라우저와 절친 먹여놓고 공부하기 시작하다보면 다음과 같은 함정에 빠지게 된다.일반적인 수학에서 함수는 입력 값이 있으면 출력 값이 있다라는 개념이다.프로그래밍 세계에서 함수의 입력 값은 매개변수, 출력 값은 반환하는 값과 연결이 된다.따라서 두 수의 합을 반환하는 함수를 만들라고 하면 다양한 결과가 나오게 된다.12345678910111213141516171819202122232425262728// 아래 두 케이스가 모범 답안function add(x, y) &#123; return x+y;&#125;var add2 = function(x, y) &#123; return x+y;&#125;;// 결과를 확인하려고자 하는 의지function add3(x, y) &#123; console.log(x+y);&#125;// 브라우저와 짱친 먹은 JS들function add4(x, y) &#123; alert(x+y);&#125;function add5(x, y) &#123; document.body.innerHTML += x+y;&#125;function add6() &#123; var x = parseInt(prompt(\"숫자를 입력해주세요.\")); var y = parseInt(prompt(\"숫자를 입력해주세요.\")); document.body.innerHTML += x+y;&#125; 사람들이 입력이라고 하면 어느 정도는 함수의 매개변수로 이해를 하는 경향이 있다.(일부는 prompt 함수로 입력받는다.)하지만 반환의 의미를 (화면에)출력으로 받아들이는 경우도 존재하고, 그 화면에 출력하는 방법도 로그창, 경고창, 브라우저에 보여주는 방법 등이 존재한다.이는 모두 브라우저에 의존하고 있는 것이다. JS는 더이상 Toy Language(장난감 가지고 놀듯 쉽고 깊이 없이 배워도 되는 언어)가 아니다.과거에 어쨌든 간에 현재 자바스크립트는 계속해서 새로운 스펙이 나오고 이제 어엿한 프로그래밍 언어의 반열에 올랐다고 할 수 있다.여전히 동적 타입, typeof 버그 등등의 단점이 존재하지만 이전 자바스크립트 버전으로 작성한 코드와의 호환 때문에 고칠 수 없는 점도 존재해서 여전히 문제는 존재한다.하지만 예전의 Toy Language(장난감 가지고 놀듯 쉽고 깊이 없이 배워도 되는 언어)가 아니란 뜻이며 진지하고 깊숙하게 시간을 내서 배울 가치가 있는 언어이다. 어떻게 공부해야할까?아직 들어가기에 앞서를 보지 않았다면 꼭 보고 오자.공부에 임하기 전에 자바스크립트를 어떠한 자세로 바라보고 공부해야할지에 대해 적어놓았다.이제 본격적으로 자바스크립트를 어떻게 정복해야할지 스텝 바이 스텝으로 적어보겠다. 1. 잘 만들어졌다고 알려진 언어들을 먼저 공부하자사람은 아는만큼 보인다.자바스크립트는 애초에 목적 자체가 프로그램을 만들기 보다는 페이지의 동적 제어였고, 10일이라는 짧은 개발 기간 덕분에 설계 상 문제점이 많은 언어이다.이걸 다른 프로그래밍 언어를 모르는 사람은 그 설계 사항들이 왜 안 좋고 어떤 문제점들이 존재하는지 모른다.그런 걸 친절하게 일일이 다 설명해주는 책이 있으면 모르겠지만 없었던 것 같고, 다 인터넷을 통해 파편화된 지식을 조각 조각 모아야했던 것 같다.혹은 너무 어렵게 설명이 돼있거나…하지만 잘 만들어졌다고 알려진 C나 Java와 같은 언어(동의를 안 하더라도 확실히 예전의 JS보다는 잘 만들어졌다는 데는 동의할 것이다.)를 먼저 공부하고 자바스크립트를 바라보면이거 왜 이렇게 만들었어?, 이렇게 짜면 이런 사항들이 문제가 되겠는데?, 예전에 봤을 때는 못 알아 먹겠는 것들이 이제는 조금씩 보이네?하고 동일한 내용을 보아도 이해하는 관점이 깊이가 깊어진다.따라서 나는 자바스크립트를 접하기 전에 그런 언어들을 먼저 접하는 걸 추천한다. 1-1. 그게 싫다면 쉽게 쉽게 쓰여진 책을 먼저 읽자나는 시간이 별로 없거니와 C언어와 Java는 너무 어렵다(알레르기가 있다)고 생각되는 사람들은 사람들이 말하는 잘 쓰여진 책들 말고 서점에 가서 자신의 눈으로 직접 보고 이해할만한 수준의 책을 골라보자.왜 잘 쓰여진 책보다 쉽게 쓰여진 책을 추천하냐면 일단 뇌를 말랑말랑하게 만들어서 자바스크립트와 친밀도를 높이게 하기 위함이다.처음부터 잘 쓰여진 책을 보다보면 자신이 이해할 수 없는 수준으로 얘기하는 경우가 많다.하지만 쉽게 쉽게 쓰여진 책은 다소 설명이 부족하더라도 이해하는데는 큰 무리가 없고 술술 넘어갈 것이다.이런 책은 깊이 없이 그냥 술술 넘어가며 봐야한다. 그냥 ‘JS가 이런 거구나~’하고 맛보기만 하는 것이지 그렇게 깊이 있게 볼만한 책은 아니다.주로 따라해볼만한 예제가 많고 브라우저와 짱친 먹은 예제들(눈에 바로 바로 결과가 보여지니 학습 유도에는 좋았다) 위주의 책이 보기 좋을 것이다.나의 경우에는 HTML+CSS+JS 무따기 시리즈로 JS를 처음 접했는데 지금은 없어진 것 같다. 2. 소문난 책들을 위주로 읽자, 단 jQuery 빼고여기서 말하는 소문난 책(내 기준)은 다음과 같다. 인사이드 자바스크립트 자바스크립트를 말하다 러닝 자바스크립트 코뿔소 책이나 노란책도 유명하다고들 하나 솔직히 1독이라도 끝낸 사람이 얼마나 될까 싶을 정도라서 그닥 추천하지 않았다.그리고 아직 읽어보지 않았지만 You Don’t Know JS 시리즈도 좋은 것 같다. 여기서 jQuery를 뺀 이유는 적어도 ES5까지는 알고 나서 제이쿼리를 접하는 걸 추천한다.자바스크립트는 엄연히 프로그래밍 언어인데 중간에 jQuery(DOM 조작 라이브러리+@)를 먼저 접하면 프로그래밍 언어 관점 보다는 DOM을 조작하는데 너무 혈안이 될 수도 있다.또 JS를 제대로 모르는 상태에서 jQuery를 접하게 되면 Javascript를 몰라서 나오는 질문을 jQuery를 모르기 때문이라고 생각할 수도 있으며,Javascript로 해결해야하는 상황들을 jQuery의 메소드로 해결하는 상황도 초래할 수 있다.jQuery는 Javascript로 만들어져있기 때문에 절대 VanillaJS(Pure JS)보다 성능 측면에서 좋을 수가 없다.따라서 jQuery를 배우더라도 아직은 그 쪽에 힘을 싣지 않고 Javascript 쪽에 힘을 더 싣는 것을 추천한다.jQuery를 사용하지 않는 곳을 찾기 힘들 정도로 jQuery는 많은 곳에서 사용 중이지만 아래와 같은 글이 있을 정도로 jQuery가 그렇게 짱짱맨인 것 만은 아니다. You Don’t Need jQuery 이제와서 JQUERY를 쓰면 안되는 이유, 혹은 JQUERY와 웹개발의 역사 2-1. MDN, Stackoverflow와 친해지자 MDN은 파이어폭스라는 브라우저를 만든 모질라 재단에서 만든 개발자를 위한 사이트이다.Javascipt 내장 API(Array 관련 메소드 등등)들의 자세한 설명 등등이 나와 있다.ECMAScript Spec을 보고 이해하기 힘든 내용들은 이 곳에서 자주 참고하자. Stackoverflow는 개발자 계의 지식 IN이라고 보면 될 것 같다.검색은 네이버(카페)에 의존하기 보다는 구글링(구글에 검색하는 행위)을 통해 Stackoverflow와 같은 사이트 올라온 글들을 참고하자.네이버의 수 백 배에 달하는 글들과 더 좋은 정보들이 있다보니 더 빨리 문제 해결을 할 수 있는 가능성이 높아진다.한 발 더 나아가서 직접 질문과 답변까지 해보면 금상첨화일 것이다. w3schools라는 사이트가 있지만 w3fools란 사이트가 있을 정도로 잘못된 내용 및 업데이트가 늦다보니 간단한 예제 정도만 참고하자. 2-2. ES5를 끝내고 ES2015+를 할 필요가 없다웹 에이전시나 쇼핑몰 등등에 근무하는 사람들은 ES5까지(2-1 챕터)까지만 공부하셔도 업무를 보는데는 크게 지장이 없을 것이다.웹 에이전시나 쇼핑몰에 근무하는 사람들이라면 ES2015+는 고사하고 ES3를 사용하고 있을 가능성이 크다.(IE8 때문)그래도 IE8도 곧 사장될 거 같기 때문에(아마도…?) ES5를 미리미리 공부해두는 게 좋다.또한 협업하는 사람이 ES2015+를 모른다면 다음과 같은 문제점이 존재한다. 협업하는 사람이 ES2015+를 공부해야한다. 협업하는 사람이 공부할 의지가 없으면 큰일이다. 추후에 사람을 뽑을 때 ES2015+를 알고 있는 사람으로 뽑아야한다. 이 외에도 다른 문제점들이 존재하겠지만 당장 떠오르는 것은 이게 끝이다. 해당 챕터부터는 스타트업이나 자사 서비스/대규모 앱을 JS로 개발하는 환경에 종사하는 사람들이라면 반드시 거쳐야하는 과정일 것이다. 과거 나도 ‘ES5를 끝내고 ES2015+를 공부해야하지 않나?’라는 생각 때문에 반년동안 ES5에만 목을 메달다가 어느 스터디에서 ES6(ES2015)와 ES5를 간단하게 비교해주는 내용을 들었는데 정말 혁명이었고 별 거 없었다.ES6 들어서 새로 생긴 Promise, Generator, Iterator 등등의 내용을 다룬 것은 아니고 간단한const/let, Rest Parameter, Default Parameter, Spread Operator, for-of 등등은 정말 금방 배울 수 있다.따라서 내 생각은 똑같은 코드를 ES5로 짜보고 ES2015+로 짜보고 점점 익숙해지면 그 이후에 Promise, Generator, Iterator 등등의 내용을 공부하면 될 것 같다.또한 요즘 프론트 엔드 개발을 할 때 ES5로 짜는 것보다 ES2015+로 짜는 경우가 훨씬 많다.따라서 ES5를 공부할 필요가 없다고 주장하는 사람도 있는데 나는 그 견해와는 입장이 다르다.ES2015+로 짠 코드를 브라우저(특히 MS 계열)에서 정상적으로 지원해주지 않는다.따라서 ES5로 바꿔주어야하는데 결국 브라우저 위에서 도는 것은 ES5 코드이다.그러니까 ES2015+로 짜면서 어느 정도는 ES5로 어떻게 변환될지 상상(?)을 조금 하면서 짤 필요는 있다.ES2015+의 코드를 ES5로 바꿔주는 애가 100% 커버를 해주지 못한다. (그 도구가 꾸진 게 아니라 언어 설계상 오는 차이 때문에…)따라서 대부분은 커버하지만 혹시 모를 에러가 발생할 수도 있으니 ES5 정도는 알아야한다는 게 내 생각이다. 3. NPM과 Babel을 배우자.우선 ES2015+의 코드를 브라우저에서 100% 지원해주지 않는다.따라서 ES5로 변환(트랜스파일)해줘야 하는데 그 중에 제일 많이 쓰고 좋다고 생각되는 것은 Babel이다.이 Babel을 사용하는 가장 쉬운 방법은 Babel REPL을 이용하는 것이다.그런데 매번 소스를 복붙 해서 트랜스파일하는 귀찮은 과정을 반복할 것인가?그리고 우리는 바벨이 ES5로 트랜스파일 한 코드를 보고 이해하지 못한다.따라서 우리가 소스 유지보수를 하기 위해서는 ES2015+로 짠 코드 하나, ES5로 트랜스파일 된 코드 하나, 총 두 개를 들고 있어야한다.이런 귀찮은 작업을 줄여주기 위한 것이 babel-cli이다.MS-DOS 유저라면 익숙할 법한 시꺼먼 창인 터미널(윈도우의 CMD)에서 트랜스파일을 해주는 도구이다.하지만 이 babel-cli를 설치는 npm을 통해서만 가능하다. (왜냐면 babel-cli가 Node.js 위에서 돌기 때문…)npm은 Node.js를 설치하면 자동으로 설치된다.이 때 우리가 배워야할 것은 두 가지이다. npm 사용 방법(package.json에 대해 공부하기, 모듈 설치 삭제 해보기) babel-cli 사용 방법 4. ES2015+가 익숙해졌다면 Typescript를 공부해보자ES2015+가 아무리 좋아졌다고 하더라도 다음과 같은 걸 해결하지 못했다. 정적 타입 사용자가 직접 인터페이스 구현 private 접근 지정자등등이 있는데 이 ES2015+의 모든 특성들을 포함한 Superset 격인 Typescript란 게 존재한다. 나도 타입스크립트는 잘 모르기 때문에 1번을 토대로 장점을 설명해보겠다. 코드의 안정성앱의 규모가 커지면 커질 수록 코드를 파악하기 힘들어지는 경향이 존재한다.또 오랜 시간이 지난 코드를 유지보수 할 때도 마찬가지이다.이럴 때 어떤 메소드를 써야할 때 첫 번째 매개변수로 문자열이 와야하는지, 숫자가 와야하는지, 매개변수를 몇 개를 넘겨야하는지, 생략이 가능한지기존 동적 타입에서는 체크할 수 없었던 내용 등등을 체크하므로 어떻게 메소드를 사용해야하는지 직접 메소드 구현부로 가서 파악할 필요가 없어진다. 코드의 자동완성어떤 함수로부터 값을 반환 받았는데 이게 배열인 줄 알고 forEach 메소드를 썼는데 알고보니 Object가 반환되는 경우였다고 생각해보자.기존 동적 타입에서는 어떤 자료형이 반환되는지 모르니 자동완성에 배열의 메소드, 문자열의 메소드 등등이 전부 뜰 것이다.하지만 정적인 타입으로 딱 Object가 반환된다는 게 확정된 메소드라면 자동완성에 배열의 메소드도 뜨지 않을 것이며 배열의 메소드를 사용하면에디터 상에서 오류로 표시되기 때문에 이런 것도 어찌보면 코드의 안정성과 연결이 되는 점이기도 하다. 하지만 장점이 있으면 단점이 있듯, 내 기준에서 단점을 서술해보겠다. 생산성이 떨어진다(초기에)동적 타입인 js는 코드를 대충 빨리 짜도 돌아간다.따라서 생산성이 높다고 볼 수 있다. (하지만 나중을 생각한다면…)하지만 타입스크립트는 타입 체크가 매우 빡빡하다.따라서 동일한 코드를 짤 때도 더 오래 걸릴 수도 있다.하지만 나중에 되면 아마 타입스크립트가 훨씬 빠를 것이다. 외부 라이브러리에 대한 타입 정의도 모두 해줘야한다.이게 제일 사람 미치게 한다.유명한 라이브러리의 경우 미리 다 타입 정의 파일이 있는데 없는 경우에는 직접 만들거나 적폐 세력(any)를 사용해야한다.또한 라이브러리의 버전과 타입 정의한 파일의 버전이 불일치하는 경우도 있고 골칫거리다.이러한 단점 때문에 타입스크립트를 포기하는 경우가 많다. (나도… ㅠㅠ) 번외편해당 파트는 자바스크립트와 직접적으로 관련이 있다고는 말할 수 없다.하지만 나는 자바스크립트로 개발을 한다면(특히 ES2015+) 당연히 알면 좋다고 생각하는 내용들을 정리해봤다. 1. 코드 검사 도구를 사용하자.코드를 짤 때 항상 일관성 있게 짜야한다.하물며 한 사람이 짤 때도 문자열을 표시하는데 “”나 ‘’을 혼용한다던지들여쓰기를 위해 탭과 들여쓰기를 혼용한다던지 등등의 경우에 놓이게 되는데다른 사람들과 협업하다보면 하나의 소스 파일의 가독성은 똥망진창이 될 것이다.하지만 사람의 눈으로 꼼꼼히 체크한다 해도 꼭 놓치기 마련이다.이렇게 코딩 컨벤션을 지켰는지와 에러 등등을 체크해주는 툴로 JS에서는 JSLint, JSHint, ESLint 등등이 있다.각자 장단점을 파악해보고 마음에 드는 걸 사용하면 좋은데 ESLint를 추천한다.또한 TS 진영에서는 TSLint를 사용하면 된다. 2. Task Runner를 배우자기존의 자바스크립트 소스 코드를 개발하던 방식에는 다음과 같은 문제가 존재한다. 유저에게 불필요한 데이터를 전송하여 LTE 데이터를 낭비하게 만들고, 그 데이터들로 하여금 로딩 속도를 느리게 만듦으로써 사용자에게 최적화된 UX를 제공해주지 못하고 있다.이게 뭔소린가 싶으면 우리의 소스 코드를 보면 공백과 기나긴 변수명 등등을 가지고 있다.이거는 사람 입장에서 가독성을 높여 유지보수하기 편하게 한 것이지, 컴퓨터 입장에서는 이런 애들은 불필요하다.따라서 공백을 줄이고(minify), 변수명을 난독화(a, b와 같은 걸로 줄이는 작업, uglify)시키는 작업을 해야한다. 우리가 사용하는 웹 브라우저는 HTTP 프로토콜 위에서 통신을 한다.요즘 HTTP 2도 나왔지만 아직까지 브라우저/서버의 호환 때문에 많은 사람들이 HTTP 1.1을 사용 중이다.HTTP/1.1는 기본적으로 Connection당 하나의 요청을 처리 하도록 설계 되어있다.그래서 동시전송이 불가능하고 요청과 응답이 순차적으로 이루어 지게된다.그렇다 보니 HTML 문서안에 포함된 다수의 리소스 (Images, CSS, Script)를 처리하려면 요청할 리소스 개수에 비례해서 Latency(대기 시간)는 길어지게 된다.SPA(Single Page Application)의 경우 다수의 스크립트 파일을 로딩하나 하나로 합친(concat) 스크립트 파일을 로딩하나 동일하게 작동한다.다수의 파일은 대기 시간이라는 오버헤드(쓸 데 없는 비용(여기서 시간도 비용으로 측정함))가 발생하기 때문에 다수의 스크립트 파일을 하나로 합쳐주는 작업도 해야한다. 이런 작업을 하는 방법은 여러 가지가 있는데 UglifyJS를 이용하는 것이 가장 간단하다.하지만 이는 Babel REPL과 마찬가지로 수동으로 해줘야한다는 단점이 존재한다.이러한 Minify 작업(Task), Uglify 작업, concat 작업 등등 무수한 최적화 작업을 소스 코드가 수정될 때마다 일일이 하고 싶을까?이러한 작업(Task)들을 실행(Run)을 하나의 단위로 묶어서 한 번에 실행시켜주는 Task Runner란 게 존재한다.그 중에서도 Grunt와 Gulp가 있는데 둘 중에 아무거나 해도 상관이 없을지 모르겠는데 나는 Gulp를 배웠다. 3. Module Bundler를 배우자.자바스크립트에서 스코프는 함수 단위(const와 let은 블록 단위)이고, 모듈이란 게 존재하지 않았다.따라서 네임스페이스 패턴과 같은 꼼수를 사용해서 모듈화를 구현하곤 하였다. 시간이 흘러 Node.js 진영에서는 CommonJS 스펙을 준수해서 모듈화를 구현하였다.하지만 웹 브라우저는 사용자들이 파일을 내려받아야한다는 특수한 상황이 존재해서 비동기적으로 모듈을 로딩해야한다는 특수한 상황에 놓여있다.이를 위한 AMD(Asynchronous Module Definition) 스펙이 있고, 이를 구현한 RequireJS라는 라이브러리가 있다.자세한 내용은 JavaScript 표준을 위한 움직임: CommonJS와 AMD를 참고하자. 하지만 ES2015에 들어와서 Module을 언어단에서 지원해주는 import와 export 문법이 존재한다.하지만 현재 이를 지원하는 브라우저/Node는 없다.따라서 브라우저 진영에서는 여전히 A 모듈, B 모듈 등등을 각각 로딩해야하는 사태가 발생했는데 이 때 구세주처럼 등장한 게 Module Bundler이다.Bundle은 ‘꾸러미’라는 의미로 하나로 합친다는 의미를 지니고 있다.Task Runner의 concat은 단순히 소스 코드 자체만을 합치지만 이 Module Bundler는 모듈 간의 관계를 전부 파악해서 단일 모듈(소스 파일)로 Bundling 해준다.따라서 Task Runner에서는 불가능한데 Module Bundler에서는 다음과 같은 것들이 가능하다. (설명은 Webpack 기준) Code Splitting(코드 분할) 변경률이 적은 서드파티(제이쿼리, 리액트 등등의 라이브러리나 프레임워크)들을 따로 빼서 사용자의 임시 파일에 저장시켜놓고 방문할 때마다 해당 내용을 캐싱하게 끔 해서 좀 더 로딩 속도를 높이기. SPA라고 해도 사용자가 모든 URI를 방문하는 게 아니니 URI 별로 소스 코드를 빼기. 그런데 URI 별로 소스 코드를 빼도 파일의 크기가 너무 작은 경우에는 오히려 요청/응답에 대한 오버헤드가 클 수 있으므로 소스 코드의 최소한의 크기 정하기. Tree Shaking(나무의 가지를 흔들어 썩은 열매를 떨어뜨리 듯, 필요없는 코드들을 삭제하기)쓰지 않는 코드(변수 함수 등등)들이 있는 경우에 자동으로 번들링 할 때는 없애기. 파일의 크기가 작은 경우에는 Data URL로 리소스를 표현하기(폰트, 이미지, svg 등등)웹팩에서는 js 소스만 모듈로 보는 게 아니라 정적인 리소스들(이미지, 폰트, svg 등등)을 모두 모듈로 보고 있다.그래서 이 모듈(정적인 리소스)들을 컨트롤 할 수 있게 된다.그런데 이미지 크기가 너무 작은 경우에는 요청/응답에 대한 오버헤드를 줄이기 위해 sprite image를 이용할 수도 있고, Data URL을 이용할 수도 있다.하지만 sprite image를 만드는 것은 귀찮고 사용하기도 불편할 때가 있다. (이를 위한 플러그인들도 많지만)그래서인지 모던 브라우저에서는 이런 Data URL을 통해서도 그런 오버헤드를 줄일 수 있다.물론 성능은 sprite image가 Data URL보다 더 뛰어난 것으로 알고 있다. 원래 Module Bundler 성격은 모듈과 관련된 것만 다루는 것이었는데 이제는 Task Runner의 기능까지 삼켜서 minify, uglify 등등의 기능까지 흡수를 해서 어지간하면 Module Bundler만 사용해도 될 정도이다.하지만 Module Bundling 이전에 처리해야하는 특수한 경우에는 Task Runner에서 작업들을 처리한 이후에 Module Bundler를 돌려야할 것이다.Module Bundler로는 Webpack, browserify, rollup 등등이 있는데Webpack이 제일 사용자도 많고, github start도 많고, 커뮤니티 활성화도 잘 돼있으므로 Webpack을 공부하는 걸 추천한다. 4. TDD를 공부하자.TDD(Test Driven Development)는 다음과 같은 개발 행위를 말한다. 테스트 코드를 먼저 짠다. 테스트 코드가 통과하게 앱의 코드를 짠다. 이를 통해 얻을 수 있는 장점은 다음과 같다. 내가 구현해야 하는 코드(테스트 통과)가 무엇인지 명확해진다. 코드를 수정해도 잘 돌아갈 거라는 안심이 된다.테스트 코드를 작성하지 않았으면 코드를 수정하고 해당 메소드를 사용하는 부분을 전부 다시 테스트해봐야한다.하지만 테스트 코드들을 작성했다면 해당 테스트를 통과했다면 수정한 메소드를 사용한 부분들이 정상적으로 동작한다고 볼 수 있으므로 심신에 안정이 찾아오게 된다. TDD는 아니더라도 앱의 코드를 먼저 짜더라도 테스트 코드는 반드시 짜는 습관을 들이자.(나부터라도…)하지만 많은 사람들이 아래와 같은 상황 때문에 TDD를 못하는 것 같다. 테스트 코드 짜는데 시간이 더 걸린다.초기에는 그럴지 몰라도 앱의 규모가 커지거나 유지보수를 생각한다면 TDD가 더 오래 걸리지는 않을 것이다. (더 적게 걸리지 않을 지도…) 어디서부터 어디까지를 테스트해야할지 모르겠어요.저도 모르겠어요… 누가 좀 알려주신다면 ㅠㅠ E2E(End to End) Test는 어떻게 하죠?저도 UI 단 테스트는 안 해봐서 누군가 피드백을 주신다면 수정하겠습니다. 이 TDD를 도와주는 프레임워크로는 jasmine, mocha, chai 등등이 있다.그리고 이러한 테스트를 자동으로 돌려주는 등 위 프레임워크들을 도와주는 Test Runner인 karma가 있다. 마치며내가 컴공을 전공하다 보니 비전공자나 입문자에게는 다소 딱딱하게 들리거나 어렵게 들린 내용이 많을 것이다.다 내가 모르는 게 많아 이런 내용들을 쉽게 풀어내는 능력이 부족하기 때문이다 ㅠㅠ…여튼 글을 보고 궁금한 점, 부족한 점, 잘못된 점 등등은 전부 댓글로 피드백 부탁드립니다~~","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"독학","slug":"독학","permalink":"http://perfectacle.github.io/tags/독학/"}]},{"title":"(자알쓰) JIT 컴파일","slug":"js-jit-compile","date":"2017-08-07T02:53:42.000Z","updated":"2017-08-07T06:16:34.000Z","comments":true,"path":"2017/08/07/js-jit-compile/","link":"","permalink":"http://perfectacle.github.io/2017/08/07/js-jit-compile/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에는 쉬어가는 타임으로 번외편 격인 JIT 컴파일에 대해 간단히 다뤄보았다. 자바스크립트는 인터스크립트 언어이다?책을 보면 위와 같이 말하는 경우가 존재한다.인터스크립트가 뭔데?에서 부터 막힌다면 아래 내용을 봐보자. 컴퓨터는 우리의 소스코드를 어떻게 이해할까?기본적으로 컴퓨터는 기계어(2진수(0과 1)로 이루어진 코드) 밖에 해석하지 못한다.바보 녀석 ㅎㅎ왜 10진수가 아닌 2진수를 사용하게 됐는지 궁금한 사람은 컴퓨터에서 2진수, 8진수, 16진수를 쓰게 된 이유를 참고하자. 따라서 우리가 작성한 var a = &#39;a&#39;라는 코드를 기계어로 바꿔주는 행위를 해야한다.이걸 사람이 직접 바꿔줘야할까…?매우 비효율적이므로 당연히 이를 도와주는 도구가 있는데 그 중 하나가 인터프리터이다. 인터프리트란…?(Interpret)코드를 실행하면서 한 줄 한 줄 기계어로 변환 후 실행하는 걸 인터프리트(Interpret)라고 한다.이 인터프리트하는 녀석을 인터프리터라고 부른다.자바스크립트는 이런 인터프리트 방식을 채택한 프로그래밍 언어였었다. 자바스크립트는 이런 인터프리트 방식을 채택한 프로그래밍 언어였었다라고…?그럼 과거에는 그렇고 지금은 아니라는 말인가…?모던 브라우저의 자바스크립트 엔진은 모두 JIT 컴파일 방식으로 Javascript 코드를 해석하고 있다. 구글에서 개발한 V8(크롬, 오페라와 Node.js) 모질라에서 개발한 TraceMonkey(파이어폭스 3.5+부터 탑재) MS에서 개발한 Chakra(IE9+부터 탑재) Webkit 엔진에 탑재된 JavascriptCore(Safari에 탑재) 컴파일이란…?(Compile)이 JIT 컴파일에 대해 알아보기 이전에 컴파일에 대해 알아보도록 하자.우리가 짠 코드 전체를 한 번에 기계어로 변환해주는 걸 말한다.이러한 일을 컴파일러(Compiler)가 대신해준다. JIT 컴파일이란…?(Just in Time Compile)컴파일 방식과 인터프리트 방식의 장점을 짬뽕한 녀석이라고 보면 된다.컴파일 방식은 기계어로 컴파일 된 코드를 바로 실행하므로 빠른 실행 속도를 보장 받는다.인터프리트 방식은 소스가 수정돼도 귀찮게 매번 컴파일을 하지 않아도 된다는 장점이 존재한다.이 JIT 컴파일 방식은 프로그램을 실행하는 시점에서 필요한 부분을 즉석에서 컴파일하는 방식이라 동적 컴파일(Dynamic Compile)이라고도 부른다.당연히 과거 인터프리트 방식보다 성능 측면에서 향상이 있어서 사용한다고 보면 될 것 같다.인터프리트는 한줄씩 해석 - 실행 - 해석 - 실행의 반복인데JIT 컴파일은 실행할 때 한번에 해석 - 실행이기 때문이다. 결론적으로 자바스크립트가 인터프리트 언어라는 것은 과거에나 먹힐 법한 말이고 모던 브라우저(최신 브라우저)와 Node에서는 JIT 컴파일 언어라로 부르는 것이 맞다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"JIT","slug":"JIT","permalink":"http://perfectacle.github.io/tags/JIT/"}]},{"title":"(자알쓰) 클로저","slug":"js-013-closure","date":"2017-08-07T02:53:42.000Z","updated":"2017-08-09T02:26:28.000Z","comments":true,"path":"2017/08/07/js-013-closure/","link":"","permalink":"http://perfectacle.github.io/2017/08/07/js-013-closure/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 세 번째 시리즈는 클로저를 주제로 진행하겠다. 들어가기 전에프로그래밍 언어에는 지역 변수란 게 존재한다.이 지역변수는 변수의 스코프에 의존적이다.여타 프로그맹 언어에서 변수의 스코프는 {} 블록 단위지만,자바스크립트의 변수의 스코프는 함수 단위이다. (물론 ES6의 const와 let의 스코프는 블록 단위)1234567891011121314// 글로벌 스코프 시작var global = 2;var func = function() &#123; // 로컬 스코프 func 시작 var local = 1; // 로컬 스코프에서는 로컬 스코프와 글로벌 스코프에 접근 가능 console.log(global); console.log(local); // 로컬 스코프 끝&#125;// 글로벌 스코프에서는 글로벌 스코프만 접근 가능console.log(global);console.log(local); // Uncaught ReferenceError: local is not defined// 글로벌 스코프 끝 스코프의 접근 가능한 스코프는 자기 자신을 포함한 상위 스코프이다.글로벌 스코프의 접근 가능한 범위는 글로벌 스코프가 최상위 스코프이므로 글로벌 스코프 자기 자신 밖에 없고,로컬 스코프 func의 접근 가능한 스코프는 자기 자신인 func와 자신의 상위 스코프인 global 스코프가 된다. 왜 이런 현상이 발생할까?이는 전역 변수와 지역 변수가 메모리(RAM)의 어느 영역(Code, Data, Stack, Heap)에 적재되는지와 관련이 있다.전역 변수는 메모리의 Data라는 영역에 적재돼서 프로그램의 종료 시까지 계속 적재돼있다.따라서 어디서나 사용이 가능하다.지역 변수는 메모리의 Stack이라는 영역에 적재되고, 지역 변수의 생명주기(Lifecycle)는 함수 호출 시 생성되고 함수가 종료되면 시스템에 의해 반환된다. 클로저는 왜 쓸까?위와 같이 지역변수는 함수 호출 시 메모리에 할당되고, 함수가 종료되면 메모리에서 해제된다.따라서 지역변수는 호출할 때마다 항상 같은 값으로 초기화된다.하지만 가끔 함수를 호출할 때 이전에 존재했던 값을 유지하고 싶어질 때가 있다.그러려면 함수가 종료됐을 때 해당 지역 변수가 메모리에서 해제되면 안 된다. 클로저는 어떻게 구현해야할까?함수가 종료돼도 지역 변수가 메모리에서 해제되지 않으려면 어떻게 해야할까?이를 위해서는 자바스크립트의 GC(Garbage Collector, 메모리 상에 쓸 데 없는 녀석 수거해가는 녀석)가 어떻게 동작하는지 간단하게나마 알아봐야한다.123var obj = &#123;name: '양간장'&#125;;var obj2 = &#123;name: '간장냥'&#125;;obj = obj2; 3번 라인에서 obj는 {name: &#39;간장냥&#39;}을 참조하게 만들었다.그럼 {name: &#39;양간장&#39;}이라는 데이터는 참조가 불가능 해졌으므로 사용할 방법이 없는 쓸 데 없는 녀석이 된다.이때 저 {name: &#39;양간장&#39;}은 GC(Garbage Collecting) 대상이 되며 GC(Garbage Collector)가 적절한 시점(개발자 도구 열닫 혹은 일정 시간 이후?)에 수거해간다.따라서 메모리 상에서 데이터가 해제되지 않게 하려면 누군가는 해당 녀석을 참조하게 만들어서 GC(Garbage Collecting) 대상에서 제외시켜야한다.이를 위해서는 다음과 같은 조건 제약이 따른다. 조건 1. 참조하는 대상이 참조하는 녀석과 접근 가능한 스코프에 있어야 한다.가령 예를 들어 참조하는 대상({name: &#39;양간장&#39;})과 참조하는 녀석(obj)이 접근 가능한 스코프에 있어야한다는 소리이다.접근 가능한 스코프 상에 존재해야 오류 없이 해당 데이터를 참조할 수 있기 때문이다. 1234567var a = function() &#123; var b = 1;&#125;;var c = function() &#123; console.log(b); // Uncaught ReferenceError: b is not defined&#125;;c(); 로컬 스코프 c의 접근 가능한 스코프는 자신을 포함한 상위 스코프이다. 로컬 스코프 c 전역 스코프따라서 로컬 스코프 c에서 로컬 스코프 b로 접근이 불가능하다. 12345678var a = function() &#123; var b = 1; var c = function() &#123; console.log(b++); // 1 &#125;; c();&#125;;a(); // 1 위 예제에서 로컬 스코프 c가 접근 가능한 스코프는 자신을 포함한 상위 스코프이다. 로컬 스코프 c 로컬 스코프 a 전역 스코프위 코드는 참조하는 대상(b)이 로컬 스코프 a에 있고, 참조하는 녀석(console.log(b))이 로컬 스코프 c에 있다.참조하는 대상(로컬 스코프 a)이 참조하는 녀석(로컬 스포크 c)과 접근 가능한 스코프에 있어야 한다는 조건을 만족하고 있다. 조건 2. 참조하는 대상이 존재하는 함수를 호출하는 게 아니라 참조하는 녀석이 존재하는 함수를 직접 호출해야한다. 12345678910var a = function() &#123; var b = 1; var c = function() &#123; console.log(b++); // 1 &#125;; c();&#125;;a(); // 1a(); // 1a(); // 1 기껏 위와 같이 로컬 스코프와 그 내부 스코프로 나누어서 b의 값을 유지하고자 했는데 함수 a를 호출할 때마다 계속해서 1이 출력된다.우리는 b의 값이 유지돼서 b++을 하고 있으므로 호출할 때마다 1이 상승된 값을 원했는데 그게 아니다.그러기 위해서는 조건 2를 만족시켜주면 된다.즉 참조하는 대상(b)이 존재하는 함수 a를 호출할 게 아니라 참조하는 녀석(console.log(b))이 존재하는 함수 c를 호출해야한다.함수 a를 백날 호출해봤자 지역변수 b를 초기화 시켜주는 구문이 매번 실행되기 때문에 참조를 아무리 한들 b의 값이 유지되는 게 아니다.하지만 스코프의 접근 가능한 스코프는 자신을 포함한 상위 스코프인데 전역 스코프에서 어떻게 로컬 스코프 a에 존재하는 c를 호출할 수 있을까?이는 자바스크립트의 특성인 함수는 first-class-citizen임을 활용하면 된다.전역 스코프에서 c를 호출할 수 있게 하려면 전역 변수와 함수 c 사이에 어떠한 매개체를 뚫어줘야한다.이는 위에서 말한 일급 객체의 특성을 살려 함수 a를 호출했을 때 함수 c(를 호출하는 게 아님)를 리턴함으로써 전역 스코프와 함수 c 사이에 다리를 놔준다고 보면 된다.123456789101112var a = function() &#123; var b = 1; var c = function() &#123; console.log(b++); &#125;; return c;&#125;;a = a();a(); // 1a(); // 2a(); // 3a(); // 4 함수 a를 호출한 결과(내부 함수 c)를 다시 a에 담는 과정이 불필요하다고 생각되니 IIFE(즉시 실행 함수, Immediately Invoked Function Expressions)를 이용하면 아래와 같이 줄일 수 있다.1234567891011var a = (function() &#123; var b = 1; var c = function() &#123; console.log(b++); &#125;; return c;&#125;)();a(); // 1a(); // 2a(); // 3a(); // 4 함수 c를 리턴할 수도 있지만, 아래와 같이 익명함수로 리턴하는 게 대부분이다.12345678910var a = (function() &#123; var b = 1; return function() &#123; console.log(b++); &#125;;&#125;)();a(); // 1a(); // 2a(); // 3a(); // 4 함수 c와 같이 기명 함수를 리턴하는 경우는 함수 내에서 자기 자신을 호출하는 재귀 함수를 구현할 때 뿐인 것 같다.123456789101112var a = (function() &#123; var b = 1; var c = function() &#123; console.log(b++); if(b &lt; 10) c(); &#125;; return c;&#125;)();a(); // 1 2 3 4 5 6 7 8 9a(); // 10a(); // 11a(); // 12 조건 3. 참조하는 대상이 전역 스코프가 아니어야한다.전역 스코프는 어차피 프로그램 종료 시까지 메모리에 계속 할당돼있으므로 상관이 없는 이야기이다. 그래서 클로저가 뭔데?먼저 클로저를 설명하기 보다는 적절한 사용 사례를 설명하고 클로저가 뭔지를 풀어 놓는 게 독자의 흥미를 유발할 거 같아서 일부러 뒤로 배치하였다.클로저는 다음과 같이 정의하고 있다.인사이드 자바스크립트 책에서는 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수,한 블로그에서는 생성 당시의 스코프에 대한 연결을 갖는 블록이라고 정의하고 있다.즉, 위에서 c가 클로저이다.변수 b는 지역 변수이므로 a 함수 종료와 동시에 죽어야하는 변수이다.하지만 그 생명 주기가 끝난 변수(b)를 참조하는 c라는 함수를 사용해서 클로저를 구현하였다. 클로저의 장점 위에서 본 바와 같이 함수를 호출할 때마다 기존에 생성했던 값을 유지할 수 있다. 외부에 해당 변수(참조하고 있는 변수)를 노출시키지 않는다.이게 무슨 장점이냐고 생각한다면 코드의 안정성을 보장해준다는 뜻이다.이는 캡슐화(encapsulation)와도 관련이 있는데 알약을 먹는 사람이 알약만 먹어서 병이 치료만 되면 되지, 그 내부의 내용물은 중요하지 않다는 개념이다.근데 만약 환자가 캡슐을 까서 내용물을 바꾸고 다시 캡슐을 씌우고 그 알약을 먹는다면?? 과연 환자의 상태를 보장할 수 있을까?이렇듯 프로그래밍에서 말하는 캡슐화는 환자가 내용물을 바꾸지 못하게(클로저에서 참조하는 변수를 변경하지 못하게 해서),즉 내가 개발한 소스를 사용하는 입장(내가 될 수도 있고 내가 만든 라이브러리를 사용하는 제 3자가 될 수도 있고)에서 코드의 안정성을 보장받게 되는 것이다.123456789101112// 개발자(약사) 입장에서 짠 코드var a = function() &#123; var b = 1; // 개발자가 변수에 값을 넣었다. (약사가 약의 내용물을 넣었다.) var c = function() &#123; // 클로저를 이용하여 내용을 캡슐화 하였다. (약사가 약들을 캡슐로 감쌌다.) console.log(b++); &#125;; return c; // 사용자(환자)가 해당 변수를 참조만 가능하고(약의 복용만 가능하고), 변경은 불가능하게(캡슐을 까서 그 안의 약물들을 못 갈아치우게) 했다.&#125;;// 실제 사용자(환자)는 해당 변수(약물)을 변경할 수 있는 방법이 없어서 코드의 안정성(환자의 상태)를 보장받을 수 있다.var d = a();d(); 클로저의 단점클로저는 위와 같이 좋은 점도 존재하는데 역시 신은 공평하듯 모든 걸 주시지 않았는데 바로 아래와 같은 단점이 존재하기 때문이다. 클로저로 참조하는 변수는 프로그램 종료 시까지 계속 메모리에 할당돼있다. 그게 뭐 어때서? 라고 생각하는 경우가 있을 수도 있고 위 경우가 크게 문제가 되지 않을 수도 있다.하지만 사용 가능한 메모리(브라우저마다 다르겠지만…)를 초과하는 사태가 발생할 수도 있고, 성능 상 좋다고 말할 수 있는 사항은 아니다.위와 같은 현상이 발생하는 이유는 계속해서 참조를 하고 있으므로 GC(Garbage Collecting) 대상이 되지 않기 때문이다.따라서 클로저는 이러한 성능 이슈를 가지고 있기 때문에 항상 주의를 기울여 사용을 최소화해야하며 오남용해서는 안 된다. 마치며클로저를 알아야 자바스크립트 고수니 중급으로 넘어가느니 등등의 얘기가 많이 들리는 것 같은데 실상 제대로 파고들어가 보면 별 거 아니란 사실을 알 수 있다.하지만 이와 같은 사항들을 알기 위해서는 아래와 같은 사항은 반드시 짚고 넘어가야 할 것이다. 변수의 스코프 변수의 생명주기(Lifecycle) GC(Garbage Collector)가 GC(Garbage Collecting)하는 대상 First Class Citizen","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Closure","slug":"Closure","permalink":"http://perfectacle.github.io/tags/Closure/"}]},{"title":"(상식) 컴퓨터는 어떻게 우리가 작성한 코드를 이해할까?","slug":"how-can-computer-understand-our-source","date":"2017-08-07T01:02:39.000Z","updated":"2017-08-07T06:12:39.000Z","comments":true,"path":"2017/08/07/how-can-computer-understand-our-source/","link":"","permalink":"http://perfectacle.github.io/2017/08/07/how-can-computer-understand-our-source/","excerpt":"","text":"기본적으로 컴퓨터는 기계어(2진수(0과 1)로 이루어진 코드) 밖에 해석하지 못한다.바보 녀석 ㅎㅎ왜 10진수가 아닌 2진수를 사용하게 됐는지 궁금한 사람은 컴퓨터에서 2진수, 8진수, 16진수를 쓰게 된 이유를 참고하자. 따라서 우리는 우리가 짠 코드를 기계어로 바꾸는 행위를 해야한다.우리의 뇌는 이렇게 좋지도 않고, 효율성 측면에서 이러한 행위를 도와주는 도구가 세 가지가 있다. 1. 컴파일(Compile)우리가 짠 코드 전체를 기계어로 변환해주는 걸 말한다.이러한 일을 컴파일러(Compiler)가 대신해준다.언어에 의존적이므로 C언어 컴파일러, Java 컴파일러 이렇게 따로 따로 존재한다. 링크(Link)우리의 프로그램은 여러 모듈들의 조합으로 이루어져있다.하지만 컴파일러는 각 모듈들을 컴파일만 해줄 뿐, 합쳐주는 역할을 하진 않는다.따라서 이 링크는 여러 모듈들을 단일 프로그램으로 합치는 걸 말한다.링크 하는 프로그램을 링커(Linker)라고 부른다.링커가 링크한 결과로 단일 실행 파일인 *.exe 등등이 만들어진다. 로드(Load)단일 실행 파일을 메모리에 적재(Load)시키는 걸 말한다.로더(Loader)가 이런 일을 한다. 컴파일 언어의 동작 방식코딩 - 컴파일(컴파일러에 의해) - 링크(링커에 의해) - 로드(로더에 의해) 2. 인터프리트(Interpret)컴파일 방식은 실행 이전에 컴파일 과정을 거쳐야하므로 시간이 더 소요된다.또한 내용을 바꿀 때마다 계속 컴파일을 해줘야한다는 단점이 존재한다.하지만 인터프리트 방식은 소스 코드가 바뀌어도 컴파일 해주지 않아도 된다.실행하면서 한 줄 한 줄 해석해(인터프리트, Interpret)나가기 때문이다.이 인터프리트 해주는 녀석을 인터프리터(Interpreter)라고 부른다.Javascript가 이에 속했다. (모던한 환경이라면 아니라는 소리다.)하지만 단점으로 한 줄 한 줄 해석하고 실행하기 때문에 컴파일 된 파일을 실행하는 것보다는 느리다는 문제점이 존재한다. 3. JIT 컴파일(Just in Time Compile)컴파일 방식과 인터프리트 방식의 장점을 짬뽕한 녀석이라고 보면 된다.컴파일 방식은 기계어로 컴파일 된 코드를 바로 실행하므로 빠른 실행 속도를 보장 받는다.인터프리트 방식은 소스가 수정돼도 귀찮게 매번 컴파일을 하지 않아도 된다는 장점이 존재한다.이 JIT 컴파일 방식은 프로그램을 실행하는 시점에서 필요한 부분을 즉석에서 컴파일하는 방식이라 동적 컴파일(Dynamic Compile)이라고도 부른다.자바의 경우 소스코드(*.java) 파일을 JVM(Java Virtual Machine)이 이해할 수 있는 자바 바이트 코드(*.class)로 변환한다.하지만 컴퓨터는 자바 바이트 코드를 해석하지 못한다.따라서 JVM에서는 실행될 때 자바 바이트 코드를 기계어로 해석해주는 JIT 컴파일 방식을 채택했다.또한 Javascript에서도 JS 엔진(Javascript 코드를 해석해주는 역할을 담당하며 브라우저에 의존적이다.) 중에서는 아래와 같은 녀석들이 JIT 컴파일 방식을 채택했다. 구글에서 개발한 V8(크롬, 오페라와 Node.js) 모질라에서 개발한 TraceMonkey(파이어폭스 3.5+부터 탑재) MS에서 개발한 Chakra(IE9+부터 탑재) Webkit 엔진에 탑재된 JavascriptCore(Safari에 탑재)","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"JIT","slug":"JIT","permalink":"http://perfectacle.github.io/tags/JIT/"},{"name":"IT","slug":"IT","permalink":"http://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"http://perfectacle.github.io/tags/Computer/"},{"name":"기계어","slug":"기계어","permalink":"http://perfectacle.github.io/tags/기계어/"},{"name":"컴파일","slug":"컴파일","permalink":"http://perfectacle.github.io/tags/컴파일/"},{"name":"인터프리터","slug":"인터프리터","permalink":"http://perfectacle.github.io/tags/인터프리터/"}]},{"title":"(상식) 왜 1byte는 8bit일까?","slug":"why-1byte-is-8bit","date":"2017-08-07T00:02:39.000Z","updated":"2017-08-07T04:55:28.000Z","comments":true,"path":"2017/08/07/why-1byte-is-8bit/","link":"","permalink":"http://perfectacle.github.io/2017/08/07/why-1byte-is-8bit/","excerpt":"","text":"과거에는 1byte가 7bit, 9bit 등등이던 시절이 있다고 하지만 현재는 8비트로 거의 표준이 된 것 같다.왜일까?이 포스트는 아래 링크를 참조하여 제 머릿 속을 바탕으로 글을 썼기 때문에 틀린 점이 있다면 댓글로 적어주길 바랍니다~ 아스키(Ascii) 메모리 하나당 차지하는 바이트 수에 대해 궁금한 점이 있습니다. 메모리 주소당 데이터용량이 1바이트인 이유가 먼가요?? 1바이트는 왜 8비트일까? 컴퓨터는 미국에서 개발했다.따라서 미국 특화(+유럽권과의 통신 등등을 고려하여 유렵권까지 특화)해서 만들었다.따라서 아시아나 아프리카 등등에는 별로 특화돼있지 않았다. (지금은 많이 완화된 것 같지만…)1byte의 bit 수를 결정 짓는 결정적인 요인은 아마 ASCII라는 문자 인코딩 때문일 것이다.ASCII는 미국권 문자를 표현하는 문자 인코딩(문자의 집합)인데 통신을 위한 기호와 특수기호 + 숫자 + 알파벳 대소문자를 표현할 수 있다.당연히 미국에서 개발했으니 미국에서 쓰이는 문자만 표현하면 되는 것이었다.이 ASCII를 표현하는데는 7bit(128자)로 충분했고, 이 ASCII를 베이스로 byte(하나의 문자를 담는 단위)가 결정된 게 아닐까 싶다. 그렇다면 왜 1byte는 7bit가 아닌 8bit일까?내가 내린 추측은 아래 두 가지이다. 데이터 송수신의 오류를 검출하기 위한 패리티 비트로 1비트가 추가됐다. 유럽권을 고려해서 확장 아스키 코드를 베이스로 정했다.유럽권 문자까지 표현하는데 8bit(256자)면 충분하다고 여겨서 정한 것 같다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"http://perfectacle.github.io/tags/Computer/"}]},{"title":"(상식) 컴퓨터에서 2진수, 8진수, 16진수를 쓰게 된 이유","slug":"computer-number-making-reason","date":"2017-08-06T23:02:39.000Z","updated":"2017-08-07T04:40:40.000Z","comments":true,"path":"2017/08/07/computer-number-making-reason/","link":"","permalink":"http://perfectacle.github.io/2017/08/07/computer-number-making-reason/","excerpt":"","text":"여러 책을 보고 혼자서 내린 결론이기 때문에 틀릴 가능성이 있으니 지적해주면 감사하겠습니다 ^^ 최초의 컴퓨터는 10진수를 사용했다.나는 처음부터 2진수를 사용한 줄 알았는데 최초의 컴퓨터인 에니악은 10진수를 사용했다고 한다.아마도 우리의 손가락이 10개이고 평상시에 연산을 할 때도 10진수를 주로 사용하기 때문에 익숙해서 10진수를 사용했던 게 아닐까? 그럼 왜 컴퓨터는 2진수를 사용하게 됐을까?전기회로는 전압이 불안정해서 전압을 10단계로 나누어 처리하는데 한계가 있다.따라서 에니악과 에드삭은 10진수를 이용했던 데 반해그 후속 시리즈인 에드박은 전압을 2단계로 나누어 처리하는 2진수를 사용하였다.즉, 전기가 흐르면 1, 전기가 흐르지 않으면 0만으로 동작하게 설계하게 된 것이다.결론을 내리자면 전기회로는 전압이 불안정해서 전압을 두 단계로 나누어 처리하는 게 안정적이다 보니 2진수를 사용하게 된 것이다. 8진수, 16진수는 왜 생겼을까? 4진수는 왜 안 쓰이는 것일까?2진수는 숫자를 표현하기 위해 상당히 많은 자릿수를 차지한다.코딩할 때도 이렇게 많은 자릿수는 가독성을 해칠 수 있다.따라서 이런 단점을 보완하기 위해 8진수와 16진수가 등장했다.그렇다면 왜 8진수와 16진수일까?2진수 2자리로는 4진수를2진수 3자리로는 8진수를2진수 4자리로는 16진수를 표현할 수 있다.2진수 2자리는 그닥 많은 자릿수를 절약할 수 없어서 사용을 안 하게 된 게 아닐까 싶다…8진수를 사용하는 대표적인 예는 리눅스나 FTP 등에서 파일이나 폴더에 관한 권한을 표현하기 위해 많이 쓰인다.777 을 예로 들면r 읽기 허용(4) w 쓰기 허용(2) x 실행 허용(1) 을 다 더하면 7이 나오고u 사용자(소유자) g 그룹 o 기타(사용자와 그룹을 제외한 사람) 순서로 기술하면 된다.16진수를 사용하는 대표적인 예는 rgb 컬러 코드(#ff00ff), 유니코드(\\u0061, U+0061, 0x0061 등등)에서 쓰인다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"http://perfectacle.github.io/tags/Computer/"},{"name":"진법","slug":"진법","permalink":"http://perfectacle.github.io/tags/진법/"}]},{"title":"(자료구조) Queue를 만들어보자!","slug":"queue-making","date":"2017-08-06T03:03:03.000Z","updated":"2017-08-06T03:46:56.000Z","comments":true,"path":"2017/08/06/queue-making/","link":"","permalink":"http://perfectacle.github.io/2017/08/06/queue-making/","excerpt":"","text":"큐는 스택과 반대로 선입선출(FIFO, First In First Out)의 구조를 가지는 자료구조이다.먼저 들어온 놈이 먼저 나가는 구조이니 입력 순서에 따른 처리를 위한 자료에서 많이 사용한다. (OS의 프로세스 스케쥴링)스택과 비교해보면 push 대신에 offer, pop 대신에 offer를 메소드를 사용한다. 만들어보자!기본적으로 큐를 만들어보기 전에 먼저 링크드리스트에 대해 알아야한다.기존에 스택처럼 생각했을 때 두 가지 데이터를 들고 있어야했다. 인덱스(몇 번째에 데이터를 삽입하고 뽑아낼지) 실제 데이터 덩어리이 경우에는 데이터를 기존의 스택 크기보다 많이 삽입했을 때만 복사가 이루어졌다.하지만 큐의 경우에는 스택과 같이 두 개의 데이터만 들고 있다고 가정했을 때데이터를 기존의 스택 크기보다 많이 삽입했을 때만 복사가 이루어지는 건 당연하고,데이터를 꺼낼 때 처음 인덱스의 데이터를 꺼내야하는데 그렇게 되면 이가 빠진 것처럼 왼쪽이 비기 때문에 전부 한 칸씩 땡겨야한다.즉, 데이터를 삽입/삭제(추출?) 할 때 모두 큰 비용을 들이게 된다.따라서 큐를 구현할 때는 스택에서 출발할 게 아니라 링크드리스트에서 출발을 해야한다.링크드리스트의 구조 대로 구현하면 삽입/삭제가 용이하기 때문이다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"http://perfectacle.github.io/categories/Middle-end/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"http://perfectacle.github.io/categories/Middle-end/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://perfectacle.github.io/tags/자료구조/"},{"name":"Queue","slug":"Queue","permalink":"http://perfectacle.github.io/tags/Queue/"}]},{"title":"(자료구조) List - LinkedList를 만들어보자!","slug":"linked-list-making","date":"2017-08-06T02:03:03.000Z","updated":"2017-08-06T16:25:08.000Z","comments":true,"path":"2017/08/06/linked-list-making/","link":"","permalink":"http://perfectacle.github.io/2017/08/06/linked-list-making/","excerpt":"","text":"List는 데이터를 순차적으로 저장하므로 선형 구조(한 줄로 계속 되며, 데이터가 끊어지지 않음)이다.또한 여기서 말하는 노드는 하나의 데이터 덩어리라고 보면 될 것 같다. LinkedList란…?LinkedList는 스택의 다음과 같은 단점을 극복하고자 만들어졌다. 노드의 끝 부분을 제외한 곳에 데이터 삽입스택은 끝 부분에만 데이터를 삽입할 수 있으므로 중간에 데이터를 삽입할 방법이 존재하지 않았다.LinkedList는 배열의 이러한 단점을 노드(배열의 각 요소)가 다음 주소지를 알게 함으로써 그 단점을 극복하였다. 하지만 신은 공평하듯, 이 LinkedList에도 다음과 같은 장/단점이 있다. 데이터의 접근 속도가 느리다.LinkedList는 다음 노드에 대한 참조만을 가지고 있다.따라서 255 번째 노드의 데이터를 불러오려면 처음부터 순차적으로 255 번째 노드까지 접근해야한다.배열에 비해 이러한 접근 속도가 매우 느리다. 다음 노드에 대한 참조만 있을 뿐, 이전 노드에 대한 데이터는 없다.따라서 이전 노드의 값을 가져올 수는 없다.이는 Doubly Linked List라는 이중 링크드 리스트라는 자료구조를 만들어 해결하였다. 처음 노드에서 마지막 노드로, 혹은 마지막 노드에서 처음 노드로 가려면 시간이 오래 걸린다.Doubly Linked List를 이용해도 순차적인 접근 밖에 되지 않기 때문에 어쨌든 계속해서 노드들을 타고 타고 끝이나 처음으로 이동해야 한다.이러한 단점을 극복하기 위해 처음 노드에 대한 이전 참조를 마지막 노드로, 마지막 노드에 대한 다음 참조를 처음 노드로 이어줘 원형 구조로 만든 Doubly Circular Linked List가 있다. 따라서 이 LinkedList를 잘 살리려면 중간에 삽입/삭제가 빈번하며 검색을 자주 하지 않는 자료를 담을 때 사용해야한다. 만들어보자!먼저 기본적인 Node부터 만들어보았다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Node &#123; private Object value; private Node next; Node(Object o) &#123; this.value = o; &#125; public Object getValue() &#123; return value; &#125; public void setValue(Object o) &#123; this.value = o; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; boolean isLast() &#123; // 마지막 노드인지 return this.next == null; &#125; public boolean equals(Node node) &#123; // 내용물과 참조하는 애가 같은지 return value.equals(node.getValue()) &amp;&amp; next == node.getNext(); &#125;&#125;class NodeTest &#123; public static void main(String[] args) &#123; Node n = new Node(2); Node n2 = new Node(2); Node n3 = new Node(2); Node n4 = new Node(3); n.setNext(n4); // n 다음에 n4 n2.setNext(n4); // n2 다음에 n4 n3.setNext(n); // n3 다음에 n System.out.println(n.equals(n2)); // true System.out.println(n.equals(n3)); // false System.out.println(n.isLast()); // false System.out.println(n4.isLast()); // true // 지금 구조(List)는 n3(2) 다음에 n(2) 다음에 n4(3) 순으로 연결(Linked)돼있다. // 초기 노드를 지정해주고, 계속해서 다음 노드를 참조하는 걸 증감식에 적어줌, for(Node node = n3; true; node = node.getNext()) &#123; // 탈출 조건이 있는 무한 반복문 // 마지막 노드여도 출력까지는 해줘야함. System.out.println(node.getValue()); // 2 2 3 if(node.isLast()) break; &#125; &#125;&#125; 그 다음엔 LinkedList를 만들어보았다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114class LinkedList &#123; private Node[] nodes; private int idx; // 현재 리스트의 몇 번째 요소까지 노드가 들어왔는지 확인하는 변수 LinkedList() &#123; this(10); // 기본적으로 10개를 만들어주자, 너무 작게 만들면 복사하는 처리 비용이 많이 들테니... &#125; LinkedList(int size) &#123; nodes = new Node[size]; &#125; void add(Object o) &#123; // 맨 끝에 삽입하는 경우 int size = size(); Node node = new Node(o); // 꽉차지 않았다면 if(idx != size) nodes[idx] = node; // 현재 인덱스에 노드 삽입. else &#123; // 꽉 찼으면 Node[] tmpNodes = new Node[size+10]; // 나중에 또 금방 복사하지 않게 적절하게 큰 배열을 만들자. for(int i=0; i&lt;size; i++) tmpNodes[i] = nodes[i]; // 기존의 값들을 새로운 배열에 복사 tmpNodes[idx] = node; // 새로운 값 삽입 nodes = tmpNodes; // 복사한 배열을 원본 배열 변수로 갈아치우기 &#125; if(idx == 0) &#123; idx++; return; // 하나만 넣은 거면 참조 관계를 수정할 필요가 없음. &#125; nodes[idx-1].setNext(nodes[idx++]); // 이전 노드의 참조를 현재 노드로 변경 &#125; void add(int idx, Object o) &#123; // 인덱스를 지정해 해당 지점에 삽입하려는 경우 // List는 선형구조이므로 데이터를 삽입해야할 인덱스보다 더 뒤에 노드를 삽입하는 것은 불가능하다. // 당연히 배열의 인덱스를 벗어나는 음수도 불가능하다. if(this.idx &lt; idx || idx &lt; 0) throw new ArrayIndexOutOfBoundsException(\"올바른 인덱스를 입력해주세요!\"); // 배열의 중간에 노드를 삽입하는 게 아닌 경우 if(idx == this.idx) this.add(o); else &#123; // 배열의 중간에 노드를 삽입하는 경우 int size = size(); Node node = new Node(o); // 꽉 차지 않았다면 기존과 동일한 사이즈의 배열 생성, 아니라면 넉넉히 길이가 10 더 긴 배열 생성. Node[] tmpNodes = idx != size ? new Node[size] : new Node[size+10]; // 복사할 배열을 직접 넘겨줘서 추가하기. for(int i=0; i&lt;idx; i++) tmpNodes[i] = nodes[i]; // idx 이전까지는 그대로 복사 for(int i=idx; i&lt;this.idx; i++) &#123; // last까지 복사 tmpNodes[i+1] = nodes[i]; // idx 이후는 한 칸씩 밀어서 복사 &#125; tmpNodes[idx] = node; // 새로운 배열에 지금 들어온 노드 삽입 nodes = tmpNodes; // 복사한 배열을 원본 배열 변수로 갈아치우기 nodes[idx].setNext(nodes[idx-1].getNext()); // idx 노드는 중간에 끼어들었으므로 idx 노드 이전 노드의 참조를 가리켜야함. nodes[idx-1].setNext(nodes[idx]); // idx 이전 노드의 참조는 idx 노드를 가리키고 있어야함. this.idx++; &#125; &#125; void remove() &#123; nodes[--idx] = null; // 마지막 노드 삭제 후 인덱스 1 낮춤. nodes[idx-1].setNext(null); // 이전 노드가 마지막 노드이므로 참조할 노드가 없음. &#125; void remove(int idx) &#123; Node[] tmpNodes = new Node[size()]; // 배열을 한 칸씩 땡겨야하므로 새롭게 배열 생성. Node node = getNode(idx).getNext(); // idx 번째 노드가 갖고 있는 참조 노드 for(int i=0; i&lt;idx; i++) tmpNodes[i] = nodes[i]; // idx 이전까지 복사 for(int i=idx+1; i&lt;this.idx; i++) tmpNodes[i-1] = nodes[i]; // idx 이후로 또 복사 nodes = tmpNodes; // 복사한 배열을 원본 배열 변수로 갈아치우기 nodes[idx-1].setNext(node); this.idx--; &#125; Object get(int idx) &#123; Node node = getNode(idx); return node == null ? null : node.getValue(); &#125; Node getNode(int idx) &#123; Node node=nodes[0]; // idx까지 계속 다음 참조 노드를 구함. for(int i=0; i&lt;idx; i++, node=node.getNext()); return node; &#125; int size() &#123; return nodes.length; &#125;&#125;class LinkdedListTest &#123; public static void main(String[] args) &#123; LinkedList l = new LinkedList(); l.add(1); l.add(\"a\"); System.out.println(l.get(0)); // 1 // 0번째 노드를 구하고 그 참조 노드를 구하고 값을 얻기 System.out.println(l.getNode(0).getNext().getValue()); // a for(int i=0; i&lt;10; i++) l.add(i); // 1 a 0 1 2 3 4 6 7 8 9 System.out.println(l.get(11)); // 9 l.add(11, 22); System.out.println(l.get(11)); // 22 LinkedList l2 = new LinkedList(); l2.add(1); l2.add(2); l2.add(3); l2.add(4); System.out.println(l2.get(3)); // 4 l2.remove(); System.out.println(l2.get(3)); // null System.out.println(l2.get(1)); // 2 l2.remove(1); System.out.println(l2.get(1)); // 3 &#125;&#125; 틀린 게 많을지는 모르겠지만…일단은 구현을 했다는 것에 의의를 두고 나중에 다시 수정해야겠다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"http://perfectacle.github.io/categories/Middle-end/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"http://perfectacle.github.io/categories/Middle-end/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://perfectacle.github.io/tags/자료구조/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://perfectacle.github.io/tags/LinkedList/"},{"name":"List","slug":"List","permalink":"http://perfectacle.github.io/tags/List/"}]},{"title":"(자료구조) List - Stack(Pushdown List)을 만들어보자!","slug":"stack-making","date":"2017-08-05T09:44:56.000Z","updated":"2017-08-06T04:23:50.000Z","comments":true,"path":"2017/08/05/stack-making/","link":"","permalink":"http://perfectacle.github.io/2017/08/05/stack-making/","excerpt":"","text":"List는 데이터를 순차적으로 저장하므로 선형 구조(한 줄로 계속 되며, 데이터가 끊어지지 않음)이다. 스택이란…?스택은 후입선출(LIFO, Last In First Out)의 구조를 가지는 자료구조이다.기본적으로 배열이 스택의 구조로 이루어져있고, CPU가 연산을 할 때 연산자에 우선순위 메겨놓고 연산할 때도 스택을 이용하는 것으로 알고 있다.그리고 프로그래밍을 배우다 보면 콜스택이라고 해서 함수의 실행 컨텍스트(EC, Execution Context)가 계속해서 쌓이는데 그 콜스택도 스택이라는 자료구조를 이용하고 있다.몇 번째에다가 데이터를 넣어야하고, 몇 번째에서 데이터를 빼야할지에 대한 인덱스(포인터)를 가지고 있어야한다.데이터 처리를 먼저하고 인덱스를 바꾸는 경우와 인덱스를 바꾸고 데이터를 처리하는 방식이 있다.기본적으로 push()라는 메소드로 데이터를 넣고 pop()라는 메소드로 데이터를 뺀다. 만들어보자!아직은 쉬운 자료구조라 그런지 만드는데 재미있었다 ㅎㅎArray도 스택 구조로 이루어져있는 만큼 자바로 구현하면 ArrayList를 상속 받으면 쉽게 구현이 가능하다.또한 기존에 만들었던 스택의 크기보다 더 많은 데이터를 삽입할 경우에는 더 큰 스택을 만들고 기존의 스택을 복사해야하는데 이 때도 자바의 내장 API를 사용하면 매우 쉽게 구현이 가능하다.하지만 자료구조를 만드는 것은 알고리즘을 향상 시키기 위한 목적도 있기 때문에 최대한 이런 내장 API나 라이브러리들은 배제하고 만들어보았다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Stack &#123; Object[] objs; int idx = 0; // 현재 스택이 몇 번째 인덱스를 가리키고 있는지(넣고 올린다, 올리고 넣는 게 아니라) public Stack() &#123; this(10); // 기본적으로 10개를 만들어주자, 너무 작게 만들면 복사하는 처리 비용이 많이 들테니... &#125; public Stack(int i) &#123; if(i &lt; 1) throw new ArrayIndexOutOfBoundsException(\"스택의 크기는 자연수여야합니다!\"); objs = new Object[i]; &#125; void push(Object obj) &#123; int len = objs.length; // 꽉 차지 않았다면 if(idx != len) objs[idx++] = obj; else &#123; // 꽉 찼으면 Object[] tmpObjs = new Object[len+10]; // 나중에 또 금방 복사하지 않게 적절하게 큰 배열을 만들자. for(int i=0; i&lt;len; i++) tmpObjs[i] = objs[i]; tmpObjs[idx++] = obj; objs = tmpObjs; &#125; &#125; Object pop() &#123; if(idx == 0) throw new ArrayIndexOutOfBoundsException(\"스택에 들어와있는 값이 없습니다!\"); Object obj = objs[--idx]; objs[idx] = null; return obj; &#125; int size() &#123; return objs.length; &#125; void setSize(int i) &#123; int len = objs.length; int copyLen = i &gt; len ? len : i; // 몇 개를 복사해야할지 if(i &lt; 1) throw new ArrayIndexOutOfBoundsException(\"스택의 크기는 자연수여야합니다!\"); if(i == len) return; Object[] tmpObjs = new Object[i]; for(int j=0; j&lt;copyLen; j++) tmpObjs[j] = objs[j]; objs = tmpObjs; &#125; boolean empty() &#123; return objs[0] == null; &#125;&#125;class StackTest &#123; public static void main(String[] args) &#123; Stack s = new Stack(); System.out.println(s.size()); // 10 s = new Stack(20); System.out.println(s.size()); // 20 // 자연수가 아니라 ArrayIndexOutOfBoundsException 예외를 뱉게 했는데 맞을라나 ㅠㅠ // s = new MyStack(0); s.setSize(4); System.out.println(s.size()); // 4 // 자연수가 아니라 ArrayIndexOutOfBoundsException 예외를 뱉게 했는데 맞을라나 ㅠㅠ // s.setSize(-1); // 들어와 있는 값이 없으므로 예외 던짐 // s.pop(); for(int i=0; i&lt;9; i++) &#123; // 스택의 길이보다 긴 데이터를 넣어보자. s.push(i%3); &#125; // 0 1 2 0 1 2 0 1 2 while(!(s.empty())) System.out.print(s.pop() + \" \"); System.out.println(); System.out.println(s.empty()); // true &#125;&#125; 심심하니까 자스로도 만들어보자 ㅎㅎ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const Stack = class &#123; constructor(size=10) &#123; if(size &lt; 1) throw RangeError(\"스택의 크기는 자연수여야합니다!\"); this.objs = new Array(size); this.idx = 0; &#125; push(obj) &#123; const len = this.objs.length; // 꽉 차지 않았다면 if(this.idx !== len) this.objs[this.idx++] = obj; else &#123; // 꽉 찼다면 const tmpObjs = new Array(len+10); for(let i=0; i&lt;len; i++) tmpObjs[i] = this.objs[i]; tmpObjs[this.idx++] = obj; this.objs = tmpObjs; &#125; &#125; pop() &#123; if(this.idx === 0) throw RangeError(\"스택에 들어와있는 값이 없습니다!\"); const obj = this.objs[--this.idx]; this.objs[this.idx] = null; return obj; &#125; size() &#123; return this.objs.length; &#125; setSize(i) &#123; const len = this.objs.length; const copyLen = i &gt; len ? len : i; // 몇 개를 복사해야할지 // const copyLen = Math.min(i, len); if(i &lt; 1) throw RangeError(\"스택의 크기는 자연수여야합니다!\"); if(i === len) return; const tmpObjs = new Array(i); for(let j=0; j&lt;copyLen; j++) tmpObjs[j] = this.objs[j]; this.objs = tmpObjs; &#125; empty() &#123; return this.objs[0] === null; &#125;&#125;;let s = new Stack();console.log(s.size()); // 10s = new Stack(20);console.log(s.size()); // 20// s.setSize(0);s.setSize(2);console.log(s.size()); // 2for(let i=0; i&lt;9; i++) s.push(i%3);while(!(s.empty())) console.log(s.pop()); // 2 1 0 2 1 0 2 1 0console.log(s.empty()); // true","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"http://perfectacle.github.io/categories/Middle-end/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"http://perfectacle.github.io/categories/Middle-end/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://perfectacle.github.io/tags/자료구조/"},{"name":"Stack","slug":"Stack","permalink":"http://perfectacle.github.io/tags/Stack/"}]},{"title":"(Java) 자바의 정석 3판 015일차 - 유용한 클래스, 날짜와 시간 & 형식화, 컬렉션","slug":"Java-study-015day","date":"2017-08-05T06:17:49.000Z","updated":"2017-08-08T06:58:25.000Z","comments":true,"path":"2017/08/05/Java-study-015day/","link":"","permalink":"http://perfectacle.github.io/2017/08/05/Java-study-015day/","excerpt":"","text":"java.util 패키지Random 클래스12345678910111213import java.util.Random;class Test &#123; public static void main(String[] args) &#123; // 두 코드는 일치 double r = Math.random(); double r2 = new Random().nextDouble(); // 두 코드는 일치 double r3 = (Math.random() * 6) + 1; double r4 = new Random().nextInt(6) + 1; &#125;&#125; Random 클래스도 내부적으로 Math.random() 메소드를 사용하고 있다.또 Random 클래스는 seed를 지정해 동일한 난수를 반환받을 수 있다.1234567891011class Test &#123; public static void main(String[] args) &#123; // 동일한 seed를 지정 double r = new Random(122).nextInt(3); double r2 = new Random(122).nextInt(3); // Random 클래스를 썼지만 두 난수는 동일하고, 항상 같은 2.0이란 결과가 나온다. System.out.println(r); System.out.println(r2); &#125;&#125; 기본적으로 seed를 지정해주지 않으면 다음과 같은 생성자를 호출한다.123public Random() &#123; this(System.currentTimeMillis());&#125; seed 값으로 현재 컴퓨터 시간을 밀리세컨드 단위로 넘겨주고 있다. regex 패키지정규식(Regular Expression)을 위한 패키지이다.정규식은 Unix에서 사용했었고, Perl의 강력한 기능이었는데 요즘엔 웬만한 언어에서는 지원하는 것 같다. 12345678910class Test &#123; public static void main(String[] args) &#123; String[] data = &#123;\"bat\", \"baby\", \"bonus\", \"cA\", \"ca\", \"co\", \"c.\"&#125;; Pattern p = Pattern.compile(\"c[a-z]\"); // c로 시작하고 그 뒤에 소문자가 오는 문자열 찾기. for(String dat : data) &#123; Matcher m = p.matcher(dat); if(m.matches()) System.out.println(dat); // ca co &#125; &#125;&#125; Pattern은 정규식을 정의하는데 사용되고, Matcher는 정규식 패턴을 데이터와 비교하는 역할을 한다.matcher의 매개변수로는 CharSequence 인터페이스의 구현체인 CharBuffer, String, StringBuffer가 있다. 12345678910111213class Test &#123; public static void main(String[] args) &#123; String source = \"HP:011-1111-1111, HOME:02-999-9999\"; String pattern = \"(0\\\\d&#123;1,2&#125;)-(\\\\d&#123;3,4&#125;)-(\\\\d&#123;4&#125;)\"; // ()로 그룹핑이 가능하다. Pattern p = Pattern.compile(pattern); Matcher m = p.matcher(source); while(m.find()) &#123; // group 메소드가 있어서 몇 번째 그룹에 속했는지도 출력이 가능하다. System.out.println(m.group() + \" -&gt; \" + m.group(1) + \", \" + m.group(2) + \", \" + m.group(3)); &#125; &#125;&#125; StringTokenizer 클래스문자열을 구분자(delimiter)를 기준으로 토큰이라는 여러 개의 문자열로 잘라내는 데 사용한다.123456789class Test &#123; public static void main(String[] args) &#123; String source = \"100,200 300\"; StringTokenizer t = new StringTokenizer(source, \", \"); // 쉼표와 공백 하나 하나가 구분자가 된다. while(t.hasMoreTokens()) &#123; System.out.println(t.nextToken()); &#125; &#125;&#125; java.math 패키지아래 두 클래스는 String 클래스와 마찬가지로 immutable이다. BigInteger 클래스int 배열을 통해 값을 다뤄서 long 보다 크지만 성능은 떨어진다. BigDecimal 클래스부동소수점이 정밀도에 따른 오차를 가지고 있어서 실수 연산은 정수로 변환 후 계산하는 게 더 낫다.이 BigDecimal 클래스도 정수를 이용해서 실수를 표현해 그 오차를 줄였다. 형식화소수점 n 번째 자리에서 반올림 하려면 곱하고 나누고 뻘짓을 하고 쿵짝쿵짝 덩기덕 쿵더러러러를 해야했다.매우 귀찮은데 이런 것들을 형식화해서 보여주는 클래스가 형식화 클래스이며 java.text 패키지 안에 존재한다.엑셀에서 % 붙이고 원화 붙이고 1,000처럼 보여주기 등등의 경우에 해당한다. DecimalFormat: 십진수 형식화 클래스, 실수 정수 다 가능하다. 123456789101112131415161718class Test &#123; public static void main(String[] args) throws ParseException &#123; // 기존 방법 double d = 1.235678; int i = (int)(d * 1000)+5; d = i / 1000.0; System.out.println(d); // 1.24 // 방법 1 DecimalFormat df = new DecimalFormat(\"#.##\"); System.out.println(df.format(d)); // 1.24 // 방법 2 Number n = df.parse(\"\"+d); double d2 = n.doubleValue(); System.out.println(d2); &#125;&#125; SimpleDateFormat: 날짜와 시간 관련 형식화 클래스. 12345678910class Test &#123; public static void main(String[] args) throws ParseException &#123; Date today = new Date(); SimpleDateFormat sd = new SimpleDateFormat(\"yyyy-MM-dd\"); System.out.println(sd.format(today)); // 2017-08-05 Date d = sd.parse(\"2017-08-05\"); System.out.println(d); // Sat Aug 05 00:00:00 KST 2017 &#125;&#125; ChoiceFormat: 특정 범위에 속하는 값을 문자열로 변환해준다. MessageFormat: 데이터를 정해진 양식에 맞게 출력할 수 있도록 도와준다. 1234567891011121314class Test &#123; public static void main(String[] args) throws ParseException &#123; String msg = \"Name: &#123;0&#125;, Age: &#123;1&#125;\"; Object[] arg = &#123;\"양간장\", 25&#125;; String res = MessageFormat.format(msg, arg); System.out.println(res); // Name: 양간장, Age: 25 MessageFormat mf = new MessageFormat(msg); Object[] arg2 = mf.parse(res); for(Object arg3:arg2) &#123; System.out.println(arg3); // 양간장 25 &#125; &#125;&#125; 날짜와 시간JAVA8부터는 java.time 패키지의 등장으로 인해 Date와 Calendar 클래스를 배울 필요가 없다고 생각하지만…이미 그 클래스를 쓴 레거시 코드들이 많아서 배워야한다 ㅠㅠDate는 JAVA1부터 나와서 굉장히 허접해서 Calendar 클래스가 나왔고 Date 클래스도 많이 발전했다고는 한다.필요하면 찾아서 보자~ java.time 패키지Calendar 클래스는 immutable이 아니라 멀티 쓰레드 환경에서 안전하지 못했다.또한 java.time이 나왔다 하더라도 레거시 코드 때문에 여전히 Date나 Calendar 클래스는 쓰일 것이다 ㅠㅠ 핵심적인 클래스는 다음과 같다.참고로 Calendar 클래스는 ZonedDateTime과 같이 다 들고 있다. LocalDate(날짜) LocalTime(시간) LocalDateTime(날짜 + 시간) ZonedDateTime(날짜 + 시간 + Timezone) InstantDate와 유사한 클래스인데 날짜와 시간을 (나노)초 단위로 표현한다.이렇게 초단위로 표현한 걸 타임스탬프라고 부르고, 하나의 정수로 다룰 수 있어서 DB나 시간 차를 구할 때 많이 사용한다. Period(날짜 - 날짜): 두 날짜 간의 차이를 표현 Duration(시각 - 시각): 두 시각 간의 차이를 표현 객체 생성하기now()와 of()라는 static 메소드를 사용하면 된다.now는 인자 없이 그냥 호출해서 지금 시간의 정보를 구하고, of()는 매개변수를 지정해서 해당 날짜의 정보를 구한다. Temporal 인터페이스와 TemporalAmount 인터페이스LocalDate, LocalTime, LocalDateTime, ZonedDateTime 클래스 등은 Temporal, TemporalAccessor, TemporalAdjuster 인터페이스의 구현체이고,Period, Duration 클래스는 TemporalAmount 인터페이스의 구현체이다.매개변수의 다형성을 이용해 Temporal 인터페이스와 TemporalAmount 인터페이스를 매개변수의 타입으로 지정한 것들이 있는데 잘 보고 쓰면 될 것 같다. Unix Time1970-01-01 00:00:00 UTC로부터 현재 얼마나 시간이 흘렀는지를 초로 환산하여 정수로 표현한 것이다.UTC는 국제 표준으로 시행되는 시간을 표현하는 기준인 것 같은데 1972년 1월 1일부터 시행되다 보니 1970년으로 퉁쳐버린 것 같다.또한 UTC는 Coordinated Universal Time의 약자인데 CUT가 아니라 UTC가 된 이유는 영어와 프랑스어의 표기 방식 중 중립 형태를 취한 것 같다.이는 32비트 메모리 상으로 표현했을 때 오버플로우 때문에 2,147,483,647((231 - 1) 지난 후인 2038년 1월 19일 03:14:08 UTC에 오류를 일으킨다고 한다.64비트를 쓰면 죽기 전에는 뭐 문제 없을라나… 또한 한국은 UTC+09:00으로 9시간을 더해줘야한다는 단점이 있다. (LocalTime과 호환되지 않음)이를 위해서는 OffsetDateTime 클래스를 이용하면 될 것 같다.서로 다른 시간대의 지역(AWS와 한국의 클라 등등)에서 날짜 데이터를 주고 받을 때는 OffsetDateTime을 이용하면 된다. 뭐 기타 파싱이나 데이터 얻어오는 건 정리하기 귀챠니즘… 나중에 책을 다시 보던가 하자. 컬렉션(Collection)다수의 데이터, 데이터 그룹을 컬렉션이라고 부른다.프레임워크는 표준화된 프로그래밍 방식, 단일화된 구조(Architecture) 정도로 보면 될 것 같다.자바에서는 이런 컬렉션 클래스들을 정리해서 프로그래머가 개발하기 편하게 만들어줬다. 핵심 인터페이스는 아래 세 가지이다.(Map 인터페이스는 독자적이며 List와 Set은 Collection 인터페이스를 상속받은 인터페이스들이다.) List: 순서가 있는 데이터의 집합이며 중복을 허용한다.구현체로는 ArrayList, LinkedList, Stack, Vector 등 Set: 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.구현체로는 HashSet, TreeSet Map: Key와 Value의 Pair(쌍)으로 이루어진 데이터의 집합니다.순서는 유지되지 않으며, 키의 중복을 허용하지 않고 값의 중복은 허용한다.구현체로는 HashMap, TreeMap, HashTable, Properties 등이 있다. Vector, Stack, HashTable, Properties는 이름만 봐서는 누구를 구현한 건지 알기 힘들다.이는 컬렉션 인터페이스가 생기기 전인 JAVA1에 생긴 것이라서 레거시 코드들과의 호환을 위해 이름을 바꾸지 않았다.이런 녀석들보다는 다소 최근에 생긴 ArrayList나 HashMap을 사용하도록 하자~ 컬렉션의 사이즈를 정할 때는 생각한 것보다 여유를 좀 줘서 생성해주는 게 좋다.어차피 공간이 부족하면 자동적으로 늘리긴 하지만 성능 상 좋지는 않기 때문이다.또한 ArrayList나 Vector는 배열로 값을 다스리기 때문에 공간이 부족하면새로운 배열(더 큰 배열)을 만들고 기존의 값을 복사 후 기존의 값들과의 참조 관계를 끊어서 가비지 컬렉팅 대상이 되게 한 후 새로운 배열과 참조관계를 맺는다.이렇게 계속해서 새로운 배열을 만들면 계속해서 메모리 공간 이곳 저곳을 차지해서 단편화가 발생하지 않을까…? ListVector vs ArrayListVector를 개선한 게 ArrayList라니까 웬만하면 ArrayList를 쓰자.ArrayList는 검색에는 빠르나 삽입/삭제에 불리하다.(복사하고 앞뒤로 땡겨야하는 처리가 필요하기 때문) ArrayList vs LinkedListLinkedList는 다음 노드에 대한 참조만 바꿔주면 되므로 삽입/삭제에 용이하다.하지만 다음 노드에 대한 참조로 순차적인 조회 밖에 불가능하므로 검색을 할 때 처음부터 순차적으로 접근해야해서 느리다.ArrayList는 접근(읽기) 속도가 빠르고, 추가/삭제가 느리다.순차적인 추가 삭제도 더 빠르다고 하는데 뭐 JVM이나 컴퓨터 환경에 많이 좌지우지 되는 것 같다.LinkedList는 접근(읽기) 속도가 느리고 추가/삭제가 느리다.그리고 데이터가 많아지면 처음부터 접근해야하는 갯수가 훨씬 늘어나므로 데이터가 많을 수록 접근성이 떨어진다.데이터의 변경(삽입/삭제)가 잦다면 LinkedList를, 잦지 않다면 ArrayList를 쓰자. LinkedList vs Doubly Linked List링크드 리스트는 다음 노드에 대한 참조는 가능한데 이전 노드에 대한 참조는 불가능하다.그래서 나온 게 이중 링크드 리스트이다.이중 링크드 리스트는 이전/다음 노드에 대한 참조와 값으로 이루어져있다.이중 링크드 리스트를 더 많이 쓴다고 한다. Doubly Linked List vs Doubly Circular Linked Listed이중 링크드 리스트는 처음부터 끝까지 갔다가 다시 끝에서 처음부터 올 수 있다.하지만 처음 노드에서 맨 끝 노드로 가려면 순차적으로 접근해야한다는 단점이 있다.(링크드 리스트도 마찬가지다.)이러한 문제점을 해결하기 위해 이중 원형 링크트 리스트가 나왔다.이중 원형 링크드 리스트는 단순히 이중 링크드 리스트에서 처음 노드와 마지막 노드의 참조를 연결한 것 뿐이다. Stack vs QueueStack은 후입선출(LIFO, Last In First Out), 즉 배열이 스택을 이용한 구조이다.(push와 pop의 전형적인 사용 사례)Queue는 선입선출(FIFO, First In First Out), 데이터가 입력된 시간 순서에 따라서 처리해야하는 경우(프로세스 스케쥴링?)에 사용한다고 한다. Stack은 전형적인 배열과 같은 자료구조를 띄므로 ArrayList와 같은 배열 리스트 기반의 클래스로 구현하기 쉽다.하지만 Queue는 앞에 있는 놈부터 나가서 앞에 있는 놈을 땡기기 위해 새로운 배열 만들어서 복사하는 수 밖에 없다.배열 관련 클래스로 Queue를 구현하면 이런 복사에 대한 처리 비용이 많이 들기 때문에 삽입/삭제가 잦을 때 쓰는 LinkedList를 이용하여 구현하면 된다. Java에서 Stack은 클래스로 제공해주고 있지만, Queue는 인터페이스로만 제공해주고 있어서 그 구현체를 가져다 쓰면 된다.1234567public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125;public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;&#125;public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; 위와 같이 LinkedList는 Deque(데크, Double Ended Queue)를 구현한 구현체이고,Deque 인터페이스는 Queue 인터페이스를 상속받은 인터페이스이다. 12345678910111213141516171819public class StackQueue &#123; public static void main(String[] args) &#123; Stack s = new Stack(); Queue q = new LinkedList(); s.push(0); s.push(1); s.push(2); q.offer(0); q.offer(1); q.offer(2); System.out.println(\"Stack\"); while(!s.empty()) System.out.println(s.pop()); // 2 1 0 System.out.println(\"Queue\"); while(!q.isEmpty()) System.out.println(q.poll()); // 0 1 2 &#125;&#125; Queue는 Queue의 인터페이스의 구현체인 LinkedList를 통해 만들 수 있고, push 대신 offer, pop 대신에 poll을 쓴다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"내장 클래스","slug":"내장-클래스","permalink":"http://perfectacle.github.io/tags/내장-클래스/"},{"name":"날짜와 시간","slug":"날짜와-시간","permalink":"http://perfectacle.github.io/tags/날짜와-시간/"},{"name":"형식화","slug":"형식화","permalink":"http://perfectacle.github.io/tags/형식화/"}]},{"title":"(Java) 자바의 정석 3판 015일차 - 유용한 클래스, 날짜와 시간 & 형식화, 컬렉션","slug":"Java-study-016day","date":"2017-08-04T06:17:49.000Z","updated":"2017-08-08T09:16:58.000Z","comments":true,"path":"2017/08/04/Java-study-016day/","link":"","permalink":"http://perfectacle.github.io/2017/08/04/Java-study-016day/","excerpt":"","text":"흠… 한 3일을 탱자탱자 논 거 같다…어찌보면 아까운 시간이지만 쉼이 있어야 또 달릴 수 있는 거 같다.고고씽! 스택과 큐의 사용 사례 스택 - 수식 계산, 수식 괄호 검사, undo/redo, 뒤로/앞으로 큐 - history, 인쇄작업 대기 목록, 버퍼 pop(poll) vs peek전자는 마지막(처음) 녀석을 삭제하면서 반환후자는 삭제는 하지 않고 반환만 Deque(데크, 덱, 디큐, Double Ended Queue)Queue의 변형으로 Deque는 양쪽 끝에 추가/삭제가 가능하다.스택으로 사용할 수도 있고 큐로도 사용이 가능하다. Deque Queue Stack offerFirst() - - offerLast() offer() push() pollFirst() poll() - pollLast() - pop() peekFirst() peek() - peekLast() - peek() Iterator, ListIterator, Enumeration컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스Enumeration은 Iterator의 구버전이며, ListIterator는 Iterator의 기능을 향상시킨 것이다.Enumeration은 컬렉션 프레임워크가 나오기 전에 나온 애라서 레거시 코드를 위한 것이고, 웬만하면 쓰지 말자. Iterator 인터페이스컬렉션 프레임워크에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 아래와 같이 표준화하였다.1234567891011121314151617181920212223public interface Iterator &#123; boolean hasNext(); Object next(); // 아래 두 메소드는 default 메소드이므로 구현하지 않아도 됨. // next 해온 요소를 컬렉션에서 삭제할지를 뜻하는 것 같다. // next 이후에 호출해야함. default void remove() &#123; throw new UnsupportedOperationException(\"remove\"); &#125; // Java8에 추가됨. // 남은 요소들에게 추가적으로 수행할 작업 default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125;public interface Collection &#123; public Iterator iterator();&#125; iterator() 메소드는 Collection 인터페이스 내에 정의된 메소드로, Collection 인터페이스의 자식인 List와 Set에도 포함되어 있다.ArrayList에 저장된 요소를 읽어오는 방법은 다음과 같다.12345List list = new ArrayList();Iteraotr it = list.iterator();while(it.hasNext()) &#123; System.out.println(it.next());&#125; 위 예제는 왜 참조타입을 ArrayList 대신에 List를 썼을까?ArrayList에만 존재하는 메소드를 쓸 게 아니고 List에만 존재하는 메소드를 쓸 때는 List로 참조 타입을 잡아두는 게 좋다고 한다.아래와 같은 상황을 가정해보자.만약에 자료구조를 ArrayList에서 LinkedList로 바꿀 일이 생겼다. 참조타입을 List로 선언한 경우LinkedList는 List의 구현체이므로 선언문 부분만 바꿔주면 되고, 나머지 사용 부분에 있어서는 List의 메소드만 사용했을 것이므로 테스트 할 필요가 없다. 참조타입을 ArrayList로 선언한 경우ArrayList의 자식이 LinkedList가 아니므로 참조 타입을 List, 혹은 LinkedList로 바꿔줘야한다.그리고 나머지 사용 부분에 있어서도 ArrayList의 메소드를 사용했을지 모르므로 그런 부분을 다 바꿔줘야 할지도 모른다.따라서 List에만 존재하는 메소드를 쓴다면 다른 사람들에게 코드 변경에 대한 안정성도 심어줄 수 있고 굳이 ArrayList로 참조타입을 잡을 일이 없다. Map 인터페이스에서는 iterator를 어떻게 쓰나?ES6에서도 다음의 경우에는 오류를 내뱉는다.12345const obj = &#123; name: '간장냥', age: 25&#125;for(const key of obj) console.log(obj[key]); Object는 Iterable한 객체가 아니라서 for of Syntax를 쓸 수 없고 아래와 같이 해주거나proposal-object-rest-spread을 지원하는 바벨 플러그인을 깔거나 해야했다. 12345const obj = &#123; name: '간장냥', age: 25&#125;for(const key of Object.keys(obj)) console.log(obj[key]); 아래와 같이 한 것이 지금 설명할 방법이다.123456// ES6와 달리 Java의 Map은 Iterable 하지 않다.Map map = new HashMap();Iterator it = map.keySet().iterator();Set set = map.entrySet();Iterator it2 = set.iterator(); java의 경우에는 Map은 Key와 Value의 쌍(pair)라서 iterator를 호출할 수 없다는데ES6의 Map도 비슷한 맥락일텐데 왜 Iterable 한 걸까…1234const myMap = new Map();myMap.set(0, 'zero');myMap.set(1, 'one');for(const [key, value] of myMap) console.log(key + ' = ' + value); ListIteratorListIterator는 Iterator를 상속받아서 기능을 추가한 것으로 컬렉션의 요소에 접근할 때Iterator는 단방향으로만 접근이 가능했지만 ListIterator는 양방향으로 접근이 가능하다.Iterator는 Set이나 Map에도 사용이 가능한 것에 비해 ListIterator는 List에만 사용이 가능하다. 1234567891011121314151617import java.util.ArrayList;import java.util.List;import java.util.ListIterator;public class ListIt &#123; public static void main(String[] args) &#123; List l = new ArrayList(); l.add(1); l.add(2); l.add(3); l.add(4); l.add(5); ListIterator it = l.listIterator(); while(it.hasNext()) System.out.println(it.next()); while(it.hasPrevious()) System.out.println(it.previous()); &#125;&#125; Iterator는 한 번 돌면 사용이 불가능해서 다시 얻어와야하지만, ListIterator는 역방향 순회가 가능해서 사용성이 더 높다. default methodInterface에 있는 default 메소드는 구현하는 구현체에서 굳이 구현해도 되지 않는 메소드이다.구현자의 부담을 약간 덜어줬다고 보면 된다.하지만 추상메소드라서 아래와 같이 몸통(body)는 반드시 명시해줘야한다.12345678910interface Test &#123; // 몸통 반드시 존재 default void t()&#123;&#125; // 저렇게 그냥 빈 몸통을 넣어줘도 오류는 안 나지만... // 이 메소드를 지원하지 않는 구현체의 경우에는 해당 메소드를 사용하면 오류가 난다는 예외를 던져줘야 좀 더 안전하다. default void t1() &#123; throw new UnsupportedOperationException(); &#125;&#125; Iterator의 remove데이터를 가져만 온다면 next,가져온 데이터를 삭제까지 한다면 remove!즉 remove 하기 위해선 next를 해야함! Arrays 클래스이 클래스에는 배열을 다루는데 유용한 메소드가 정의돼있다. copyOf(), copyOfRange() 123456int[] arr = &#123;0, 1, 2, 3, 4&#125;;int[] arr2 = Arrays.copyOf(arr, arr.length); // 0, 1, 2, 3, 4int[] arr3 = Arrays.copyOf(arr, 3); // 0, 1, 2int[] arr4 = Arrays.copyOf(arr, 7); // 0, 1, 2, 3, 4, 0, 0int[] arr5 = Arrays.copyOfRange(arr, 2, 4); // 2, 3int[] arr6 = Arrays.copyOfRange(arr, 0, 7); // 0, 1, 2, 3, 4, 0, 0 fill(), setAll() 123int[] arr = new int[5];Arrays.fill(arr, 9); // 9, 9, 9, 9, 9Arrays.setAll(arr, () -&gt; (int)(Math.random()*5)+1); // 1, 5, 2, 1, 1 람다식을 보니 반갑다, 그냥 ES6의 Arrow Function을 보는 기분이고 익명 함수도 보니 더욱 JS를 보는 거 같아 반갑다. sort(), binarySearch()binarySearch는 요소를 검색할 때 사용하며 항상 정렬이 돼있어야한다.1234567int[] arr = &#123;77, 105, 2, 33&#125;;int idx = Arrays.binarySearch(arr, 105); // 1, 잘못된 결과System.out.println(idx);Arrays.sort(arr);idx = Arrays.binarySearch(arr, 105); // 3System.out.println(idx); Linear Search(순차 검색)은 배열이 정렬돼있을 필요가 없으나 요소 하나하나 비교하기 때문에 느리고,Binary Search(이진 검색)은 배열의 검색 범위를 반복적으로 절반씩 줄여나가기 때문에 빠르나 배열이 정렬돼있어야한다. toString(), toDeepString(), equals(), deepEquals()전자는 얕은 문자열화, 후자는 깊은 문자열화?라고 보면 될 거 같다.즉 전자는 1차원 배열, 후자는 다차원 배열에 사용하면 된다.equals의 경우에도 마찬가지… asList(Object… a)배열을 List에 담아서 반환한다.매개변수가 가변인자라서 배열 생성 없이 그냥 요소만 넣어줘도 된다.일반 List와 달리 추가/삭제는 안 되고 변경만 된다. 123456789101112List list = Arrays.asList(new int[]&#123;1, 2, 3, 4, 5&#125;);List list2 = Arrays.asList(new Integer[]&#123;1, 2, 3, 4, 5&#125;);List list3 = Arrays.asList(1, 2, 3, 4, 5);List list4 = new ArrayList(Arrays.asList(1, 2, 3, 4, 5));// UnsupportedOperationException 발생// list2.add(2);list4.add(2);System.out.println(list.get(0)); // int를 넣으면 안된다.System.out.println(list2.get(0));System.out.println(list3.get(0));System.out.println(list4.get(5)); // 2 parallelXXX(), spliterator(), stream()parallel로 시작하는 메소드는 보다 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 한다.spliterator는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환한다.stream은 컬렉션을 스트림으로 반환한다. Comparator와 ComparableComparator는 sort하는 기준, 메소드이고 Comparable한 녀석들끼리만 비교해서 sort 할 수 있다.둘 다 인터페이스이다.123456789101112131415161718192021222324import java.util.Arrays;import java.util.Comparator;public class ComparatorTest &#123; public static void main(String[] args) &#123; String[] str = &#123;\"마나\", \"하마\", \"가나\"&#125;; Arrays.sort(str); System.out.println(Arrays.toString(str)); // 가나, 마나, 하마 Arrays.sort(str, new Desc()); System.out.println(Arrays.toString(str)); // 하마, 마나, 가나 &#125;&#125;class Desc implements Comparator &#123; public int compare(Object o1, Object o2) &#123; if(o1 instanceof Comparable &amp;&amp; o2 instanceof Comparable) &#123; Comparable c1 = (Comparable)o1; Comparable c2 = (Comparable)o2; return c1.compareTo(c2) * -1; // return c2.compareTo(c1); &#125; return -1; &#125;&#125; Set순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.저장 순서를 유지하는 녀석으로 LinkedHashSet이 있다. HashSetSet 인터페이스의 구현체내부적으로는 HashMap을 이용해서 만들어졌다. load factor컬렉션 클래스에 저장공간이 가득 차기 전에 미리 용량을 확보하기 위한 것.이 값을 0.8로 지정하면 80%가 찼을 때 용량이 두 배로 늘어남. 기본값은 0.75(75%)HashSet(int capacity, float loadFactor)과 같은 곳에서 사용한다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"내장 클래스","slug":"내장-클래스","permalink":"http://perfectacle.github.io/tags/내장-클래스/"},{"name":"날짜와 시간","slug":"날짜와-시간","permalink":"http://perfectacle.github.io/tags/날짜와-시간/"},{"name":"형식화","slug":"형식화","permalink":"http://perfectacle.github.io/tags/형식화/"}]},{"title":"(Java) 자바의 정석 3판 014일차 - 오류(에러와 예외), 유용한 클래스","slug":"Java-study-014day","date":"2017-08-04T06:17:49.000Z","updated":"2017-08-04T17:28:32.000Z","comments":true,"path":"2017/08/04/Java-study-014day/","link":"","permalink":"http://perfectacle.github.io/2017/08/04/Java-study-014day/","excerpt":"","text":"프로그램 오류 컴파일 에러 - 컴파일 시에 발생하는 에러(오타, 타입 불일치 등등) 런타임 에러 - 실행 시에 발생되는 에러(파일을 열어야하는데 없는 파일을 인자로 넘겼을 때 등등) 논리적 에러 - 의도와 다르게 동작하는 것(돈이 음수가 된다거나 적에게 부딪혀도 죽지않는 것 등등) 오류의 두 가지 종류 에러(Error) - 발생하면 복구할 수 없는 심각한 오류(StackOverflowError, OutOfMemoryError 등등) 예외(Exception) - 발생하더라도 수습이 가능한 비교적 덜 심각한 오류(NullPointerException 등등) 오류를 처리하는 클래스Error와 Exception 모두 클래스로 만들어져있고, 그 둘의 부모 클래스는 Throwable 클래스이다. (물론 최상위에는 Object 클래스가 자리잡고 있다.) 예외 클래스Exception 클래스는 다음 두 카테고리로 나눌 수 있다. Exception의 자식 클래스주로 외부의 영향(프로그램의 사용자)으로 발생한다. 존재하지 않는 파일의 이름을 입력(FileNotFoundException) 실수로 클래스 이름을 잘못 적은 경우(ClassNotFoundException) 입력한 데이터 형식이 잘못된 경우(DataFormatException) 기타 등등… RuntimeException의 자식 클래스(물론 RuntimeException 클래스도 Exception 클래스의 자식 클래스이다.)RuntimeException 클래스는 주로 개발자의 실수에 의해 발생한다. 배열의 범위를 벗어난 경우(IndexOutOfBoundException) 값이 null인 참조변수의 멤버를 호출한 경우(NullPointerException) 정수를 0으로 나눈 경우(ArithmeticException) 기타 등등… 예외 처리하기프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것이 그 목표이다.이러한 예외 처리를 제대로 해놓지 않으면 프로그램이 뻗고, JVM의 예외처리기(UncaughtExceptionHandler)가 받아서 원인을 로그에 출력해준다. 이러한 예외를 처리하기 위해서는 try-catch 문을 사용해야한다.try-catch 문은 문이 하나 뿐이어도 {} 블록의 생략이 불가능하다.1234567try &#123; // 예외가 발생할 수 있는 구문&#125; catch(IndexOutOfBoundException e) &#123; System.out.println(\"배열의 길이를 벗어났습니다!\");&#125; catch(ArithmeticException e) &#123; System.out.println(\"연산이 제대로 이루어지지 않았습니다!\");&#125; 만약 저기서 NullPointerException이 발생했으면 예외 처리를 제대로 하지 않았으므로 프로그램이 뻗는다.매개변수의 다형성을 이용하면 아래와 같이 처리할 수 있다.12345try &#123; // 예외가 발생할 수 있는 구문&#125; catch(Exception e) &#123; System.out.println(\"어디선가 예외가 발생했습니다!\");&#125; 또한 예외가 발생하지 않았으면 try-catch 문 전체를 빠져나간다. 또한 try나 catch문 안에 try-catch문이 또 들어갈 수 있다.이렇게 중첩해서 try-catch문을 사용할 때는 중복된 변수(IndexOutOfBoundException와 ArithmeticException를 모두 e로 선언하는 경우 등등)를 사용하면 에러가 난다.지역 변수는 상위 스코프의 변수를 덮어씌우는데 try-catch문은 안되나 보다. 멀티 catchJava7부터 추가되었다.여기서 쓰이는 | 는 논리 연산자가 아니라 그냥 기호이고, 갯수에는 제한이 없다.1234catch(IndexOutOfBoundException | ArithmeticException e) &#123;&#125;// catch(ParentException | ChildException e) &#123;&#125;// 부모 자식 관계인 경우에는 위 코드는 오류를 유발하므로 아래와 같이 써주자.catch(ParentException e) &#123;&#125; 예외 처리 정보 얻기 printStackTrace(): 예외 발생 당시 콜스택에 있던 메서드의 정보와 예외 메시지를 화면에 출력한다. getMessage(): 발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻는다.12345678910111213141516public class ExceptionTest &#123; public static void main(String[] args) &#123; try &#123; System.out.println(1); System.out.println(2/0); System.out.println(3); // 위에서 에러나서 출력 안 됨. &#125; catch (ArithmeticException e) &#123; // java.lang.ArithmeticException: / by zero // at ch08.Exception.main(Exception.java:7) e.printStackTrace(); System.out.println(\"예외 메시지:\" + e.getMessage()); // 예외 메시지:/ by zero &#125; catch (Exception e) &#123; System.out.println(\"asdf\"); &#125; &#125;&#125; switch-case 문처럼 instanceof가 true에 걸리는 녀석을 순서적으로 찾아가고 마지막에 default 마냥 Exception에 걸리게 된다.하지만 아래와 같이 하면 에러가 난다. 123456789101112131415161718public class ExceptionTest &#123; public static void main(String[] args) &#123; try &#123; System.out.println(1); System.out.println(2/0); System.out.println(3); &#125; catch (Exception e) &#123; System.out.println(\"asdf\"); &#125; // java: exception java.lang.ArithmeticException has already been caught catch (ArithmeticException e) &#123; // java.lang.ArithmeticException: / by zero // at ch08.Exception.main(Exception.java:7) e.printStackTrace(); System.out.println(\"예외 메시지:\" + e.getMessage()); // 예외 메시지:/ by zero &#125; &#125;&#125; 이미 먼저 예외 처리를 하고 있다고 아래서는 할 필요가 없다고 에러를 내고 있다. 예외 발생시키기정확하게 왜 일부로 예외를 발생시켜야하는지는 모르겠지만, 그런 경우가 있는 것 같다. 123456789101112131415public class ThrowTest &#123; public static void main(String[] args) &#123; try &#123; ArithmeticException e = new ArithmeticException(\"이거시 예외 메시지!\"); throw e; // throw new ArithmeticException(\"이거시 예외 메시지!\"); &#125; // java.lang.ArithmeticException: 이거시 예외 메시지! // at ch08.ThrowTest.main(ThrowTest.java:6) catch (ArithmeticException e) &#123; e.printStackTrace(); System.out.println(e.getMessage()); // 이거시 예외 메시지! &#125; &#125;&#125; 1234567891011import java.io.IOException;public class ThrowTest &#123; public static void main(String[] args) &#123; // RuntimeException의 자식 클래스가 아니면 컴파일 에러가 난다. // throw new IOException(); // RuntimeException의 자식 클래스면 런타임 에러가 난다. throw new ArithmeticException(); &#125;&#125; 메소드에 예외 선언하기다른 프로그래밍 언어에서는 메소드에 예외를 선언할 수 없었다.따라서 해당 메소드가 어떤 예외를 발생할지 모르므로 노련한 프로그래머야 해당 메소드를 쓸 때 예외처리를 잘 하겠지만,경험이 적은 개발자 입장에서는 다양한 테스트를 통해 어떤 상황에서 어떤 Exception이 발생하는지 순전히 노가다(?)로 알아볼 수 밖에 없었다.하지만 자바에서는 메소드에서 발생할 수 있는 예외를 명시해서 사용하는 측에서 어떻게 대비해야하는지를 알려줄 수 있다. 주의해야할 것은 메소드에 예외를 선언한다고 해서 예외 처리까지 떠맡게 되는 것은 아니다.12345678910111213141516public class MethodException &#123; static void method() throws NullPointerException &#123; method2(); &#125; static void method2() throws NullPointerException &#123; throw new NullPointerException(); &#125; public static void main(String[] args) &#123; // Exception in thread \"main\" java.lang.NullPointerException // at ch08.MethodException.method2(MethodException.java:8) // at ch08.MethodException.method(MethodException.java:5) //at ch08.MethodException.main(MethodException.java:12) method(); &#125;&#125; main이 method를 호출했고, method가 method2를 호출했고 method2에서 NullPointerException 예외가 발생했다고 알려주고 있다.물론 다음과 같이 메소드 내에서도 예외를 처리할 수 있다. 12345678910111213141516public class MethodException &#123; static void method() throws NullPointerException &#123; method2(); &#125; static void method2() throws NullPointerException &#123; try &#123; throw new NullPointerException(); &#125; catch (NullPointerException e) &#123; System.out.println(e.getMessage() + \" 예외 처리\"); // null 예외 처리 &#125; &#125; public static void main(String[] args) &#123; method(); &#125;&#125; 이 예제는 main 메소드는 예외가 발생했다는 사실도 모른다는 것이다.내 생각에는 메소드에서 처리할 바에는 저렇게 throws로 명시해줄 필요가 없을 것 같다.throws 키워드로 던져주는 예외는 메소드 사용자가 처리해야할 예외인데,미리 발생할 예외를 메소드 개발자가 미리 처리하는데 굳이 throws로 어떤 예외가 발생했는지 알려줄 필요가 있나 싶다.따라서 메소드 사용자에게 예외 처리를 미뤄버리면 다음과 같이 구현하면 될 것이다.12345678910111213141516public class MethodException &#123; static void method() throws NullPointerException &#123; method2(); &#125; static void method2() throws NullPointerException &#123; throw new NullPointerException(); &#125; public static void main(String[] args) &#123; try &#123; method(); &#125; catch (NullPointerException e) &#123; System.out.println(e.getMessage() + \" 예외 처리\"); // null 예외 처리 &#125; &#125;&#125; 이 예제는 main 메소드도 예외가 발생했다는 것을 알게 된다. finally1234567891011121314151617public class FinallyTest &#123; static void method() &#123; try &#123; System.out.println(\"try\"); return; &#125; catch (Exception e) &#123; System.out.println(\"catch\"); &#125; finally &#123; System.out.println(\"finally\"); &#125; &#125; public static void main(String[] args) &#123; // try // finally method(); &#125;&#125; 타짜를 보면 손은 눈보다 빠르듯, finally는 함수를 종료시키는 return 보다 빠르다. 자동 자원 반환주로 I/O와 관련된 클래스를 처리할 때 유용하다.12345678910111213try &#123; FileInputStream fis = new FileInputStream(\"score.dat\"); DataInputStream dis = new DataInputStream(fis); // 코드..&#125; catch(IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if(dis != null) dis.close(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125;&#125; 예외가 나던 안 나던 자원은 close(), 반환해줘야한다.하지만 이 close에서도 예외가 일어날 수도 있어서 또 예외 처리를 해줘야한다.가독성은 물론이고 문제가 있는 코드란다. (자세히는 모르겠다.) 그래서 JDK7에서는 try-with-resources 문이 생겼다.123456try(FileInputStream fis = new FileInputStream(\"score.dat\"); DataInputStream dis = new DataInputStream(fis)) &#123; // 코드..&#125; catch(IOException e) &#123; e.printStackTrace();&#125; 문장이 두 개인 경우 ;를 구분자로 사용하며 finally 없이도 자원이 자동으로 반환된다.이렇게 자동으로 반환되는 자원이라면 클래스(DataInputStream 등등)가 AutoCloseable 인터페이스를 구현한 것이어야만 한다.자세히 모르니 나중에 다시 보자. java.lang 패키지Object 클래스equals 메소드최상위 클래스 Object에는 equals 메소드가 있고 다음과 같이 구현돼있다.123public boolean equals(Object obj) &#123; return (this == obj);&#125; 둘이 같은 객체를 참조하고 있는지 비교하고 있는 것이다.그렇다면 String 클래스에서 어떻게 문자열을 가지고 비교하는 것일까?String도 클래스이고, 인스턴스 생성시 항상 메모리에 비어있는 공간에 할당될텐데 어떻게 equals 메소드로 두 문자열의 값을 비교하는 것일까?바로 equals 메소드를 오버라이딩하는 것이다. String 클래스는 다음과 같이 구현돼있다.1234567891011121314151617181920212223242526272829public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; // 결국에 다뤄지는 것은 C언어와 마찬가지로 문자 배열로 다루게 된다. private final char value[]; public boolean equals(Object anObject) &#123; if (this == anObject) &#123; // 같은 객체를 참조 하고 있으면 return true; &#125; if (anObject instanceof String) &#123; // 인자가 String 클래스의 인스턴스인 경우 // 기존에 넘어온 것은 Object 참조 타입이므로 Object 멤버 밖에 사용이 불가능하다. // 따라서 String 클래스의 멤버들을 사용하려면 String 클래스로 형변환(다운 캐스팅) 해줘야 한다. String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; // 둘의 길이가 같다면 char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; // 둘의 문자 하나 하나를 각각 비교 if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125;&#125; hashCode 메소드해싱은 데이터 관리 기법 중의 하나인데, 다량의 데이터를 저장하고 검색하는 데 유용하다.해시 함수는 찾고자하는 값을 입력하면 그 값이저장된 위치를 알려주는 해시 코드를 반환한다. 일반적으로 해시코드가 같은 두 객체가 같은 것지 존재하는 것이 가능하지만(String 클래스),hashCode 메소드를 오버라이딩 하지 않는 한 Object 클래스의 hashCode 메소드를 사용할 것이고이 메소드는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 절대 같은 해시코드를 가질 수 없다. 해싱기법을 사용하는 HashMap이나 HashSet 같은 클래스에 저장할 객체라면 반드시 이 메소드를 오버라이딩 해주자! toString 메소드기본적으로 println이나 print 메소드에서 인스턴스를 넣으면 자동적으로 toString 메소드가 호출된다.그리고 toString 메소드를 오버라이딩 하다보면 항상 public 접근 지정자를 왜 써야하는지 의문이었다.그에 대한 해답은 Object 클래스가 어떻게 toString 메소드를 구현했는지 보면 된다.123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode());&#125; 바로 public 접근 지정자를 쓰고 있다.메소드 오버라이딩을 하기 위해선 부모 클래스의 메소드보다 더 좁은 접근 지정자를 지정할 수 없는데,public 보다 넓은 접근 지정자는 없으니 무조건 public으로 접근 지정자를 지정하고 오버라이딩을 해줘야하는 거였다. clone 메소드Object 클래스의 clone 메소드를 보면 다음과 같다.1protected native Object clone() throws CloneNotSupportedException; 무조건 CloneNotSupportedException 예외를 던진다.따라서 클래스에서 따로 이 예외를 처리해줘야한다. 1234567891011121314151617181920public class TV implements Cloneable &#123; public Object clone() &#123; Object obj = null; try &#123; // TV 클래스의 부모 클래스는 Object, // Object 클래스의 clone 메소드는 아래와 같은 예외를 유발하므로 예외 처리를 이렇게 해줘야함. obj = super.clone(); &#125; catch (CloneNotSupportedException e) &#123;&#125; return obj; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; TV t = new TV(); // 반환된 타입은 Object 객체니 TV 객체로 형변환 해줘야한다. TV t2 = (TV)t.clone(); &#125;&#125; 또한 clone을 하기 위해서는 클래스를 Cloneable 인터페이스를 구현해야한다.왜냐하면 코드의 안전성을 보장하기 위한 것인데 클래스 개발자가 명시적으로 클래스 복제를 허락했다고 알리는 것과 같다. 공변 반환 타입위 예제에서 clone을 하고 나서 Object로 반환했으니 TV 객체로 형변환해야하는 과정이 필요했다.하지만 JDK5부터는 공변 반환 타입이란 게 나왔다.뭔소린지 나도 모르겠으니까 코드로 보자.1234567891011121314151617181920212223242526272829303132public class TV implements Cloneable &#123; public TV clone() &#123; Object obj = null; try &#123; obj = super.clone(); &#125; catch (CloneNotSupportedException e) &#123;&#125; return (TV)obj; &#125; // 아래 코드는 에러를 유발한다. // public TV2 toString() &#123; // return new TV2(); // &#125;&#125;class CaptionTV extends TV implements Cloneable &#123; &#125;class TVCR extends CaptionTV implements Cloneable &#123; public CaptionTV clone() &#123; // 부모 클래스의 메소드에서 이미 예외 처리를 하고 있기 때문에 얘는 예외 처리를 안 해줘도 된다. Object obj = super.clone(); return (CaptionTV)obj; &#125; &#125;class Test &#123; public static void main(String[] args) &#123; TV t = new TV(); TV t2 = t.clone(); &#125;&#125; 원래대로 라면 메소드 오버라이딩 조건에 의해 선언부는 완전히 일치해야하기 때문에 return 타입도 일치해야하기 때문에public Object clone()이 돼야하는데 TV instanceof Object가 true이기 때문에 public TV clone()도 가능해진 것이다.TVCR의 clone 메소드도 마찬가지다. 이런 clone 메소드는 배열, Vector, ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap, Calendar, Date와 같은 클래스에서도 사용이 가능하다. 얕은 복사와 깊은 복사clone 메소드는 객체의 값만 복사하므로 그 값이 참조하고 있는 객체를 또 복사하거나 하지 않는 Shallow Copy(얕은 복사)를 수행한다.멤버 변수가 기본값이 아닌 참조타입(클래스)인 경우가 이에 해당한다.기본적으로 deep copy는 해당 클래스의 인스턴스를 새로 반환하게 끔 해야하는 것 같다.JS처럼 hierarchical(계층적) 구조여서 재귀함수로 얕은 복사를 계속해서 수행하는 방식과는 다르다. Class 객체이름이 Class인 객체1public final class Class implements ... &#123;&#125; 클래스마다 getClass라는 메소드를 가지고 있고, 이 메소드는 자신의 Class 객체를 반환한다.따라서 클래스마다 Class 객체는 단 하나만 가지고 있다.이 Class 객체는 클래스 파일이 클래스 로더(ClassLoader)에 의해 메모리에 올라갈 때 자동으로 생성된다.클래스 로더는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다.클래스 파일을 찾지 못하면 ClassNotFoundException을 발생시키고, 찾으면 클래스 파일을 읽어서 Class 객체로 변환한다. 클래스 객체를 얻기 위해서는 세 가지 방법이 있다. Class c = new Card().getClass();, 생성된 객체(인스턴스)로부터 얻는 방법 Class c = Card.class;, 클래스 리터럴(*.class)로부터 얻는 방법 Class c = Class.forName(&quot;Card&quot;);, 클래스 이름으로부터 얻는 방법 또한 인스턴스를 만드는 방법도 두 가지 방법이 있다. Card card = new Card();, new 연산자를 이용해서 인스턴스 생성 Card card = c.newInstance();, 위에서 구한 Class 객체를 이용해서 인스턴스 생성 String 클래스immutable(변경 불가능한) 클래스이다.String 클래스에는 문자열을 저장하기 위해 문자형 배열 변수인 char[] value를 인스턴스 변수로 정의해놓고 있다.인스턴스 생성 시 매개변수로 입력하는 문자열은 이 인스턴스 변수(문자형 배열 변수 value)로 저장된다.따라서 + 연산자를 이용하여 문자열을 결합한다면 새로운 인스턴스를 생성한다고 보면 된다.따라서 + 연산자를 이용하여 계속해서 새로운 인스턴스를 생성하면 아무리 GC(Garbage Collector)가 회수해간다 해도 메모리 공간 측면에서 좋지 않을 것이다. “abc” vs new String(“abc”)문자열을 생성하는데도 위의 두 가지 방법이 있다.나는 편의를 위해서 그냥 new String()의 생략이 가능한 줄 알았는데 그게 아니었다. &quot;abc&quot;, 이미 인스턴스가 존재하면 해당 인스턴스를 반환 new String(&quot;abc&quot;), 매번 새로운 인스턴스를 반환 그러한 까닭에 &quot;abc&quot; == &quot;abc&quot;는 true이지만, &quot;abc&quot; == new String(&quot;abc&quot;)는 false인 것이다.그래서 어떤 방식으로 문자열을 생성했을지 모르니 문자열의 비교는 무조건 equals() 메소드를 사용하자. Constant Pool123456String a = \"aa\";String a2 = \"aa\";String a3 = \"aa\";String b = new String(\"bb\");String b2 = new String(\"bb\");String b3 = new String(\"bb\"); 이 .java 파일을 컴파일하고, 컴파일된 .class 파일을 헥스 에디터로 열어보면aa는 단 한 번만 저장되고, bb는 세 번 저장돼있는 걸 볼 수 있다.Constant Pool이라는 상수 저장소에 바로 저 aa가 저장되게 되는 것이다. 문자형 배열에서 null의 부재?기존에 C를 배웠을 때 문자 배열에서 맨 끝에 null 문자(\\0)을 삽입해줬었다.이 null 문자를 만나는 순간이 배열의 끝이라는 걸 알려주기 위함이었다.하지만 Java에서는 따로 길이정보를 저장한다고 한다. 기본값String도 클래스이다 보니 참조변수의 기본값인 null이 들어가는 줄 알았는데 빈 문자열인 “”으로 초기화 된다고 한다.123public String() &#123; this.value = \"\".value;&#125; char는 빈 문자열이 들어갈 수 없으므로 공백(‘ ‘)이 들어간다고 한다. join vs split둘이 반대되는 개념이라고 보면 된다. join배열의 요소들 사이에 구분자를 넣어서 문자열로 반환한다. split문자열을 구분자로 나누어서 배열로 반환한다. int vs char메소드의 매개변수를 보면 int인 것이 있고 ch인 것이 있는데 차이는 다음과 같다. intUTF-16(2Byte, 65536개의 문자)로도 감당이 안 되다보니 int(4Byte, 4294967296개의 문자)를 매개변수로 받는 것이다.뭐 이런 문자는 거의 안 쓴다고 보면 된다. charUTF-16 내에 존재하는 문자로 커버가 된다고 생각하는 매개변수이다. “” vs valueOf자스에도 문자열로 변환하는 다양한 방법들이 있고, 자바에서도 마찬가지이다.“” 이 더 간결한데, 성능이 중요시 된다면 valueOf를 쓰라고 한다. parseInt vs valueOf둘 다 동일한 메소드이다.valueOf 내부를 보면 아래와 같이 parseInt를 호출하고 있다.아마 다른 클래스에서도 valueOf를 쓰기 때문에 통일성 때문에 추가된 게 아닐가 싶다.123public static Integer valueOf(String s) Throws NumberFormatException&#123; return Integer.valueOf(parseInt(s, 10));&#125; 기본형 &lt;-&gt; 문자열 기본형 -&gt; 문자열 문자열 -&gt; 기본형 String.valueOf(boolean b) Boolean.parseBoolean(String s) String.valueOf(char c) 문자를 문자로 바꿀 필요 없음. btye b도 int i와 동일 Byte.parseByte(String s) short s도 int i와 동일 Short.parseShort(String s) String.valueOf(int i) Integer.parseInt(String s) String.valueOf(long l) Long.parseLong(String s) String.valueOf(float f) Float.parseFloat(String s) String.valueOf(double d) Double.parseDouble(String s) 문자열에 숫자로 인식 가능한 + - . f d L과 같은 접두어, 접미어를 붙일 수 있다.12345678class Test &#123; public static void main(String args[]) &#123; int a = Integer.parseInt(\"+100\"); float b = Float.parseFloat(\"+100d\"); System.out.println(a); System.out.println(b); &#125;&#125; StringBuffer 클래스StringBuffer 클래스도 기본적으로 char[]로 문자열을 처리한다.123456789public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence &#123; /** * A cache of the last value returned by toString. Cleared * whenever the StringBuffer is modified. */ private transient char[] toStringCache;&#125; 또한 기본적으로 16자리 공간을 차지하며 문자열보다 + 16자리 큰 버퍼를 가진다.12345678 public StringBuffer() &#123; super(16);&#125;public StringBuffer(String str) &#123; super(str.length() + 16); append(str);&#125; 또한 기존 char[] 보다 더 긴 문자열을 추가하려면 기존의 문자열을 복사하고 더 긴 char[]을 만들고 기존의 것을 복사한 후 새로운 걸 붙여넣는 형태로 만들 것이다.append 메소드가 있는데 요놈은 문자열을 뒤에 추가하고 + 자기 자신의 주소를 반환해서 메소드 체이닝이 가능하다. String 클래스는 equals() 메소드를 오버라이딩하여 비교가 가능하지만, StringBuffer 클래스는 오버라이딩하지 않아 문자열로 비교할 방법이 없다.12345678class Test &#123; public static void main(String args[]) &#123; StringBuffer s = new StringBuffer(\"asd\"); StringBuffer d = new StringBuffer(\"asd\"); // StringBuffer를 String으로 변환 후 비교를 진행해야한다. System.out.println(s.toString().equals(d.toString())); // true &#125;&#125; StringBuffer vs StringStringBuffer는 데이터의 변경이 가능한데 String은 데이터를 변경하는 게 아니라 새로운 인스턴스를 생성하는 것이다. StringBuffer vs StringBuilder동기화는 StringBuffer의 성능을 떨어뜨린단다.또한 멀티 쓰레드로 작성된 프로그램이 아닌 경우에는 StringBuffer의 동기화는 불필요하게 성능만 떨어뜨린다.반면 StringBuilder는 멀티쓰레드에 안전(Thread Safe)하도록 동기화가 되어있단다.StringBuffer에서 쓰레드의 동기화만 뺀 게 StringBuilder란다.뭔 소린지 모르겠다.싱글 스레드면 StringBuilder가 더 좋다는 말같다.멀티 스레드면 StringBuffer를 쓰라는 건가…?근데 뭐 StringBuffer도 충분히 성능이 좋아서 크게 StringBuilder를 쓸 일은 없는 것 같다. Math 클래스Math 클래스는 PI, E 두개의 상수 외에는 전부 static 메소드이다.자동으로 메모리에 로딩되는 애들이기 때문에 굳이 생성자로 인스턴스를 만들어도 메모리 차지만 할 뿐, 추가적으로 이용 가능한 인스턴스 멤버가 없다.따라서 인스턴스를 생성할 필요가 없어서 클래스의 접근 지정자가 private이고 만들고 싶어도 만들 수 없다. 소수점 n째 자리까지 반올림하기 Math.round()를 쓰면 정수(Long)로 반올림 한다.소수점 n째 자리까지 반올림해서 구하고 싶다면 10n를 곱하고 Math.round로 정수로 반올림 후에 10n로 다시 나누면 된다.이때 나눌 때는 정수로 곱하면 안되고 뒤에 .0이나 실수형의 접두어인 f나 d를 붙여주자. 12345678class Test &#123; public static void main(String[] args) &#123; double d = 90.12345; Long i = Math.round(d * 100); d = i / 100.0; System.out.println(d); // 90.12 &#125;&#125; 올림, 내림, 반올림 Math.ceil(): 올림 Math.floor(): 내림 Math.round(): 반올림 Math.rint(): 반올림 Math.round vs Math.rint를 비교해보자.1234567891011121314class Test &#123; public static void main(String[] args) &#123; System.out.println(Math.round(1.1)); // 1 System.out.println(Math.round(1.5)); // 2 System.out.println(Math.round(-1.1)); // -1 System.out.println(Math.round(-1.5)); // -1 System.out.println(Math.round(-1.6)); // -2 System.out.println(Math.rint(1.1)); // 1.0 System.out.println(Math.rint(1.5)); // 2.0 System.out.println(Math.rint(-1.1)); // -1.0 System.out.println(Math.rint(-1.5)); // -2.0 System.out.println(Math.rint(-1.6)); // -2.0 &#125;&#125; 예외를 발생시키는 메소드Java8에서 추가됐다.add 메소드는 결과만 반환하고 오버플로우(범위를 초과)가 발생했는지 얘기해주지 않는다.addExact 메소드는 오버플로우가 발생하면 ArithmeticException을 발생시킨다.여기서 negateExact라는 메소드도 있는데 단순히 부호를 바꿔주는 연산자인데 부호를 바꾸는 과정에서 어떻게 오버플로우가 발생하는지 알아보니 참 재밌는 것 같다.우선 a의 부호를 바꾸는 연산자는 -a이지만 내부적으로는 ~a+1로 돌아간다.내 말을 못 믿겠다면 아래 코드를 보고 원리를 이해해보자.1234567class Test &#123; public static void main(String[] args) &#123; int i = -2147483648; System.out.println(i); // -2147483648 System.out.println(-i); // -2147483648 &#125;&#125; ~a는 십진수를 이진수로 바꾸고 비트를 전부 역전시키므로 a의 2의 보수를 구하게 된다.2의 보수 + 1은 음수이므로 ~a+1은 음수이다.그래서 그게 어쨌다는 건가… 싶으면 다음 내용을 보자. int는 4byte로 범위는 -232-1 ~ 232-1-1, 즉 -2147483648 ~ 2147483647이다.-2147483648를 negate, 부호를 바꾼다고 생각해보자.~(-2147483648)+1을 구하면 되는 간단한 문제이다.-2147483648을 2진수로 표현하자면 다음과 같다.1000_0000_0000_0000_0000_0000_0000_000(2)이걸 2의 보수(~(-2147483648))를 구하면 다음과 같다.0111_1111_1111_1111_1111_1111_1111_1111(2)이 수는 int의 최대값인 2147483647이다.여기서 1을 더하면 다음과 같다.1000_0000_0000_0000_0000_0000_0000_000(2)다시 자기 자신으로 돌아왔다.최대값 + 1 == 최소값, 즉 오버플로우가 발생했다.따라서 아래와 같이 처리해줘야한다.1234567891011class Test &#123; public static void main(String[] args) &#123; int i = -2147483648; try &#123; System.out.println(Math.negateExact(i)); &#125; catch (ArithmeticException e) &#123; System.out.println(\"범위 초과!\"); System.out.println(Math.negateExact((long)i)); // 2147483648 &#125; &#125;&#125; 단순히 부호를 바꾸는 연산자인데도 오버플로우가 발생할 수 있다는 사실이 참 신기하고 재미있다.따라서 negateExact라는 메소드가 필요한 것이다. Math vs StrictMathMath 클래스는 최대한의 성능을 얻기 위해 OS의 메서드를 호출해서 사용한다.즉 OS에 의존적이라 결과가 달라질 수도 있다.StrictMath는 성능을 좀 포기하더라도 어디서나 동일한 결과를 보장받기 위한 클래스이다. 기타 메소드 Math.random(): 0.0 &lt;= x &lt; 1.0 Math.max(), Math.min(): 두 가지 인자를 받아서 둘 중에 누가 크고 작은지 알려줌. Math.abs(): 절대값 알려줌. 래퍼 클래스(Wrapper Class)기본타입을 객체로 다루기 위한 클래스Object 아래 Boolean, Character, Number 클래스가 있다.Number 클래스의 자식으로 Byte, Short, Integer, Long, Float, Double이 있고,추가적으로 BigInteger(Long 보다 큼), BigDecimal(Double보다 큼)도 존재한다. 오토 박싱 &amp; 언박싱(autoboxing &amp; unboxing)JDK5 이후에 등장했다.오토박싱은 기본값을 래퍼 객체의 인스턴스로 바꿔주는 걸 말한다.1234567class Test &#123; public static void main(String[] args) &#123; // 제네릭에는 기본값이 못 들어간다. Vector&lt;Integer&gt; v = new Vector&lt;Integer&gt;(); v.add(10); // v.add(new Integer(10)) 이라고 컴파일러가 오토박싱 해줌. &#125;&#125; 언박싱은 반대로 래퍼 객체의 인스턴스를 기본값으로 바꿔주는 걸 말한다.1234567class Test &#123; public static void main(String[] args) &#123; int i = 1; int i2 = new Integer(\"1\"); // new Integer(1); 과 동일 System.out.println(i + i2); // i + i2.intValue()로 컴파일러가 자동 언박싱 해준다. &#125;&#125; java.util.Objects 클래스Object 클래스의 보조 클래스이다.Math처럼 모든 메소드가 static이다. isNull(Object obj), nonNull(Object obj): 딱 보면 뭐하는 놈인지 알 것이다. 둘은 정반대 requireNonNull(T obj)기존에는 아래와 같이 했어야 했다. 12345678910void setName(String name) &#123; if(name == null) &#123; try &#123; throw new NullPointerException(\"name must not be null\"); &#125; catch (NullPointerException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name;&#125; 하지만 위 메소드를 쓰면 좀 더 줄일 수가 있다.1234567void setName(String name) &#123; try &#123; this.name = Objects.requireNonNull(name, \"name must note be null\"); &#125; catch (NullPointerException e) &#123; e.printStackTrace(); &#125;&#125; compare(Object a, Object b, Comparator c)Object 클래스에는 equals만 있고 비교를 할 수 있는 메소드가 없는데 Objects 클래스에서 추가되었다.Comparator는 두 객체를 비교할 기준인 거 같다.크면 양수, 작으면 음수, 같으면 0을 반환한다. (아마 a가 기준일라나..??)String 클래스에서는 그냥 compareTo를 이용하거나 숫자는 부등호를 이용하면 될 것 같다.여튼 나중에 다시 알아보자. equals기존 Object 클래스에서 equals를 비교하기 전에 null인지 아닌지도 비교를 해줬어야 했다. 1if(a != null &amp;&amp; a.equals(b)) &#123;&#125; 하지만 Objects 클래스의 equals를 쓰면 한결 편해진다.1if(Objects.equals(a, b)) &#123;&#125; deeqEquals(Object a, Object b)위 equals는 shallow equals라고 보면 된다.내부에 참조변수가 있으면 그녀석들은 비교하지 못한다.다차원 배열인 경우가 아마 그럴 것이다. 그럴 때 이 deepEquals를 쓰면 된다. toString(Object o)equals와 마찬가지로 내부적으로 null을 검사해주는 것 이외에는 큰 차이가 없다. toString(Object o, String nullDefault)null이면 기본으로 넣을 값을 지정해줄 수 있다. hashCode(Object o)이것도 내부적으로 null을 검사해주는 것 외에는 큰 차이가 없다.null이면 0을 반환한다. import static java.util.Objects.*을 한다면…?Objects 클래스까지 생략 가능하고 바로 메소드의 사용이 가능해진다.하지만 컴파일러는 자동적으로 java.lang.* 패키지도 넣어버리므로 Object 클래스까지 같이 import 된다.Objects 클래스와 Object 클래스는 메소드명이 겹치는 경우가 많아서 어떤 걸 써야할지 구분을 못 하는 경우가 있어서 이럴 때는 클래스명을 다 붙여줘야한다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"오류","slug":"오류","permalink":"http://perfectacle.github.io/tags/오류/"},{"name":"에러","slug":"에러","permalink":"http://perfectacle.github.io/tags/에러/"},{"name":"예외","slug":"예외","permalink":"http://perfectacle.github.io/tags/예외/"},{"name":"내장 클래스","slug":"내장-클래스","permalink":"http://perfectacle.github.io/tags/내장-클래스/"}]},{"title":"(Spring) 스타트 스프링 부트 003일차 - Spring Data JPA","slug":"Spring-boot-study-003day","date":"2017-08-04T04:11:13.000Z","updated":"2017-08-04T05:16:03.000Z","comments":true,"path":"2017/08/04/Spring-boot-study-003day/","link":"","permalink":"http://perfectacle.github.io/2017/08/04/Spring-boot-study-003day/","excerpt":"","text":"드디어 유닛 테스트? 단위 테스트? JUnit을 써봤다~그럼 시작! RepositoryxBatis(MyBatis, iBatis) 같은 경우에는 DAO(Data Access Object)라는 개념이 있었다는데 나중에 공부해봐야겠다.여튼 JPA에서는 Repository가 비슷한 거라고 DAO와 비슷하다고 보면 될 거 같다.JPA에서는 EntityManager를 구성하고, 트랜잭션을 시작하고 종료하는 코드를 만들 수도 있지만…(트랜잭션은 나중에 또 공부하자 ㅠㅠ)JPA를 쓰기 좋게 구성한 Spring Data JPA 라이브러리를 쓰면 복잡하지 않은 Repository는 간단하게 구성이 가능하다. Repository &lt;- CrudRepository &lt;- PagingAndSortingRepository위는 Repository 인터페이스들의 상속 구조를 나타낸 것이다.&lt;&gt;는 제네릭이고(공부하자 ㅠㅠ), T는 타입(엔티티 타입), ID는 PK를 의미한다.CRUD(Create(insert), Read(Select), Update, Delete)는 CrudRepository로,Paiging과 Sorting은 PagingAndSortingRepository로 해주면 된다.페이징 로직(현재 몇 페이지인지, 데이터 몇 개씩 보여줄 건지, 페이지를 보여주는 블록에 관한 것 등등)을 안 짜도 된다니 혁명 같다 ㅠㅠ 나머지는 다 코드 중심이고, CRUD 및 페이징, 정렬 코드 작성하고 테스트 하는 건데…넘나 덥고 자바의 정석 공부를 해야해서 나중에 정리해야겠다 ~~","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"http://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://perfectacle.github.io/tags/Spring-Data-JPA/"}]},{"title":"(자알쓰) 디버깅","slug":"js-012-debug","date":"2017-08-03T17:44:39.000Z","updated":"2017-08-03T17:58:37.000Z","comments":true,"path":"2017/08/04/js-012-debug/","link":"","permalink":"http://perfectacle.github.io/2017/08/04/js-012-debug/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 두 번째 시리즈는 번외편 격으로 디버깅 하는 방법을 주제로 진행하겠다. 디버깅이란…?우선 디버그란 De Bug, Bug를 제거하는 것이다.그렇다면 버그란…? 우리가 생각하는 오류를 뜻한다.그럼 왜 버그가 오류인가…?과거에 벌레(버그)가 기계 속에 들어가서 프로그램이 오류가 난 적이 있다.그래서 해당 벌레를 제거(디버그)했더니 프로그램이 정상적으로 실행됐다는 사례 때문에 붙여진 이름이라고 한다.디버깅은 디버그 하는 것, 즉 버그를 제거하는 것, 오류를 고치는 행위를 말한다. 디버깅을 해보자아래와 같은 코드가 있다고 해보자.123456var getMidChar = function(str) &#123; var idxMid = ~~(str.length / 2); return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num); 위 코드를 실행하면 Uncaught TypeError: str.charAt is not a function이라는 오류가 나게 된다.매개변수 str에 도대체 어떤 값이 들어왔길래 charAt가 함수가 아니라는 건지 도저히 모르겠을 때 다음과 같은 방법으로 str의 값을 얻어낼 수 있다. 로그 찍어보기.가장 간단하면서 빠른 방법이다.코드를 아래와 같이 고쳐보자.1234567var getMidChar = function(str) &#123; console.log(str); // 1234 var idxMid = ~~(str.length / 2); return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num); 코드가 간단해서 굳이 로그를 안 찍어봐도 되지만 로직이 복잡한 경우에 이렇게 로그를 찍어보면 어떤 값이 넘어와서 에러를 유발하는지 쉽게 찾아낼 수 있다. 브레이크 포인트 지정하기(묵시적)BP(Break Point), 말 그대로 코드를 끝까지 실행하는 게 아니라 어느 시점(Point)에서 멈추게(Break) 하는 것이다.위 코드를 로그 찍어보는 대신에 브레이크 포인트를 지정해 str에 넘어온 값을 얻어보고자 한다.로그를 찍어보는 것은 궁금한 내용을 찍어보기 위해서는 계속 소스를 수정해야하지만,브레이크 포인트를 걸어두면 브레이크 걸린 시점에서 소스 수정 없이 이것 저것 테스트 해볼 수 있다는 장점이 존재한다.이 포스트에서는 디버거의 사용 방법(다음 BP로 이동 등등)에 대해서는 설명하지 않으니 그건 알아서 공부하자. 브라우저설명은 크롬 기준으로 하지만 다른 브라우저에서도 모두 지원할 것이다. 우선 아래와 같은 html 파일을 만들자.1234567891011121314151617&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var getMidChar = function(str) &#123; var idxMid = ~~(str.length / 2); return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 브라우저에서 해당 html 파일을 열고 개발자 도구를 열어서 콘솔 탭을 보자.11번 줄에서 에러가 난 상황이고, 11번을 call? 호출? 한 건 14번 라인에 의한 것이란다.일단 11번 라인으로 가기 위해 파란 박스를 클릭해주자. 해당 라인에서 오류가 나고 있다.정확히 어떤 값이 넘어오는지 봐야하기 때문에 브레이크 포인트를 지정해주자.파란 박스 친 11번 라인을 클릭해주자. 이제 새로고침을 해주자. 11번 라인이 실행되기 직전에 딱 브레이크가 걸린다.스코프들의 관계(누가 누구를 호출했는지) 콜스택을 통해 볼 수 있고, 어떤 브레이크 포인트에 의해 브레이크 된 건지 등등의 유용한 정보를 볼 수 있다. 또한 원래 콘솔에서는 전역 스코프만 접근이 가능했는데 브레이크 걸린 스코프는 로컬 스코프인데 마치 전역 스코프인 것 마냥 그 안으로 파고 들어와서 테스트를 할 수 있다. Node.js설명은 IntelliJ로 하지만 VSCode나 Atom에서도 Node.js를 디버깅 할 수 있는 것으로 알고 있다.요즘에는 Javascript가 브라우저를 탈출해 Node.js 런타임 환경까지 생기다보니 IDE에서 Node 인터프리터를 제공해주기도 한다.Node를 이용하면 브라우저에서 제공하는 DOM이나 BOM 객체의 사용은 불가능하지만, ES+Node API를 통해 데이터에 집중해서 테스트 할 수 있다는 장점이 존재한다. 아래와 같은 js 파일을 만들자.123456var getMidChar = function(str) &#123; var idxMid = ~~(str.length / 2); return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num); 우클릭 후 Run ‘test.js’를 클릭해주자. 동일한 코드이므로 동일한 부분에서 에러가 난다.3번 라인 14번째 칸에서 오류가 났다고 하고, (3: 14)6번 라인 14번째 칸에 의해 호출이 일어났다고 한다. (6: 14) 3번 라인을 클릭해 BP를 걸어주자. 그리고 이번엔 Debug ‘test.js’를 클릭해주자. 그럼 3번 라인에서 BP가 걸리고 소스코드 창에는 해당 스코프에 어떤 인자가 넘어왔는지 등등을 보여주고 있다. 인터프리터 창의 Debugger 탭의 좌측에는 콜스택, 우측에는 스코프를 보여주고 있다. 인터프리터 창의 Console 탭으로 와서 str을 찍어보려고 하면마치 로컬 스코프(getMidChar())가 전역 스코프(Global)인 것마냥 자동완성을 해서 보여주고 있다. 별도의 소스코드 수정 없이 해당 스코프에서 하고싶은 테스트를 콘솔창에서 마음껏 해볼 수 있다. 브레이크 포인트 지정하기(명시적)명시적으로 소스코드 상에 브레이크 포인트를 지정해주는 걸 말한다. 다음과 같은 js 파일을 만들어주자.1234567var getMidChar = function(str) &#123; var idxMid = ~~(str.length / 2); debugger; return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num); 4번 라인이 실행되기 전에 BP를 명시적으로 걸어준 것이다.브라우저에서는 기본적으로 BP가 걸리고 IntelliJ에서는 Debug ‘test.js’ 해줘야지만 BP가 걸리는 모습을 볼 수 있다. 소스코드 주석 처리하기(+로그 출력하기)메소드의 어느 부분까지 제대로 실행되는지 확인하기 위해서는 확인하려는 부분 아래로 쭉 주석을 달고 오류가 나지 않는지 확인하면 된다.(혹은 그냥 제거해도 된다.)혹은 확인하려는 부분에 로그(의미없는 로그보다는 눈으로 확인하기 쉬운 임의의 로그)를 출력해보면 메소드가 어디까지 제대로 실행됐는지 확인할 수 있다. BP 걸고 로그 찍어서 어떻게 디버깅을 하는데?어떤 값이 들어왔는지 모르는 상황에서 머릿 속으로 상상의 나래를 펼치는 것보다그냥 로그 찍어보고 BP 걸어서 어떤 값들이 들어왔는지 확인하는 게 훨씬 빠를 경우가 많다.그래서 어떤 값들이 들어왔는지 확인하고 인자를 수정하던, 메소드 등등을 수정하던지 하면 훨씬 디버깅 하는데 용이할 것이다.따라서 로그 찍어보고 BP 거는 습관을 들이보다보면 훨씬 디버깅하는 데 용이할 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"디버깅","slug":"디버깅","permalink":"http://perfectacle.github.io/tags/디버깅/"}]},{"title":"(ES6) Number.EPSILON은 왜 2.220446049250313e-16인가?","slug":"ES6-EPSILON","date":"2017-08-03T17:25:57.000Z","updated":"2017-08-03T18:31:01.000Z","comments":true,"path":"2017/08/04/ES6-EPSILON/","link":"","permalink":"http://perfectacle.github.io/2017/08/04/ES6-EPSILON/","excerpt":"","text":"들어가기에 앞서 Number.EPSILON이 뭔지 모르는 사람은 해당 링크를 참조하고 오자. 부동소수점이 뭔지 모르는 사람은 해당 링크를 참조하고 오자. 자바스크립트에서 숫자의 자료형은?C나 Java를 접해본 사람이라면 숫자의 자료형은 크게 두 가지로 나눌 수 있을 것이다. 정수 실수 하지만 자바스크립트에서는 실수 하나 밖에 존재하지 않는다.123console.log(0 === 0.0); // trueconsole.log(0 === .0); // trueconsole.log(.0 === 0.0); // true 또 이 실수는 크게 두 가지로 나눌 수 있을 것이다. float double 하지만 자바스크립트에서는 이 실수형 중에서도 double 형 하나 밖에 존재하지 않는다. 실수를 나타내는 데도 고정 소수점과 부동 소수점이 존재하는데 고정소수점은 직관적인데 반해 표현할 수 있는 범위가 좁아서거의 부동 소수점이 실수를 표현하는데 표준으로 자리잡고 있다.물론 이 부동 소수점도 오차가 존재한다는 단점을 떠안고 있지만… 이 부동 소수점을 표현하는데도 여러가지 방법이 있는데(아마도…?) 현재 거의 표준으로 자리잡은 것은전기 전자 기술자 협회(IEEE)에서 제정한 IEEE754라는 것이다. double 형이란…?자바스크립트도 이 IEE754를 따라서 숫자(실수, 부동소수점)을 표현하고 있고,Double-precision floating-point format을 따르고 있다. 해당 부동소수점 표현 방식은 아래와 같이 세 가지 부분으로 나뉘어진다. 부호 비트(sign, 1bit)MSB(most significant bit): 최상위 비트, 즉 제일 왼 쪽에 있는 비트를 뜻하며 0이면 양수, 1이면 음수를 나타낸다. 지수부(exponent, 11bit)이진 소수를 정규화 했을 때 나타낼 지수부.지수부는 정수형과 달리 바이어스 표기법을 사용한다.범위는 -211-1-1 ~ 211-1, 즉 -21024-1 ~ 21024이다.해당 범위를 넘어가는 지수부에 한해서는 아마도 오버플로우가 발생해서 예기치 않은 결과를 뿜어내지 않을까 싶다.(NaN, ±Infinity)또한 지수 표기법과 같이 1e1 같은 숫자를 봤을 때 나오는 저 e가 지수부의 exponent를 줄인 것이다. 가수부(fraction, 52bit)이진 소수를 정규화 했을 때 나타낼 가수부.부호 없는 정수를 나타내는 방식과 동일하며 0~252-1 = 0 ~ 4503599627370495이다.4503599627370495는 십진수 16자리인데 0~15자리 수를 모두 커버하고 있으므로 double의 정밀도는 소수점 15자리가 되는 것이다. 부동 소수점은 먼저 아래와 같은 절차를 거친다. 십진 소수를 이진 소수로 바꾼다. (십진 소수 8.25를 이진 소수로 바꾸면 1000.01(2)) 이진 소수를 정규화한다. (이진 소수를 지수부와 가수부로 나누어서 표현한 방식을 뜻한다.)예를 들어 이진 소수 1000.01(2)을 정규화를 거치면 1.000101(2) X 103(2)와 같이 나타나며 1.101e3(2)로도 표현이 가능하다. 물론 지수부의 범위를 넘어서는 숫자라면 오버플로우가 발생할 것이고 가수부의 범위를 넘어서는 경우에는 오차가 발생한다.이 오차는 왜 발생할까? 가수부의 범위를 넘어서는(정규화 이후에 소수점 이하가 15자리를 넘어서는 경우) 경우 십진수로는 유한 소수인데 이진수로는 무한 소수인 경우0.1만 해도 이진수로는 표현이 불가능하다. (구해보면 이진수로는 무한 소수)따라서 끝자리가 5로 끝나는 소수가 아니면 유한소수라고 단정지을 수가 없고, 오차가 없다고 말할 수가 없다. 왜 Number.EPSILON은 2.220446049250313e-16일까?double 형 부동 소수점 가수부에서 0을 제외하고 가장 작은 숫자는 무엇일까?바로 2-52, 0.0000000000000002220446049250313(2.220446049250313e-16)이다.(가수부는 소수점 이하를 표현하는 것이기 때문에 252가 아니다.)그 말은 0 &lt; x &lt; 0.0000000000000002220446049250313, 즉 x는 표현하지 못하는 숫자가 된다.그래서 Number.EPSILON이 2-52, 즉 2.220446049250313e-16가 된 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"EPSILON","slug":"EPSILON","permalink":"http://perfectacle.github.io/tags/EPSILON/"}]},{"title":"(Java) 자바의 정석 3판 013일차 - Constant Pool","slug":"Java-study-013day","date":"2017-08-03T06:05:34.000Z","updated":"2017-08-04T04:26:19.000Z","comments":true,"path":"2017/08/03/Java-study-013day/","link":"","permalink":"http://perfectacle.github.io/2017/08/03/Java-study-013day/","excerpt":"","text":"어제 잠이 안 와서 늦잠을 잤더니 오늘은 어제꺼 복습이랑 연습문제 밖에 못 풀었다…내일부터 또 다시 진짜 빡세게 이빠이 달려야겠다 ㅠㅠ 연습문제 오답노트1~10 반복하기1234567class Test &#123; public static void main(String[] args)&#123; for(int i = 0; i &lt; 20; i++) &#123; System.out.println(i % 10 + 1); &#125; &#125;&#125; 내가 생각한 것12345678class Test &#123; public static void main(String[] args)&#123; for(int i = 0; i &lt; 20; i++) &#123; int lastNum = (i+1) % 10; System.out.println(num == 0 ? 10 : num); &#125; &#125;&#125; 이렇게 10인 경우에 대해서 먼저 덧셈을 진행하고 나머지 연산자를 쓰다보니 그런 문제가 발생한 것 같다.역시 나는 아직 멀었다, 알고리즘 ㅠㅠ 매개변수의 유효성 검사매일 까먹는데 매개변수가 들어오면 항상 유효성 검사를 하자!!특히 setter 부분… 내가 생각한 것12345678SutdaCard pick(int idx) &#123; if(idx &lt; 0 &amp;&amp; idx &gt;= CARD_NUM) return null; return cards[idx];&#125;SutdaCard pick() &#123; return cards[(int)(Math.random() * CARD_NUM)];&#125; 위 코드보다 혹시 몰라서 유효성 검사까지 돌려주게 끔 하려고 기존에 작성된 메소드를 이용하는 것 같다.pick() 안에서 유효성 검사를 또 돌리면 중복이기에… 답안12345678SutdaCard pick(int idx) &#123; if(idx &lt; 0 &amp;&amp; idx &gt;= CARD_NUM) return null; return cards[idx];&#125;SutdaCard pick() &#123; return pick([(int)(Math.random() * CARD_NUM)]);&#125; 자식 클래스에서 부모 메소드 호출1234567891011121314151617class Parent &#123; int y = 20; void method() &#123; System.out.println(y, + \",\" + this.y); &#125;&#125;class Child extends Parent &#123; int y = 30;&#125;class Test &#123; public static void main(String[] args) &#123; Child c = new Child(); c.method(); // 20,20 &#125;&#125; 메소드를 오버라이딩 하지 않아 부모 클래스의 메소드를 호출할 때가 있다.이때 메소드 내에 멤버들은 부모의 멤버를 가리킨다.ES2015와는 약간 다르다.123456789101112131415161718class Parent &#123; constructor() &#123; this.x = 20; &#125; method() &#123; console.log(this.x); &#125;&#125;class Child extends Parent &#123; constructor() &#123; super(); this.x = 30; &#125;&#125;const c = new Child();c.method(); // 30 ES2015+에서는 메소드 오버라이딩을 하지 않았어도 자식 클래스에서 호출한 거면 자식 클래스의 멤버를 따른다. 이전 값 기억하기setter로 값을 계속 지정하고, 그 이전값으로 돌아가는 메소드까지 구현해보는 거였다.예제로 TV 클래스의 채널을 가지고 구현했는데 나는 아래와 같이 반복된 로직을 사용하였다.1234567891011121314151617181920public class TV &#123; private int channel; private int prev; public int getChannel() &#123; return channel; &#125; public void setChannel(int channel) &#123; prev = this.channel; this.channel = channel; &#125; void gotoPrevChannel() &#123; int tmp = prev; prev = channel; channel = tmp; &#125;&#125; gotoPrevChannel 쪽에 저렇게 스와핑하는 로직을 쓸 필요가 없이 아래와 같이 하면 끝나는 거였다.나는 바보같다 흑흑…123456789101112131415161718public class TV3 &#123; private int channel; private int prev; public int getChannel() &#123; return channel; &#125; public void setChannel(int channel) &#123; prev = this.channel; this.channel = channel; &#125; void gotoPrevChannel() &#123; setChannel(prev); &#125;&#125; Math 클래스의가 private 접근 지정자가 붙어있는 이유?Math 클래스는 인스턴스 멤버는 하나도 없고 죄다 static 멤버이다.따라서 클래스가 자동으로 로딩되니(컴파일러가 import.lang.*을 자동으로 삽입해주니) 메모리에 static 멤버는 바로 적재되니 인스턴스 생성없이 사용이 가능하며인스턴스를 생성할 필요가 없어서 private 접근 지정자로 호출이 불가능하게끔 하고 있다. 참조타입 간의 형변환12345678910111213141516171819202122232425262728293031class Unit &#123; int x = 1;&#125;class AirUnit extends Unit &#123;&#125;class GroundUnit extends Unit &#123; int y = 2;&#125;class Tank extends GroundUnit &#123;&#125;class AirCraft extends AirUnit &#123;&#125;class UnitTest &#123; public static void main(String[] args)&#123; Unit u = new GroundUnit(); Unit u2 = new Unit(); Tank t = new Tank(); AirCraft ac = new AirCraft(); // 가능하다. 나는 참조타입이 Unit이라 더 넓은 타입인 GroundUnit으로 변환이 불가능한 줄 알았다. // 근데 인스턴스 타입이 GroundUnit이어서 가능한 것이다. // u2처럼 만드는 것과 차이점이 무엇이 있냐면 // 이렇게 형변환을 자유로이(멤버의 범위를 여의봉 마냥 자유자재로 늘렸다 줄였다) 할 수 있는 장점이 있다. GroundUnit gu = (GroundUnit)u; // 컴파일 에러는 안 나는데 런타임 에러, // u2는 Unit 인스턴스 타입이라 참조 가능한 한계가 Unit 뿐임. // 하지만 위는 GroundUnit의 인스턴스라 참조타입에 따라서 여의봉 마냥 참조 가능한 멤버의 한계가 달라짐. // GroundUnit gu2 = (GroundUnit)u2; // System.out.println(u.y); 참조타입이 Unit이라 Unit꺼가 아니라 컴파일 에러 System.out.println(gu.y); // GroundUnit의 멤버까지 접근이 가능하다. &#125;&#125; 확실히 구현해야하는 메소드들은 오버라이딩 보다는 추상메소드를 쓰자추상 메소드로 쓰면 구현을 하지 않으면 컴파일 에러가 나서 무조건 구현해야하는구나 라고 개발자가 더 확실히 인식할 수 있다.또한 오버라이딩은 해도 그만 안 해도 그만이라 잘못된 메소드를 만들어서 메소드 오버로딩이 될 수도 있는데 추상 메소드는 그럴 가능성이 없다.123456789101112131415161718192021class Unit &#123; int x, y; abstract move(int x, int y)&#123;&#125; // 메소드 오버라이딩 대신에 추상 메소드를 써서 무조건 구현하게끔 했다. void stop()&#123;&#125;&#125;class Marine extends Unit &#123; void move(int x, int y)&#123;&#125; void stimPack()&#123;&#125;&#125;class Tank extends Unit &#123; void move(int x, int y)&#123;&#125; void changeMode()&#123;&#125;&#125;class Dropship extends Unit &#123; void move(int x, int y)&#123;&#125; void load()&#123;&#125; void unload()&#123;&#125;&#125; 고객이 물건 사는 거 구현하기생각할 게 많은 예제인 것 같다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Product &#123; int price = 100; Product(int price) &#123; this.price = price; &#125;&#125;class TV extends Product &#123; TV() &#123; super(100); &#125; public String toString() &#123; return \"TV\"; &#125;&#125;class Computer extends Product &#123; Computer() &#123; super(200); &#125; public String toString() &#123; return \"Computer\"; &#125;&#125;class Audio extends Product &#123; Audio() &#123; super(50); &#125; public String toString() &#123; return \"Audio\"; &#125;&#125;class Buyer &#123; int money = 1000; Product[] cart = new Product[3]; int i = 0; void buy(Product p) &#123; if(p.price &lt;= money) &#123; money -= p.price; add(p); &#125; else &#123; System.out.println(\"잔액이 부족하여 \" + p + \"을/를 살 수 없습니다.\"); &#125; &#125; void add(Product p) &#123; int len = cart.length; // len - 1까지는 정상적으로 넣어도 되는 값이고 넣은 이후에 ++이 되기 때문에 len으로 조건을 걸어주면 된다. if(i &gt;= len) &#123; Product[] tmp = new Product[len*2]; System.arraycopy(cart, 0, tmp, 0, len); cart = tmp; &#125; cart[i++] = p; &#125; void summary() &#123; int spend = 0; System.out.print(\"구입한 물건: \"); // cart.length로 하면 null인 경우에 break를 걸어줘야하는데(아직 카트를 덜 채운 경우) // i를 맥스로 하면 i는 이제 넣어야할 차례의 인덱스이므로 끝까지 넣은 구간까지만 출력하니 null을 처리해주지 않아도 된다. for (int j = 0; j &lt; i; j++) &#123; System.out.print(cart[j] + \", \"); // spend를 구할 때 1000 - money로 구해도 되지만 1000원이라는 확신이 없기에 이렇게 해줘야함. spend += cart[j].price; &#125; System.out.println(); System.out.println(\"사용한 금액: \" + spend); System.out.println(\"남은 금액: \" + money); &#125;&#125;class Test5 &#123; public static void main(String[] args) &#123; Buyer b = new Buyer(); b.buy(new TV()); b.buy(new Computer()); b.buy(new TV()); b.buy(new Audio()); b.buy(new Computer()); b.buy(new Computer()); b.buy(new Computer()); b.summary(); &#125;&#125; 매개변수가 인터페이스일 때매개변수의 다형성에 대해 묻는 얘기인 것 같다.이렇게 다형성을 이용하면 메소드 오버로딩 해야할 경우의 수를 많이 줄일 수 있다.하지만 특정 인스턴스에 특화된 게 아니라 공통된 멤버들만 사용이 가능하다는 제약이 있다.진짜 클래스의 다형성, 매개변수의 다형성, 메소드의 다형성, 인터페이스의 다형성 등등 그지같이 많다. null Interface Interface를 구현한 클래스(인스턴스) Interface를 구현한 클래스의 자식 클래스(인스턴스) 내부 클래스의 변수 사용하기사용할 일이 있을라나… 인스턴스 변수 123456789101112class Outer &#123; // 외부 클래스 class Inner &#123; // 내부 클래스(인스턴스 클래스) int iv=100; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Outer o = new Outer(); Outer.Inner ii = o.new Inner(); System.out.println(ii.iv); &#125; &#125; 클래스 변수 1234567891011class Outer &#123; // 외부 클래스 class Inner &#123; // 내부 클래스(인스턴스 클래스) static int iv=100; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Outer.Inner ii = new Outer.Inner(); System.out.println(ii.iv); &#125; &#125; 익명 클래스얘는 어딘가 써먹을 법하다. 1회성 클래스에… 캡슐화 시키고자12345678910111213class Test &#123; public static void main(String[] args) &#123; Frame f = new Frame(); f.addWindowListener(new EventHandler()); &#125;&#125;class EventHandler extends WindowAdapter &#123; public void windowClosing(WindowEvent e) &#123; e.getWindow().setVisible(false); e.getWindow().dispose(); System.exit(0); &#125; &#125; EventHandler를 익명클래스로 작성하면123456789101112class Test &#123; public static void main(String[] args) &#123; Frame f = new Frame(); f.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; e.getWindow().setVisible(false); e.getWindow().dispose(); System.exit(0); &#125; &#125;); &#125;&#125; 상속받은 클래스의 인스턴스를 호출하고 {} 블록을 열어서 내용을 채워주면 된다.Swing에서 1회성(하나의 버튼에서만 쓰인다거나) 이벤트 핸들러를 쓸 때 이걸 많이 썼던 것 같다. Constant PoolDB의 Connection Pool 마냥 상수를 모아놓은 곳인 것 같다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"}]},{"title":"(Spring) 스타트 스프링 부트 002일차 - Hibernate와 MySQL 연결하기","slug":"Spring-boot-study-002day","date":"2017-08-03T00:17:54.000Z","updated":"2017-08-04T05:16:03.000Z","comments":true,"path":"2017/08/03/Spring-boot-study-002day/","link":"","permalink":"http://perfectacle.github.io/2017/08/03/Spring-boot-study-002day/","excerpt":"","text":"Hibernate를 써보자! (feat. MySQL) 의존성 추가(build.gradle)12345dependencies &#123; compile('org.springframework.boot:spring-boot-starter-data-jpa') compile('org.springframework.boot:spring-boot-starter-jdbc') testCompile('org.springframework.boot:spring-boot-starter-test')&#125; DB 정보 입력(및 하이버네이트 설정)/src/main/resources/application.properties에 정보를 입력해주자.이 DB 정보 입력을 datasource 지정이라고 하는 것 같다.1234567891011121314151617spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/db?useSSL=falsespring.datasource.username=idspring.datasource.password=pw# 스키마 생성(create)spring.jpa.hibernate.ddl-auto=create# DDL 생성 시 데이터베이스 고유의 기능을 사용하는가?spring.jpa.generate-ddl=false# 실행되는 SQL문을 보여줄 것인가?spring.jpa.show-sql=true# 데이터베이스는 무엇을 사용하는가?spring.jpa.database=mysql# 로그 레벨logging.level.org.hibernate=info# MySQL 상세 지정spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect 필요한 정보들은 알아서 수정하자. JPA로 엔티티 만들기 SQL로 테이블 만들고 엔티티 클래스 만들기 JPA를 통해 클래스만 설계하고 자동으로 테이블 생성하기 이 중에 후자를 택했다. (책에서) 엔티티 클래스 설계(VO 만들기, model) 12345678910111213141516import lombok.Getter;import lombok.Setter;import lombok.ToString;import java.sql.Timestamp;@Getter@Setter@ToStringpublic class Board &#123; private Long bno; private String title; private String Writer; private String content; private Timestamp regdate; private Timestamp updatedate;&#125; JPA를 위한 어노테이션 추가 123456789101112131415161718192021222324252627import lombok.Getter;import lombok.Setter;import lombok.ToString;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.UpdateTimestamp;import javax.persistence.*;import java.sql.Timestamp;@Getter@Setter@ToString@Entity@Table(name=\"tbl_boards\")public class Board &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long bno; private String title; private String Writer; private String content; @CreationTimestamp private Timestamp regdate; @UpdateTimestamp private Timestamp updatedate;&#125; @Table vs @Entity나는 엔티티 == 테이블이라고 알고 있어서 두 어노테이션의 차이점이 뭐가 있나 싶었는데@Table은 테이블에 관한 정보를 기술한 어노테이션이고,@Entity는 이 클래스의 인스턴스가 엔티티임을 명시해주는 거란다. @EntityScan나는 다른 패키지에 엔티티 클래스를 만들고 ComponentScan을 했는데 안 되서 구글링 해보니 @EntityScan 어노테이션을 써야하는 거였다.Controller와 Model을 import하는 어노테이션이 따로 있는 줄은 몰랐다.사실 스프링이며 JPA며 다 어제 처음 접한 거니 모르는 거 투성이다.근본 없이, 이해 없이 본다 하더라도 나중엔 피와 살이 되겠지 ㅠㅠ… Failed to start connector [Connector[HTTP/1.1-8080]]해당 포트를 이미 사용 중이라는데 IDE 다 껐는데도 종종 살아있는 서버가 있는갑다 ㅠㅠ아래 명령어로 pid를 확인하고 kill해주자.12lsof -i :8080kill -9 pid 테이블의 수동 생성 VS 자동 생성일단은 JPA에 익숙하지 않으니 자동으로 생성해보면서 익숙해지자!큰 규모의 프로젝트라면 테이블을 별도로 생성하고 코드를 작성하는 것이 일반적이란다! 엔티티와 엔티티 매니저 엔티티: DB 상에서 데이터로 관리하는 대상‘상품’, ‘회사’, ‘직원’ 등과 같이 명사인 것들(아마 테이블로 뽑아낼 수 있는 걸 얘기하는 듯…?)DB에서는 엔티티를 위해 테이블을 설계하고 데이터를 추가하는데 이렇게 추가된 데이터를 인스턴스 혹은 레코드라고 부란다.상품, 회사 이것들 하나 하나가 엔티티 타입이 되며 이 엔티티 타입을 생성한다는 의미는 하나의 클래스를 작성한다는 의미가 된다.또한 JPA에서의 엔티티는 하나의 클래스(엔티티 타입, 테이블)이 될 때도 있고 하나의 인스턴스(레코드)를 뜻할 때도 있다. 엔티티 매니저: 여러 엔티티 객체(아마 인스턴스이지 않을까…)들을 관리하는 역할을 한다.여기서 말하는 관리는 라이프 사이클이라고 할 수 있다.(고 한다.)엔티티 매니저는 자기가 관리해야하는 엔티티 객체를 Persistence Context(영속 컨텍스트)라는 곳에 넣고 객체들의 생사(라이프 사이클)을 관리한다. 엔티티 객체 생명주기 New(비영속): Java 영역에 객체만 존재하고, DB와 연동된 적이 없는 상태.엔티티 매니저의 관리 하에 있는 게 아니기 때문에 순수한 Java 객체 Managed(영속): DB에 저장되고 메모리 상에서도 같은 상태로 존재하는 상태.객체는 영속 컨텍스트 내에 들어가게 되고 PK를 통해 엔티티 객체를 꺼내 사용할 수 있다. Removed(삭제): DB에서 삭제된 상태, 객체는 더 이상 영속 컨텍스트에 존재하지 않는다. Detached(준영속): 영속 컨텍스트에서 엔티티 객체를 꺼내서 사용하는 상태.고유한 PK는 있지만, 아직 DB와 동기화가 이루어지지 않은 상태.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"http://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://perfectacle.github.io/tags/Hibernate/"},{"name":"MySQL","slug":"MySQL","permalink":"http://perfectacle.github.io/tags/MySQL/"},{"name":"Entity Lifecycle","slug":"Entity-Lifecycle","permalink":"http://perfectacle.github.io/tags/Entity-Lifecycle/"}]},{"title":"(자료구조) Vector vs ArrayList vs LinkedList","slug":"vector-array-list-linked-list","date":"2017-08-02T05:58:36.000Z","updated":"2017-08-05T09:03:54.000Z","comments":true,"path":"2017/08/02/vector-array-list-linked-list/","link":"","permalink":"http://perfectacle.github.io/2017/08/02/vector-array-list-linked-list/","excerpt":"","text":"위 개념들은 일단 자바에 존재한다. (다른 거에도 다 존재하려나…?)비슷비슷해서 각각의 차이점이 궁금해서 정리해보았다. 일단 이 포스트에서 소개하는 자료구조들은 Array의 다음과 같은 단점들을 극복하고자 나왔다. 길이가 한정적이라 길이를 넘어서게 되면 새로 배열을 만들고 복사를 한 후에 새로운 값을 넣어야한다는 굉장히 큰 비용을 지불해야한다. 똑같은 타입의 요소들만 들어간다. 차이점 VectorJava1 버전 대에서 제일 먼저 등장해서 아무도 없을 때는 요놈만 썼다.또한 동기화를 보장해주어 공유 자원이나 복수의 사용자가 존재할 때 좀 더 안전하게 프로그램을 작성할 수 있다.하지만 하나의 스레드가 하나의 자원을 이용하는 경우에는 오히려 성능의 저하가 발생한다.또한 공간이 모자를 때 모자른 공간x2 만큼의 공간을 확보하기 때문에 메모리를 많이 잡아먹는다는 단점도 존재한다. ArrayListArray 라는 이름이 들어갔다싶이 인덱스를 가지고 있어서 검색에 용이하다.하지만 삽입/삭제를 하려면 중간에 이빨 나간 곳을 전부 한칸씩 땡기거나 뒤로 밀어야하기 때문에삽입과 삭제가 빈번한 데이터인 경우에는 부적합하다.Vector와 달리 동기화를 보장해주지 못하고, 공간이 모자를 때는 모자른 만큼만 공간을 확보한다. LinkedList노드(데이터와 다음 노드로 연결시킬 주소지)들이 줄줄이 연결된 녀석이다.맨 마지막에 있는 녀석을 검색해야한다면 처음부터 끝까지 노드를 타고 줄줄이 이동해야해서 검색에는 적합하지 않다.하지만 삭제/삽입을 할 때는 중간에 해당 노드의 주소지만 바꿔주면 되므로 삽입/삭제가 빈번한 데이터에 적합하다. ArrayList vs LinkdedList12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ArrayLinked &#123; static long add(List list) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) list.add(i + \"\"); long end = System.currentTimeMillis(); return end - start; &#125; static long add2(List list) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) list.add(500, \"X\"); long end = System.currentTimeMillis(); return end - start; &#125; static long remove(List list) &#123; long start = System.currentTimeMillis(); for (int i = list.size()-1; i &gt;= 0; i--) list.remove(i); long end = System.currentTimeMillis(); return end - start; &#125; static long remove2(List list) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) list.remove(i); long end = System.currentTimeMillis(); return end - start; &#125; static long access(List list) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) list.get(i); long end = System.currentTimeMillis(); return end - start; &#125; public static void main(String[] args) &#123; ArrayList a = new ArrayList(200000); LinkedList b = new LinkedList(); System.out.println(\"순차적으로 추가하기\"); System.out.println(\"ArrayList: \" + add(a) + \"ms 소요\"); // 44ms System.out.println(\"LinkedList: \" + add(b) + \"ms 소요\"); // 21ms System.out.println(); System.out.println(\"중간에 추가하기\"); System.out.println(\"ArrayList: \" + add2(a) + \"ms 소요\"); // 272ms System.out.println(\"LinkedList: \" + add2(b) + \"ms 소요\"); // 18ms System.out.println(); System.out.println(\"중간에 제거하기\"); System.out.println(\"ArrayList: \" + remove2(a) + \"ms 소요\"); // 259ms System.out.println(\"LinkedList: \" + remove2(b) + \"ms 소요\"); // 458ms System.out.println(); System.out.println(\"순차적으로 삭제하기\"); System.out.println(\"ArrayList: \" + remove(a) + \"ms 소요\"); // 5ms System.out.println(\"LinkedList: \" + remove(b) + \"ms 소요\"); // 15ms System.out.println(); add(a); add(b); System.out.println(\"접근 속도 테스트\"); System.out.println(\"ArrayList: \" + access(a) + \"ms 소요\"); // 1ms System.out.println(\"LinkedList: \" + access(b) + \"ms 소요\"); // 283ms &#125;&#125; 참고자료 Java 의 Vector 와 ArrayList , Linked List 의 차이점 What are the differences between ArrayList and Vector?","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"http://perfectacle.github.io/categories/Middle-end/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"http://perfectacle.github.io/categories/Middle-end/자료구조/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"http://perfectacle.github.io/tags/자료구조/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://perfectacle.github.io/tags/LinkedList/"},{"name":"Vector","slug":"Vector","permalink":"http://perfectacle.github.io/tags/Vector/"},{"name":"ArrayList","slug":"ArrayList","permalink":"http://perfectacle.github.io/tags/ArrayList/"}]},{"title":"(Java) 자바의 정석 3판 012일차 - 다형성(클래스, 매개변수, 인터페이스), 참조타입의 형변환, 추상 클래스, 인터페이스, 단일 상속과 다중 상속","slug":"Java-study-012day","date":"2017-08-02T02:35:34.000Z","updated":"2017-08-04T04:31:21.000Z","comments":true,"path":"2017/08/02/Java-study-012day/","link":"","permalink":"http://perfectacle.github.io/2017/08/02/Java-study-012day/","excerpt":"","text":"다형성(Polymorphism)객체지향 개념에서 다형성이란 여러 가지 형태를 가질수 있는 능력을 의미함.자바에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현함. 12345678910111213141516171819202122232425public class TV2 &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown()&#123;&#125;&#125;class CaptionTV extends TV2 &#123; String text; void caption()&#123;&#125;&#125;class Test4 &#123; public static void main(String[] args) &#123; TV2 t = new TV2(); CaptionTV c = new CaptionTV(); TV2 t2 = new CaptionTV(); System.out.println(c.text); // System.out.println(t2.text); TV2에 생성된 것만 참조 가능. // CaptionTV c2 = new TV2(); CaptionTV보다 TV2가 가진 멤버가 더 적어서 생성 불가능. &#125;&#125; 다음과 같은 특성을 지닌다.참조변수 a = new 인스턴스타입() 을 기준으로 설명한다. 기본적으로는 참조변수와 인스턴스의 타입이 일치하는 걸 많이 쓴다. 참조 변수 보다 인스턴스 타입의 멤버가 더 범위가 넓어야한다.TV2 t2 = new CaptionTV();참조변수: 부모, 인스턴스 타입: 자식 -&gt; 가능, 부모의 멤버만 참조가 가능하다.CaptionTV c2 = new TV2();참조변수: 자식, 인스턴스 타입: 부모 -&gt; 불가능, 참조변수의 멤버를 모두 충족하지 못한다. 그럼 TV2 t = new TV2();와 TV2 t = new CaptionTV(); 차이점이 궁금할텐데 차차 보도록 하자. 참조 변수의 형변환(Casting)기본값과 마찬가지로 참조타입도 형변환이 가능하다.하지만 제약이 있는데 상속 관계에 있는 녀석들끼리만 가능하다.또한 부모의 부모로 형변환도 가능하므로 모든 클래스는 Object 클래스를 상속 받고 있으므로 Object 클래스로 형변환이 가능하다.참조 변수의 캐스팅의 특징은 다음과 같다. 자식 -&gt; 부모(Up-casting): 형변환 생략 가능자식이 부모의 모든 걸 상속 받았으므로 자식이 더 범위가 넓다고 판단하여 손실이 없다고 판단하는지 형변환의 생략이 가능하다. 부모 -&gt; 자식(Down-casting): 형변환 생략 불가능 우리 눈으로 보기에는 형제 관계도 있을 것 같은데 자바에서는 형제 관계가 존재하지 않아 형제 사이에 형변환은 불가능하다.그럼 TV2 t = new TV2();와 TV2 t = new CaptionTV(); 차이점을 알아보자.사실 TV2 t = new CaptionTV();는 다음을 줄인 것이다.TV2 t = (TV2)new CaptionTV(); 업 캐스팅이므로 형변환이 생략돼있던 것이다.이걸 또 풀어쓰면 다음과 같다. CaptionTV c = new CaptionTV(); TV2 t = (TV2)c역시 업캐스팅이므로 TV2는 생략이 가능하다. 그럼 위와 같은 차이점으로 인해 무엇이 달라진단 말인가?아래의 예제를 살펴보자.12345678910111213141516171819202122232425262728public class TV2 &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown()&#123;&#125;&#125;class CaptionTV extends TV2 &#123; String text; void caption()&#123;&#125;&#125;class Test4 &#123; public static void main(String[] args) &#123; TV2 t = new TV2(); TV2 t2 = new CaptionTV(); // t는 TV2 인스턴스여서 TV2의 멤버만 가지고 있으므로 CaptionTV 타입을 커버할 수가 없다. // 컴파일 시에는 올바른 형변환으로 보지만 런타임에서 체크 해보면 부모가 자식을 커버할 수 없는 원리와 같다. // CaptionTV c = (CaptionTV)t; // System.out.println(c.text); // t2는 CaptionTV 인스턴스를 강제로 TV2로 업캐스팅 해서 일단 CaptionTV 멤버를 들고는 있는데 // 접근만 못할 뿐이라 CaptionTV 타입을 커버할 수 있다. CaptionTV c2 = (CaptionTV)t2; System.out.println(c2.text); // null &#125;&#125; 이렇듯 부모 클래스에서 자식 클래스로 형변환이 가능하지만부모 인스턴스 타입에서 자식 참조 타입으로 변환하지는 못한다.이 말을 풀어 쓰면 TV2 t = new TV2();부모 참조 타입에 부모 인스턴스면CaptionTV c = (CaptionTV)t;자식의 참조 타입으로 변환하지 못한다. TV2 t = new CaptionTV();부모 참조 타입에 자식 인스턴스면CaptionTV c = (CaptionTV)t;자식의 참조 타입으로 변환 가능하단 소리다. instanceof 연산자자스와 비슷하다고 보면 되고, null인 참조 변수는 항상 false를 반환한다.음… 말로 설명하기 까다로우니 다음 예제를 보자. 12345678910111213141516171819202122public class TV2 &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown()&#123;&#125;&#125;class CaptionTV extends TV2 &#123; String text; void caption()&#123;&#125;&#125;class Test4 &#123; public static void main(String[] args) &#123; CaptionTV c2 = new CaptionTV(); System.out.println(c2 instanceof CaptionTV); // true System.out.println(c2 instanceof TV2); // true System.out.println(c2 instanceof Object); // true &#125;&#125; 참조변수와 인스턴스의 연결1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Parent &#123; int x = 10; static int y = 20; void method() &#123; System.out.println(\"asdf\"); &#125; static void method2() &#123; System.out.println(\"qwer\"); &#125;&#125;class Child extends Parent &#123; int x = 20; static int y = 30; void method() &#123; System.out.println(\"x=\"+x); // 20 System.out.println(\"this.x=\"+this.x); // 20 System.out.println(\"super.x=\"+super.x); // 10 &#125; static void method2() &#123; System.out.println(\"zxcv\"); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Parent p = new Child(); // (Parent)new Child(); // 인스턴스 변수인 x는 참조타입인 Parent를 따른다. System.out.println(p.x); // 10 // static 변수인 y는 참조타입인 Parent를 따른다. System.out.println(p.y); // 10 // static 메소드인 method2는 참조타입인 Parent를 따른다. p.method2(); // 인스턴스 메소드인 method는 인스턴스 타입인 Child를 따른다. p.method(); Child c = new Child(); // 인스턴스 변수인 x는 참조타입인 Child를 따른다. System.out.println(c.x); // 20 // static 변수인 y는 참조타입인 Child를 따른다. System.out.println(c.y); // 30 // static 메소드인 method2는 참조타입인 Child를 따른다. c.method2(); // zxcv // 인스턴스 메소드인 method는 인스턴스 타입인 Child를 따른다. c.method(); &#125;&#125; 참조타입에 좌지우지 되지 않고 뚝심있게 인스턴스 타입으로 밀고나가는 것은 인스턴스 메소드 밖에 없다.static 타입도 참조타입에 좌지우지 되므로 인스턴스.멤버 말고 클래스.멤버로 적어주는 것이 좋다. 매개변수의 다형성1234567891011121314151617181920public class Product &#123; int price; int bonusPoint;&#125;class Computer extends Product &#123;&#125;class Radio extends Product &#123;&#125;class Buyer &#123; int money = 1000; int bonusPoint = 0; void buy(Computer c) &#123; money -= c.price; bonusPoint += c.bonusPoint; &#125; void buy(Radio r) &#123; money -= r.price; bonusPoint += r.bonusPoint; &#125;&#125; 제품이 추가될 때 마다 계속해서 메소드를 오버로딩할 것인가…?아래와 같이 다형성을 이용하면 된다. 1234567891011121314151617181920212223class Buyer &#123; int money = 1000; int bonusPoint = 0; void buy(Product p) &#123; money -= p.price; bonusPoint += p.bonusPoint; &#125; void buy(Radio r) &#123; // 따로 처리하고 싶은 녀석만 따로 빼면 된다. money -= r.price; bonusPoint += r.bonusPoint; System.out.println(\"asdf\"); &#125;&#125;class Test5 &#123; public static void main(String[] args) &#123; Buyer b = new Buyer(); b.buy(new Radio()); // \"asdf\"까지 무사 출력된다. System.out.println(b.money); // 900으로 까였다. b.buy(new Computer()); System.out.println(b.money); // 800으로 까였다. &#125;&#125; Product의 instanceof로 자식 클래스들이 전부 걸리므로 저기서도 전부 매칭이 된다.매개변수의 다형성이 저렇게 부모 클래스로 추상화시키는 것이라면 메소드의 다형성은 오버로딩이려나…?? 여러 종류의 객체를 배열로 다루기1234567891011121314class Test5 &#123; public static void main(String[] args) &#123; // Product의 instanceof에 걸리므로 이렇게도 할 수 있다. // 물론 배열 내부에 있는 애들은 부모 타입으로 업캐스팅 된다. (형변환 연산자는 생략된 것임) Product[] p = &#123;new Computer(), new Radio(), new Radio()&#125;; // 배열은 길이가 고정적인데 반해 벡터는 10개는 기본이고, 그 이후에는 계속해서 추가된다. // 이러한 단점을 극복한 게 Vector이다. Vector는 객체 배열이다. // 따라서 클래스의 인스턴스 멤버들을 사용하려면 다운캐스팅 해줘야한다. // System.out.println(((Audio)p[3]).volume); Vector&lt;Product&gt; v = new Vector&lt;&gt;(); v.add(new Computer()); v.add(new Radio()); &#125;&#125; 추상 클래스(abstract class)미완성 클래스(설계도)이다.틀만 그려놓고 자식이 상속받아서 구현하라는 뜻이다.이 클래스를 가지고는 인스턴스를 생성하지 못한다.백지에서 클래스를 설계하기 보다는 공통된 요소를 모아논 추상 클래스를 만들고 여기 저기서 상속 받아서 클래스를 작성하면 훨씬 수월할 것이다.추상 메소드가 있으면 abstract 키워드를 붙여 상속 받아서 완성시켜야할 놈이 있다고 명시적으로 알려주는 게 좋다.abstract에는 미완성인 녀석만 있는 게 아니라 생성자나 메소드 등등 다 가지고 있을 수 있다.심지어 일반 클래스도 그냥 abstract 키워드를 붙여 추상 클래스로 만들 수 있는데 이렇게되면 직접 인스턴스 생성을 하지 못한다.상속이 자식 클래스를 만드는데 부모 클래스(공통 부분)를 이용하는 것이라면,추상화는 부모 클래스(공통 부분)을 만드는데 자식 클래스(여러 자식에서 공통되는 부분들을 추출)를 이용한다.추상화는 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업이라고 할 수 있고,구체화는 상속을 통해 클래스를 구현, 확장하는 작업이라고 할 수 있다. 추상 메소드(abstract method)일반적인 클래스에는 존재할 수 없다.몸통이 없으므로 abstract void a();와 같이 세미콜론을 찍어주고 {} 블록이 없다.일반 메소드와 달리 추상 메소드는 무조건 오버라이딩 해줘야 오류가 발생하지 않는다. 인터페이스(Interface)추상 클래스보다 추상화 정도가 훨씬 높다.인터페이스는 추상 메소드와 상수만 존재할 수 있다. 그리고 인터페이스 멤버의 제약 사항은 다음과 같다. 모든 멤버변수는 public static final이어야 하면 생략 가능하다. 모든 메소드는 public abstract이어야 하며 생략 가능하다 Java8부터 static 메소드와 default 메소드도 가능해졌다. 인터페이스의 상속은 다른 인터페이스로부터만 가능하며 다중 상속이 가능하다.인터페이스는 클래스의 Object와 같은 최고 조상이 없다.인터페이스의 모든 메소드들을 구현해야하는데 일부만 구현하는 클래스는 abstract 키워드를 붙여 추상 클래스로 만들어주면된다.인터페이스는 주로 ~able로 끝나는 것들이 많다.그 이유는 어떤 기능 또는 행위를 하는데 필요한 메소드를 제공한다는 의미를 지니기 때문이다. 123456789interface TT &#123; // public abstract void a(); void a();&#125;class T implements TT &#123; // 구현부는 원본보다 접근 지정자가 넓어야한다. public void a() &#123;&#125;&#125; 다중 상속?다중 상속을 하면 멤버(변수, 메소드) 명의 충돌 위험이 존재한다는 단점이 존재해서 Java에서는 지원하지 않는다.하지만 다른 객체 지향 언어인 C++에서는 지원하는데 반해 Java에서는 지원하지 않자 이게 단점처럼 지적을 받았다.그러다보니 마케팅(?)을 위해서인지 Java에서도 인터페이스를 통해 다중 상속(구현)을 지원하기 시작했는데 실제로 인터페이스를 다중 상속하는 경우는 드물단다. 인터페이스의 다형성클래스에서 부모 타입으로 자식 인스턴스를 생성하듯,인터페이스에서도 인터페이스 타입으로 인터페이스를 구현한 클래스의 인스턴스를 생성할 수 있다.12// Fightable 인터페이스에 존재하는 멤버들만 사용이 가능한다.Fightable f = new Fighter(); // (Fightable)new Fighter();와 동일. 그 진가는 아래 예제를 통해 발동한다.instanceof 연산자는 자기 자신, 부모, 조상, 추상 클래스, 인터페이스에 모두 걸리는 모양이다.12345678910111213141516171819202122232425262728293031public interface Parseable &#123; void parse(String fileName);&#125;class XMLParser implements Parseable &#123; public void parse(String fileName) &#123; System.out.println(fileName + \" - XML parsing completed.\"); &#125;&#125;class HTMLParser implements Parseable &#123; public void parse(String fileName) &#123; System.out.println(fileName + \" - HTML parsing completed.\"); &#125;&#125;class ParserManager &#123; public static Parseable getParser(String type) &#123; if(type.equals(\"XML\")) return new XMLParser(); return new HTMLParser(); &#125;&#125;class ParserTest &#123; public static void main(String[] args) &#123; Parseable parser = ParserManager.getParser(\"XML\"); parser.parse(\"document.xml\"); // document.xml - XML parsing completed. parser = ParserManager.getParser(\"HTML\"); parser.parse(\"document.html\"); // document.html - HTML parsing completed. &#125;&#125; 매개변수와 리턴타입으로 인터페이스가 올 수 있는데 이는 해당 인터페이스를 구현한 클래스의 인스턴스를 의미한다.그래서 Parseable라는 인터페이스 타입에 XMLParser나 HTMLParser 인스턴스를 모두 저장할 수 있는 것이다.이러한 장점은 분산환경 프로그래밍에서 그 위력을 발휘한다.사용자가 컴퓨터에 설치된 프로그램을 변경하지 않고 서버측의 변경만으로도 사용자는 변경된 프로그램을 사용할 수 있게 된다라고 하는데 뭔 소린지 모르겠다. 기본 메소드와 static 메소드Java8에 들어와서 기본 메소드가 등장했다.인터페이스에 메소드가 하나 추가되면 모든 구현체 클래스에 해당 메소드를 구현해야한다는 부담이 생긴다.따라서 아래와 같이 하면 기본적인 메소드가 생겨서 굳이 구현을 하지 않아도 오류가 생기지 않는다.1default void newMethod()&#123;&#125; // public default void newMethod()&#123;&#125; static 메소드는 인스턴스와 관계가 없는 독립적인 메소드이기 때문에 인터페이스에 넣지 않을 이유가 없다는데 그게 무슨 상관인지 모르겠다. 만약 여러 인터페이스에서 default 메소드가 중복된다면 구현하는 클래스에서 오버라이딩해야하고,부모 클래스와 default 메소드 간에 충돌이 일어나면 디폴트 메소드는 무시되고 부모 클래스의 메소드를 상속받는다. 내부 클래스클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계가 있기 때문이다.내부 클래스를 선언하면 두 클래스 멤버 사이에 서로 쉽게 접근할 수 있고, 외부에 불필요한 데이터를 감춤으로써코드의 복잡성을 줄일 수 있다. (캡슐화)","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"OOP","slug":"OOP","permalink":"http://perfectacle.github.io/tags/OOP/"}]},{"title":"(Spring) 스타트 스프링 부트 001일차 - 스프링(부트), 빌드툴, VO, Lombok, 어노테이션, Jackson, ORM, JPA, Hibernate","slug":"Spring-boot-study-001day","date":"2017-08-02T01:02:06.000Z","updated":"2017-08-04T04:29:04.000Z","comments":true,"path":"2017/08/02/Spring-boot-study-001day/","link":"","permalink":"http://perfectacle.github.io/2017/08/02/Spring-boot-study-001day/","excerpt":"","text":"자바에 대한 근본도 없고, MVC, Servelet/JSP에 대한 이해도 제대로 없는데 이런 걸 해도 될런지 모르겠지만… 일단은 시작!나머지는 병행해가면서 해보자… 스프링 vs 스프링 부트 스프링: 프론트로 치면 웹팩, 바벨, 걸프 설정 등등을 처음부터 내가 다 짜줘야함. 스프링 부트: CRA(Create React App) or Vue-CLI와 같이 알아서 설정을 도와줌.IntelliJ에서 프로젝트를 만들 때 Sprign Initializer를 선택하면 된다.보이지 않는다면 최신버전으로 업뎃하고 플러그인에서 Spring Boot가 제대로 설치/활성화 됐는지 확인하자. 스프링이란?1.0이 2004년에 나왔고 2011년에는 3.x가 나왔다.처음에는 light-weight(경량)화됐으나 지금은 매우 무겁다…Servlet/JSP에서 진보된 웹 개발 방식?이라고 해야하려나…여튼 스프링은 프레임워크이다.스프링 부트는 루비의 RoR(Ruby on Rails), 파이썬의 Flask, Django 등의 마이크로 프레임워크를 보고 영감을 얻은 것 같다.이런 마이크로 프레임워크들은 프로젝트 생성과 동시에 필요한 라이브러리를 초기화 해주며, 템플릿 등을 제공해줘 개발의 생산성을 높였다.스프링 부트는 기존 스프링의 복잡한 설정 과정이나 버전 충돌 등의 불편한 점을 제거하고 빠르고 쉬언 서버/테스트 환경을 제공해준다.또한 내부에 WAS(Web Application Server)인 Tomcat을 내장하고 있어서 따로 Tomcat을 설치할 필요가 없는 것 같다. Ant, Maven, Gradle나중에 더 자세히 조사해봐야겠지만 일단은 정리.빌드 툴이란다.빌드는 컴파일 내에 속하는 것(?) 같은데 그 중간에 해줘야하는 복잡한 과정들을 기술한 것 같다.프론트로 치면 Task Runner인 Gulp와 Grunt, 그리고 npm scripts 정도…??또한 이 안에는 의존성이 주입(?)된 라이브러리도 기술돼있으므로 npm도 포함하는 개념인 것 같다.프론트도 d3 홈페이지가서 js 파일 받고, jQuery 홈페이지가서 js 파일 받고 수동으로 해서 이걸 편하게 하기 위해(?) npm이 나왔 듯백엔드도 라이브러리 홈피가서 zip 파일 받아서 zip 파일 풀고 jar 파일 import 하는 게 귀찮아서인지 이런 툴들이 나온 것 같다. Java Bean VS VO(Variable Object)Java Bean은 일종의 스펙이고 VO는 특정한 의도를 달성하기 위해 Java Bean을 준수한 것 같다. Java Bean은 다음과 같은 스펙을 준수한 클래스를 칭하는 것 같다.(내가 아는 수준만 적어보았다.) 모든 변수는 private 접근 지정자를 지정해줘야한다. 해당 변수에 접근하기 위한 getter와 setter가 있어야한다. 이외에도 더 많은 것 같은데 나중에 다시 한 번 공부를 해보고 지금 내가 당장 이해한 수준은 위와 같다. VO는 Java Bean 스펙을 준수했는데 값 자체를 나타내며 불변(immutable)이란다.또 아래 내용을 인용했는데 이쪽이 더 이해하기 쉬운 것 같다.출처: vo하고 bean의 차이가 무엇인가요? 자바 빈은 특정 형태의 클래스를 가르키는 말이고 VO는 주로 계층형 구조에서 계층간 값을 전달하기 위해 자바 빈의 형태로 구현한 클래스입니다.그래서 지금 시점에서는 그냥 퍼블릭 생성자와 속성(컨벤션에 맞는 getter/setter 조합)을 갖는 클래스를 가르키는 뜻으로 쓰이는 만큼, POJO(Plain Old Java Object)와도 거의 동일한 개념으로 이해해도 무방합니다. Lombok이것도 라이브러리? 플러그인? 같은데 Sass가 CSS 전처리기라면 Lombok은 어노테이션 전처리기란다.프로젝트를 만들 때 Core에서 Lombok을 설정해줘야한다.IntelliJ에서 플러그인에서 설치를 해줘야하고(그래야 IDE에서 오류로 처리하지 않는다. 아마…??),또 실제로 작동하게 하려면 Setting으로 가서 … &gt; Compiler &gt; Annotation Processors로 가서 Enable 시켜주기. 일반 IDE에서는 아래와 같이 getter와 setter를 자동으로 만들어주기도 해서 굳이 Lombok을 쓸 필요가 있냐고 주장하는 사람도 있다.1234567891011121314151617181920212223242526272829public class SampleVO &#123; private String val1; private String val2; private String val3; public void setVal1(String val1) &#123; this.val1 = val1; &#125; public void setVal2(String val2) &#123; this.val2 = val2; &#125; public void setVal3(String val3) &#123; this.val3 = val3; &#125; public String getVal1() &#123; return val1; &#125; public String getVal2() &#123; return val2; &#125; public String getVal3() &#123; return val3; &#125;&#125; Lombok을 쓰면 아래와 같이 간단해진다.12345678910import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class SampleVO &#123; private String val1; private String val2; private String val3;&#125; 하지만 Lombok을 쓰면 Setter에 로직을 심을 수 없다는 단점이 존재해서 간단한 getter/setter나 기타 어노테이션 정도만 써야겠다.기타 어노테이션은 (Lombok)사용 설명을 참고하자. 스프링의 어노테이션ES.Next에도 어노테이션과 비슷한 데코레이터라는 게 있는데 아직도 어떻게 동작하는지 제대로 이해하지 못했다.자바의 정석을 차근차근 진도 빼면서 익혀봐야겠다.아 그리고 클래스나 메소드를 감싸(?)는 게 어노테이션이므로 클래스와 메소드를 먼저 작성하고 추후에 어노테이션을 뭘 쓸지 고민하고 사용하자.여튼 스프링에서 REST API를 구현하기 위해 사용한 어노테이션을 조금 익혀보자. @RestController컨트롤러 클래스에 붙이는 어노테이션, REST API를 담당하는 Controller라는 뜻인 것 같다.또한 이렇게 하면 스프링의 빈(Bean)으로 등록된단다.기존 스프링에서는 어노테이션을 사용해도 \\ 등과 같은 별도의 설정이 필요했지만 스프링 부트에서는 그런 귀찮은 작업이 필요없다. 12345678package com.example.exo.controller;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorld &#123; &#125; @ComponentScan만약 스프링 앱(main 메소드가 있고 run 하는 *.java 파일)과 같은 패키지, 혹은 자식패키지에 존재하지 않고 다른 패키지에 존재한다면해당 어노테이션을 사용해서 클래스들을 스프링에 인식시켜야한다. 12345678910111213package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@SpringBootApplication@ComponentScan(basePackages = &#123;\"com.example.demo\", \"com.example.exo\",&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 주의 사항으로 @ComponentScan 어노테이션을 쓰지 않으면 현재 패키지 내에 있는 모든 클래스를 스프링에 등록하지만@ComponentScan을 사용해서 다른 패키지를 등록하는 순간 현재 패키지는 제외된다.따라서 @ComponentScan 어노테이션을 사용한다고 하면 현재 패키지까지 추가를 무조건 해줘야한다. @GetMappingREST API 중 http method인 get에 매핑되는 녀석에 해당하는 어노테이션이다.@PostMapping, @PutMapping, @DeleteMapping도 물론 존재한다. 12345678910111213package com.example.exo.controller;import com.example.exo.vo.SampleVO;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.GetMapping;@RestControllerpublic class HelloWorld &#123; @GetMapping(\"/hello\") public String sayHello() &#123; return \"Hello World\"; &#125;&#125; JacksonVO의 toString()한 일반 문자열을 JSON 형태로 뿌려주는 라이브러리인 것 같다.Spring Boot에서 기본적으로 깔린다. JPA와 HibernateJPA는 Java Persistence API의 줄임말이고, 이 JPA를 스프링에서 쓰기 편하게 한 라이브러리가 Spring Data JPA이다. 그럼 Hibernate는 무엇일까?이 관계를 ECMAScript와 Javascript로 풀어보았다.ECMAScript는 스펙이고 Javascript는 그 스펙을 준수해서 구현한 구현체(?)이다.JPA는 스펙이고 Hibernate는 그 스펙을 준수해서 구현한 구현체(?)이다.맞을라나 모르겠다.Hibernate 말고 JPA의 구현체는 EclipseLink, DataNucleus 등등이 있다. 그럼 이 JPA는 뭘까? ORM을 자바라는 언어로 구현(?)한 것이라고 나는 본다.ORM(Object Relational Mapping)은 객체지향에서 말하는 객체와 DB에서 말하는 개체가 상당히 유사하다는 입장에서 시작했다.회원정보를 객체(클래스)로 표현한 것과 개체(Entity, DB의 Table이라고 보면 될 것 같다)로 표현한 것이 매우 유사하다는 점이다.이러한 ORM은 언어에 종속적인 게 아니라서 Java에서는 JPA가 있 듯이, Javascript 진영에는 Sequelize라는 녀석이 존재한다. 마지막으로 ORM의 장단점을 정리해보자. 장점 DB 관련 코드에 대해 유연함을 얻을 수 있다.DB가 변경되면 우리가 사용하는 Java 코드도 다 고쳐야하는데 ORM을 이용하면 모델 부분?만 고쳐주면 된단다. DB와 독립적 관계이다.RDB, NoSQL을 가리치 않는다는 소리 같다. Join 관계가 매우 복잡해지면 쌩 SQL보다 가독성이 좋다고 한다. 단점 학습 곡선(Learning curve)가 크다. 객체 지향에 대한 이해가 제대로 돼야 제대로 된 설계가 가능하다. 특정 DB의 특성을 이용할 수 없다.장점의 2를 보면 특정 DB에 의존적이지 않다는 것은 특정 DB의 특성을 이용하지 않고 범용적인 부분만 사용한다는 것이다.이러한 특성을 못 살리다 보니 튜닝이라던지 퍼포먼스 측면에서 Natvie SQL보다는 구리다는 단점이 존재한다.따라서 ORM과 Native SQL을 케바케로 잘 섞어 써야하는 것 같다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"http://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Gradle","slug":"Gradle","permalink":"http://perfectacle.github.io/tags/Gradle/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://perfectacle.github.io/tags/Hibernate/"},{"name":"VO","slug":"VO","permalink":"http://perfectacle.github.io/tags/VO/"},{"name":"Bean","slug":"Bean","permalink":"http://perfectacle.github.io/tags/Bean/"},{"name":"Lombok","slug":"Lombok","permalink":"http://perfectacle.github.io/tags/Lombok/"},{"name":"Jackson","slug":"Jackson","permalink":"http://perfectacle.github.io/tags/Jackson/"},{"name":"ORM","slug":"ORM","permalink":"http://perfectacle.github.io/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"http://perfectacle.github.io/tags/JPA/"},{"name":"Ant","slug":"Ant","permalink":"http://perfectacle.github.io/tags/Ant/"},{"name":"Maven","slug":"Maven","permalink":"http://perfectacle.github.io/tags/Maven/"}]},{"title":"(Java) 자바의 정석 3판 011일차 - 상속과 포함, 오버라이딩, super, 패키지와 클래스, 접근 지정자","slug":"Java-study-011day","date":"2017-08-01T09:30:01.000Z","updated":"2017-08-04T04:31:13.000Z","comments":true,"path":"2017/08/01/Java-study-011day/","link":"","permalink":"http://perfectacle.github.io/2017/08/01/Java-study-011day/","excerpt":"","text":"연습문제 실수 기존의 코드를 재사용할 수 있으면 하자. 123456789101112131415public class SutdaCard &#123; int num = 0; boolean isKwang = false; SutdaCard() &#123; // 이 한줄로 커버 되고 이래야 유지보수 측면에서도 용이하다. this(1, true); // num = 1; // isKwang = true; &#125; SutdaCard(int num, boolean isKwang) &#123; this.num = num; this.isKwang = isKwang; &#125;&#125; 형변환10f와 10.0f는 동일하니 쓸 데 없는 .0을 안 찍도록 하자. 지역변수 123public static void main(String[] args)&#123; &#125; args도 지역변수다.또한 main은 변수가 아니라 (클래스) 메소드이다.자바스크립트에서는 함수를 변수에 담을 수 있어서 함수도 변수의 범주 안에 속하고,함수와 메소드가 유사한 측면을 갖고 있다보니 main 메소드도 static 키워드를 썼으므로 클래스 변수인 줄 알았는데 아니었다. String vs StringBuffer1234567891011121314151617181920public class Test &#123; static void change(String str) &#123; str += \"456\"; &#125; static void change(StringBuffer str) &#123; str.append(\"456\"); &#125; public static void main(String[] args) &#123; String str = \"ABC123\"; System.out.println(str); // ABC123 change(str); System.out.println(\"After change:\"+str); // ABC123 StringBuffer str2 = new StringBuffer(\"ABC123\"); System.out.println(str2); // ABC123 change(str2); System.out.println(\"After change:\"+str2); // ABC123 &#125;&#125; String 클래스는 참조타입임에도 불구하고 내용을 변경할 수 없기 때문에 ABC123456이라는 새로운 변수를 지역변수 str에 만들고메소드 종료와 더불어 해당 지역변수도 날아가서 원하는 결과가 나오지 않는다.따라서 원하는 결과를 얻어내려면 return으로 반환 값을 받아오거나 StringBuffer 클래스를 이용해야한다. 상속생성자와 초기화 블럭은 상속되지 않고, 멤버(변수, 메소드)만 상속된다.접근 지정자가 private 또는 default는 상속은 받되, 자식 클래스에서 직접적인 접근이 불가능하다. 포함(Composite)12345678class Point &#123; int x, y;&#125;class Circle &#123; //int x, y, r; Point p = new Point(); int r;&#125; 이렇게 단위별로 클래스를 여러 개로 쪼개면 조합해서 사용할 수도 있어서 유지보수(재사용성, 적은 변경사항) 측면에서 뛰어나다. extends vs composite 원은 점이다. - Circle is a Point, 상속(extends) 원은 점을 가지고 있다. - Circle has a Point, 포함(composite) toString() 메소드1234567891011class Card &#123; public String toString() &#123; return \"asdf\"; &#125; public static void main(String[] args)&#123; Card c = new Card(); System.out.println(c.toString()); // \"asdf\" System.out.println(c); // \"asdf\" System.out.println(\"qwer\" + c); // \"qwerasdf\" &#125;&#125; java.lang.Object 클래스에 있는 메소드를 오버라이딩한 것이다.모든 객체(클래스, 인스턴스)는 Object 클래스를 상속 받는다. 단일 상속(single inheritance)또 다른 객체지향 언어인 C++에서는 다중 상속을 허용하지만, 자바는 그렇지 않다.다중 상속을 하면 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 장점이 존재하지만,클래스 간의 관계가 복잡해질 수 있고, 다른 클래스로부터 상속받은 멤버간의 이름이 같으면 구별할 수 있는 방법이 없다.static 멤버야 클래스 이름을 붙여서 구분이 가능하지만 인스턴스 멤버는 그렇지 않다.다중 상속의 장점을 포기했지만, 그럼으로 인해서 클래스 간의 관계가 명확해지고 코드의 신뢰도가 올라간다는 장점이 존재한다. 물론 아래와 같이 다중 상속을 흉내낼 수 있다.12345678910111213141516171819202122232425262728293031323334353637class TV &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown90()&#123;&#125;&#125;class VCR &#123; boolean power; int counter; void power()&#123;&#125; void play()&#123;&#125; void stop()&#123;&#125; void rew()&#123;&#125; void ff()&#123;&#125;&#125;class TVCR extends TV &#123; VCR vcr = new VCR(); int counter = vcr.counter; void play() &#123; vcr.play(); &#125; void stop() &#123; vcr.stop(); &#125; void rew() &#123; vcr.rew(); &#125; void ff() &#123; vcr.ff(); &#125;&#125; TVCR은 TV이다. (상속) TVCR은 VCR을 가지고 있다. (포함) 위 관계를 잘 활용하면 다중 상속과 같은 효과를 낼 수 있다.TVCR.play는 사실 VCR 클래스의 play 메소드를 실행하고 있다. 오버라이딩(overriding)발음상 overwrite(오버라이트)와 override(오버라이드)가 비슷하다.따라서 override는 덮어쓴다고 생각하면 될 것 같다.부모 클래스의 메소드를 재정의하는 것이다. 조건은 아래와 같다. 이름이 같아야한다. 매개변수가 같아야한다. 반환타입이 같아야한다.Java5부터는 자손 클래스의 타입으로 변경하는 것이 가능하게 되었다.covariant return type이라고도 부른다.(공변, 함께 변하는 이라는 뜻) 즉 선언부는 아예 일치해야한다는 뜻이다.하지만 접근 지정자와 예외 처리는 예외이다. 부모 클래스 보다 접근 지정자가 넓어야한다. 보통은 같은 걸 쓴다. 123456789public class Parent &#123; protected void a()&#123;&#125;&#125;class Child extends Parent &#123; protected void a()&#123;&#125; // private가 protected 보다 범위가 좁아서 오류가 난다. // private void a()&#123;&#125; &#125; 부모 클래스보다 예외 처리할 수 있는 경우가 적어야한다. 12345678910public class Parent &#123; protected void a() throws IOException, SQLException &#123;&#125;&#125;class Child extends Parent &#123; protected void a() throws IOException &#123;&#125; // 단순 갯수의 문제가 적어야하는 게 아니라 경우의 수의 문제이다. // Exception은 모든 예외의 경우를 커버하므로 경우의 수가 부모보다 훨씬 많다. // protected void a() throws Exception &#123;&#125;&#125; 인스턴스 메소드 &lt;-&gt; static 메소드가 불가능하다.또한 부모 클래스의 static 메소드를 자식 클래스에서 static 메소드로 선언하는 것은 각 클래스에 별개의 static 메소드를 선언하는 것이므로 오버라이딩은 아니다. 오버로딩 vs 오버라이딩 오버로딩(new): 기존에 없던 새로운 메소드(이름만 같은)를 선언하는 것 오버라이딩(modify): 상속받은 메소드를 수정하는 것 super vs thisthis가 인스턴스 자기 자신을 가리키는 참조 변수이듯, super는 상속받은 부모 인스턴스를 가리키는 참조 변수이다.123456789101112131415161718class Parent &#123; int x = 10;&#125;class Child extends Parent &#123; void method() &#123; System.out.println(\"x=\"+x); // 10 System.out.println(\"this.x=\"+this.x); // 10 System.out.println(\"super.x=\"+super.x); // 10 &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Child c = new Child(); c.method(); &#125;&#125; 읭? 뭐지? 싶으면 아래를 보자.12345678910111213141516171819class Parent &#123; int x = 10;&#125;class Child extends Parent &#123; int x = 20; void method() &#123; System.out.println(\"x=\"+x); // 20 System.out.println(\"this.x=\"+this.x); // 20 System.out.println(\"super.x=\"+super.x); // 10 &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Child c = new Child(); c.method(); &#125;&#125; 매개변수와 인스턴스 변수를 구분할 때 this를 썼 듯이,부모 인스턴스 변수와 자식 인스턴스 변수를 구분할 때 super를 사용하면 유용하다.물론 변수 뿐만 아니라 메소드도 가능하다. 1234567891011121314public class Point &#123; int x, y; String getLocation() &#123; return \"x: \" + x + \", y: \" + y; &#125;&#125;class Point3D extends Point &#123; int z; String getLocation() &#123; // return \"x: \" + x + \", y: \" + y + \", z: \" + z; return super.getLocation() + \", z: \" + z; &#125;&#125; this() vs super()this()는 같은 클래스 내의 생성자를 호출하기 위해 사용하는 데 비해,super()는 부모 클래스의 생성자를 호출하기 위해 사용된다.this와 마찬가지로 super도 제일 첫 줄에 호출해야하는데자식 클래스가 부모 클래스의 멤버를 사용했을 수도 있으므로먼저 부모 클래스의 생성자를 호출해서 멤버들을 초기화시켜야한다.자식 생성자에서 다른 생성자(super()나 this())가 없는 경우에는 컴파일러가 자동으로 super()를 삽입한다. 123456789101112131415161718192021222324252627282930class Test &#123; public static void main(String[] args) &#123; Point3D p = new Point3D(1, 2, 3); System.out.println(p.x + \", \" + p.y + \", \" + p.z); // 1, 2, 3 &#125;&#125;// 아무것도 상속받지 않으면 컴파일러가 자동적으로 extends Object를 붙여준다.// 그래서 equals()나 toString() 같은 메소드는 모든 클래스에서 사용이 가능한 것이다.public class Point &#123; int x, y; Point(int x, int y) &#123; // super(); // 여기에도 마찬가지로 다른 생성자(this()나 super())가 없으므로 자동으로 super()가 삽입된다. // 아마 최상위 부모인 Object까지 타고 가지 않을까 싶다. this.x = x; this.y = y; &#125;&#125;class Point3D extends Point &#123; int z; Point3D(int x, int y, int z) &#123; // super()가 자동으로 삽입되지만 부모 클래스에는 Point() 생성자는 없고 Point(int x, int y) 생성자만 존재한다. // this.x = x; // this.y = y; super(x, y); this.z = z; &#125;&#125; 따라서 Point3D 클래스의 인스턴스의 생성 순서는 다음과 같다. Point3D(int x, int y, int z) Point(int x, int y) Object() 패키지와 클래스클래스: 물리적으로 하나의 파일(*.class)패키지: 물리적으로 하나의 디렉토리java.lang.String -&gt; java 패키지(디렉토리) 안에 lang 패키지(디렉토리) 안에 String 클래스(파일)패키지(디렉토리)가 다르면 클래스(파일)명은 같아도 된다. 모든 클래스는 반드시 패키지 안에 속해야하며 패키지를 명시하지 않으면 default package로 같은 패키지 안에 속하게 된다. importimport 문은 다른 패키지에 있는 클래스를 사용할 때 패키지 명을 붙이지 않고 사용할 수 있게 해준다.123456789import java.util.Scanner;public class Test2 &#123; java.util.Scanner sc = new java.util.Scanner(System.in); &#125;class Test4 &#123; Scanner sc = new Scanner(System.in);&#125; import 문을 많이 쓰거나 import java.util.* 처럼 *을 썼다고 해서 실행할 때 퍼포먼스 상 차이는 없다.단지 컴파일 시간이 조금 더 오래 걸릴 뿐이다.하지만 *을 쓰면 어떤 패키지의 클래스인지 구분하기 어려울 때가 있다.또한 *은 클래스에만 매칭되지 하위 패키지까지 매칭되는 것은 아니다. 123// 이렇게 하면 java 패키지의 클래스만 매칭되지 // java 패키지 내부에 있는 util 패키지까지 import 되는 것은 아니다. import java.*; 같은 패키지 내의 클래스들은 import 없이도 사용이 가능하다! 또한 System이나 String 클래스는 어떻게 패키지를 import하지 않고도 사용이 가능했던 걸까?같은 패키지 내의 클래스는 import 없이 사용 가능하다는데 그럼 모든 패키지에는 System이나 String 과 관련된 패키지가 삽입된 걸까?123// 컴파일러가 자동적으로 아래와 같은 import 문을 삽입해주기 때문이다.// 해당 패키지의 클래스들은 매우 빈번하게 사용하기 때문이다.import java.lang.*; static import 문import를 하면 패키지명을 생략할 수 있듯이static 키워드를 사용하면 클래스명을 생략할 수 있다.단 export 한 녀석은 public static이어야한다.1234567891011import static java.lang.System.out;import static java.lang.Math.random;// 아래와 같이 하면 Math 클래스의 모든 public static 메소드(random, ceil, abs 등등)에서 Math 클래스를 생략 가능하다. // import static java.lang.Math.*;class Test2 &#123; public static void main(String[] args) &#123; // System과 Math가 생략이 가능해졌다. out.println(random()); &#125;&#125; 그냥 import는 package.*로 해서 모든 클래스들을 불러와서 패키지 명을 생략가능하게 했다면static import는 package.class.*로 해서 클래스 내의 모든 멤버를 불러와서 클래스 명을 생략 가능하게 했다고 알아두면 될 것 같다. 클래스 멤버 vs 인스턴스 멤버멤버: 변수, 메소드클래스 멤버는 static 멤버라고도 부른다.인스턴스 멤버를 사용하지 않는 인스턴스 메서드는 static 메서드로 바꾸는 걸 고려해보자. 다음과 같은 장점이 있다. 클래스가 메모리에 로드될 때 단 한번만 수행된다. 인스턴스를 생성하지 않고 호출이 가능하다. 더 편리하고 속도도 더 빠르다. final 변수 -&gt; 상수로 만들어버림. 메소드 -&gt; 오버라이딩이 불가능해짐. 클래스 -&gt; 상속받지 못하는 클래스가 됨. 예외로 인스턴스 변수는 상수로 선언만 했을 때는 생성자 함수에서 초기화가 가능하다.그 이유는 생성자 함수에서 초기화가 불가능하다면 모든 인스턴스마다 같은 인스턴스 상수를 갖게 될 것이기 때문이다.인스턴스 상수도 일단은 인스턴스 변수이니 인스턴스마다 다른 값을 가져야 의미가 있는 것이지 다 같은 값을 가지면 static 변수와 큰 차이점이 없게 된다. 1234567891011class Test2 &#123; final int x; final int y = 10; Test2() &#123; x = 10; // 초기화 되지 않은 상수를 초기화 시켜주지 않고 방치하면 오류가 발생한다. // y = 20; 초기화만 가능하지 재할당은 불가능하다. &#125; void a() &#123; // x = 22; 생성자 함수 이외에는 불가능하다. &#125;&#125; 접근 지정자 제어자 같은 클래스 같은 패키지 자식 클래스 전체 public O O O O protected O O O X (default) O O X X private O X X X 대상 사용 가능한 접근 지정자 클래스 public, (default) 멤버 public, protected, (default), private 지역변수 없음 접근 지정자를 사용하는 이유는 다음과 같다. 외부로부터 데이터를 보호하기 위해서 외부에는 불필요하고 내부적으로만 사용하는 부분들을 감추기 위해서이러한 것들을 캡슐화(encapsulation)이라고 부른다.데이터가 유효한 값을 유지하고, 비밀번호 같은 데이터를 외부에서 함부로 변경하지 못하게 하기 위함.이렇게 접근 범위를 축소해나가다 보면 테스트를 할 때도 다른 패키지들을 다 커버할 필요없이 해당 코드가 접근 가능한 부분들만 테스트하면 되니 유지보수 측면에서도 용이하다.또한 getter와 setter를 써서 변수의 유효성 검사도 할 수 있다. 12345678910111213141516171819202122public class Time &#123; private int hour; public int getHour() &#123; return hour; &#125; public void setHour(int hour) &#123; if(hour &gt; 0 &amp;&amp; hour &lt; 24) this.hour = hour; &#125;&#125;class TimeTest &#123; public static void main(String[] args) &#123; Time t = new Time(); // t.hour = 25; 접근지정자가 없으면 유효한 시간 값인지 검사할 방법이 없다. t.setHour(25); System.out.println(t.getHour()); // 0 t.setHour(11); System.out.println(t.getHour()); // 11 &#125;&#125; 또한 생성자에 접근 제어자를 사용하면 싱글톤 패턴을 구현할 수 있다.싱글톤: 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴. 123456789101112131415161718192021// 싱글톤 객체는 상속이 불가능하다.// 왜냐하면 자식 클래스에서 부모 클래스의 생성자 호출이 불가능하기 때문이다.// 따라서 명시적으로 final 키워드를 붙여서 상속이 불가능한 클래스라는 것을 표기해주는 게 좋다.public final class Singleton &#123; private static Singleton s = new Singleton(); private Singleton() &#123; System.out.println(11); &#125; public static Singleton getInstance() &#123; return s; &#125;&#125;class SingletonTest &#123; public static void main(String[] args) &#123; // Singleton s = new Singleton(); private이므로 다른 클래스에서 생성자에 접근 불가 // 클래스의 인스턴스를 얻으려면 이미 static 변수에 저장된 동일한 인스턴스만 불러오면 된다. Singleton s = Singleton.getInstance(); System.out.println(s); &#125;&#125; 또한 다음과 같은 주의사항이 있다. 메소드에 static과 abstract를 함께 사용할 수 없다.abstract는 몸통이 없는 불완전한 애이고, static은 클래스가 로딩되자마자 메모리에 적재되므로구현이 안 된 애를 메모리에 적재할 수는 없다. 클래스에도 abstract와 final을 함께 사용할 수 없다.abstract는 선언부만 던져주고 상속받아서 알아서 구현하라는 키워드인데final 키워드를 붙여 상속이 불가능하게 만들면 모순되는 말이다. 메소드에 abstract와 private를 함께 사용할 수 없다abstract는 선언부만 던져주고 상속받아서 알아서 구현하라는 키워드인데private 키워드는 그 상속받은 자식 클래스에서 조차 접근이 불가능하므로 모순되는 말이다. 메소드에 private과 final을 같이 사용할 필요는 없다.private인 메소드는 자식에서도 접근이 불가능하기 때문에 오버라이딩 될 수 없다. 이미 둘 다 같은 역할을 하기 때문에 하나만 사용하면 된다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"OOP","slug":"OOP","permalink":"http://perfectacle.github.io/tags/OOP/"}]},{"title":"(자작) Hexo theme overdose starter","slug":"hexo-theme-overdose-starter","date":"2017-07-21T15:58:01.000Z","updated":"2017-07-23T03:41:48.000Z","comments":true,"path":"2017/07/22/hexo-theme-overdose-starter/","link":"","permalink":"http://perfectacle.github.io/2017/07/22/hexo-theme-overdose-starter/","excerpt":"","text":"깃헙 저장소로 바로가기 만든 계기기본적으로 헥소로 블로그 테마를 얹히는 것은 크게 어렵지 않다.하지만 적용한 테마를 깃헙에 올리고 다른 컴퓨터에서 다운받으려고 하면 참담한 결과를 맞이하게 된다.이유는 다음 스크린샷을 보면 알게 된다.이러한 문제점은 모든 테마에서 발생하고 있으며 .git 폴더를 삭제하면 해결되는 문제이다.하지만 이미 컴퓨터를 포맷한 이후라면 여태까지 커스터마이징한 내역을 복구가 불가능할 것이다. (지못미 ㅠㅠ)물론 .gitignore도 삭제해야 우리가 여태까지 테마를 커스터마이징한 설정 파일인 _config.yml까지 형상관리가 가능하게 된다. overdose 테마의 문제점일단 한국인이 만들었고, 테마도 깔끔하다는 점은 굉장히 높게 평가할만 하다.하지만 다음과 같은 문제점이 존재한다. overdose에서 사용하는 패키지 중에 Node 8을 지원하지 않는 패키지가 있는데 명시돼있지 않다! (Node 7 버전 이하만 사용 가능한 테마이다.) 또한 테마를 설치하고 테마의 디렉토리로 이동해서 항상 아래 명령어를 입력해주어야한다.(packge.json 참조)1npm run clone 해당 명령어는 다음과 같은 역할을 한다. https://github.com/spoqa/spoqa-han-sans 저장소를 source/libs/spoqa-han-sans 폴더로 클론한다.이 과정이 제일 문제가 많다. 해당 저장소를 가보면 Original과 VFB_FILES 디렉토리를 보면 폰트 개발자나 관심있을 법한 폰트 관련한 파일들이 존재한다.우리에게 필요한 것은 웹폰트와 css 파일이 전부인데 쓸 데 없는 파일까지 클론을 받게 되는 것이다.뭐 이게 무슨 대수냐고 볼 수도 있는데 두 디렉토리의 용량이 각각 238MiB와 195MiB에 달한다.테마의 국제화를 겨냥한 것인지 일본어 폰트까지 제공해주는 테마에서 이렇게 큰 용량은 인터넷 속도가 빠른 한국에서도 부담이 될 수 밖에 없는 용량이다. https://github.com/hyunseob/noto-sans-kr 저장소를 source/libs/noto-sans-kr 폴더로 클론한다.이 과정에서는 2MiB 정도의 데이터만 다운받기 때문에 큰 시간은 소요되지 않는다. 하지만 위 과정에도 역시나 문제는 존재한다.이유는 바로 클론을 받았기 때문에 해당 디렉토리 내에도 .git 디렉토리가 존재한다.따라서 .git 디렉토리를 지워주고 다시 올려야 나중에 클론할 때도 폰트 파일까지 정상적으로 받아오게 된다.물론 폰트파일만 400MiB가 넘을테지만… 아마 최신의 폰트를 제공하고자 해당 저장소의 내용을 내포하고 있는 게 아니라 클론시키게 하다보니 이런 문제점이 발생하는 것 같다.하지만 해당 폰트는 CJK(중국, 일본, 한국) 계열에서나 쓸 법한 폰트지 그 이외의 국가에서는 사용하지 않을 법 하므로 필수적으로 설치하지 않게 한 것은 높은 점수를 줄만하다. 그래서 어떻게 해결했나? overdose 테마가 저장소에 올라가지 않던 문제테마를 커스터마이징한 내역을 내포하게 끔 하다보니 내가 작업한 현 시점의 overdose 최신 테마를 stater 저장소에 추가하였다.v0.2.8이 최신이지만, 내가 업데이트하지 않는 한 해당 테마의 최신버전을 따라서 업데이트가 되긴 힘들 것이다. spoqa-han-sans 폰트의 용량이 400MiB가 넘어가던 문제이건 최소한으로 용량을 줄이고자 웹폰트(*.ttf 제외, 용량이 커서…)와 css 파일만 따로 뺀 저장소를 한국어, 일본어 버전으로 만들었다.이것도 내가 spoqa-han-sans의 업데이트에 발맞춰 갱신하지 않는 이상은 해당 버전과 발맞춰 따라가기가 힘들 것이다. 설치한 폰트가 저장소에 올라가지 않던 문제이 문제는 클론 받는 대신에 그냥 저장소 자체에 폰트 파일을 내장하면 되지만 그렇게 되면 두 가지 문제점이 존재한다. 폰트를 최신 버전이 아닌 내가 저장소에 추가한 시점의 폰트만 사용이 가능하다. (그렇다고 해서 내가 폰트 파일을 계속 업데이트 할 지는 모르겠지만…) CJK 계열이 아닌 다른 국가에서도 해당 폰트를 필수로 설치해야한다. (용량이 20MiB에 달한다. 일어만 16MiB…) 따라서 해당 문제는 클론을 받되 해당 디렉토리의 .git을 삭제하는 단계를 거치도록 하였다.물론 명령어로 해결하면 되지만, 윈도우 유저와 Mac 폴더 삭제부터 명령어 차이가 나기 때문에(npm scripts에서 구분은 불가능한 걸로 알고 있다.)node에서 지우도록 rm-git.js라는 파일을 만들었다. 클론이 끝난 이 후에 이 파일을 실행하게 된다. 또한 폰트 설치 옵션을 다음과 같이 세분화하였다.왜냐하면 noto-sans-kr이나 spoqa-han-sans-kr은 각각 2MiB 남짓이라 크게 부담되지 않을 수 있는데,spoqa-han-sans-jp는 한자 때문인지 16MiB에 달해 부담이 될만한 용량이라 각각 나눠놨다. noto-sans-kr spoqa-han-sans-kr spoqa-han-sans-jp 한국어 폰트(noto-sans-kr, spoqa-han-sans-kr), Spoqa 폰트(spoqa-han-sans-kr, spoqa-han-sans-jp), 모든 폰트(noto-sans-kr, spoqa-han-sans-kr, spoqa-han-sans-jp) 추가된 사항 정적인 html 파일들만 버전관리가 되는 문제기존 헥소 블로그에는 위와 같은 고질적인 문제가 존재한다.따라서 나는 이러한 문제를 해결하고자 과거에는 md나 기타 파일들을 관리하는 저장소를 따로 팠었는데 그냥 브랜치를 하나 파서 하나의 저장소에서 관리하게끔 하였다.그리고 새로 만든 브랜치를 default 브랜치로 정해놓으면 더 편하다. 포트폴리오를 블로그 위에 얹기원래 깃헙 페이지는 블로그가 메인이 아니라 정적 페이지를 서비스하는 게 메인인 것으로 알고 있다. (아닌가…?)그럼 블로그 위에 포트폴리오도 얹을 수 있다는 발상이 떠오르게 된다.물론 포트폴리오는 웹서버나 DB를 사용하지 않는 동적인 페이지만 가능하다. (예를 들면 홈페이지나 웹 어플리케이션)이 디렉토리에 있는 파일들은 아래와 같이 접근이 가능하다. SEO 친화적으로 만들기(검색 엔진에 노출 잘 되게 만들기) hexo-generator-seo-friendly-sitemap을 이용하여 사이트맵 만들기. hexo-generator-feed을 이용하여 RSS Feed를 만들기. hexo-autonofollow를 이용하여 크롤러를 위해 외부 링크에는 nofollow 속성이 달리게 끔 하기. 대표 URL(선호 URL)을 지정해주는 canonical 속성 추가하기. 남은 과제overdose 테마의 컨트리뷰터가 되어 이렇게 스타터 저장소를 만들 게 아니라근본적인 문제를 해결하고자 해당 저장소에 pull request를 몇 개 날려봐야겠다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"자작","slug":"기타/자작","permalink":"http://perfectacle.github.io/categories/기타/자작/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://perfectacle.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://perfectacle.github.io/tags/hexo/"},{"name":"starter","slug":"starter","permalink":"http://perfectacle.github.io/tags/starter/"}]},{"title":"(JS) 문자, 단어, 동음이의어 갯수 세기","slug":"js-count-char-word","date":"2017-07-18T14:14:51.000Z","updated":"2017-07-18T14:52:20.000Z","comments":true,"path":"2017/07/18/js-count-char-word/","link":"","permalink":"http://perfectacle.github.io/2017/07/18/js-count-char-word/","excerpt":"","text":"웰 컴 투 정규표현식 문자 &amp; 단어 세기1234567891011const str =`반응형웹, 반응형 웹, Responsive, responsive web 웹표준웹표준, 웹 표준, Web Standard, web Standard`;const countChar = (char, str) =&gt; &#123; const matchedChars = str.match(new RegExp(char, 'gmi')); return matchedChars ? matchedChars.length : 0;&#125;;console.log(countChar('웹', str)); // 5console.log(countChar('웹표준', str)); // 2 동음이의어 세기123456789101112131415161718let str =`반응형웹, 반응형 웹, Responsive, responsive web 웹표준웹표준, 웹 표준, Web Standard, web Standard`;const homonym = ['웹 표준', '웹표준', 'Web Standard'];const countHomonym = (homonym, str) =&gt; &#123; let cnt = 0; for(const word of homonym) &#123; const regExp = new RegExp(word, 'gmi'); const matchedWords = str.match(regExp); if(matchedWords) cnt += matchedWords.length; &#125; return cnt;&#125;;console.log(countHomonym(homonym, str));","categories":[],"tags":[]},{"title":"(후기) 키워드 크롤러를 만들고 나서...","slug":"keyword-crawler-review","date":"2017-07-18T06:34:38.000Z","updated":"2017-08-03T08:32:20.000Z","comments":true,"path":"2017/07/18/keyword-crawler-review/","link":"","permalink":"http://perfectacle.github.io/2017/07/18/keyword-crawler-review/","excerpt":"","text":"프로젝트로 바로가기 왜 만들었나?수작업을 줄여보자.과거 어떤 사람이 프론트 엔드 개발자 채용 공고에서 직접 수집한 키워드를 빈도수 별로 모은 자료를 보여준 적이 있다.이후에 크롤러의 존재에 대해 알고 나서 물어보니 수작업으로 했다고 한다. (그렇기 때문에 신뢰도가 좀 더 높은 것 같다.)이런 수작업(노가다성)을 어떻게 하면 줄일 수 있을까 고민을 하면서 만들어보고 싶다는 막연한 생각만 가지고 있었다. 백엔드 개발자가 되려면 뭘 공부해야하는지 알고 싶었다.작년부터 같은 고민을 했지만 백엔드 개발자가 되고 싶었다. HTML/CSS를 만지는 시간은 행복하지 않았고,오로지 자바스크립트 하나 때문에 프론트 엔드 개발 공부를 계속 했고, 쉽게 쉽게 취업하자는 생각에 프론트 엔드 개발자로 취업을 하였다.(프론트 엔드 개발자로 취직하는 게 쉽다는 게 아니라 내 기준에서 프론트 엔드 개발 공부만 1년 가까이 했기 때문에 백엔드보다 더 쉽다는 뜻이다.)하지만 작업하면서 역시나 행복하지 않았다. 그래서 그런지 작업 속도도 느리고, 내 코드 자체에 만족하지 못했다.백엔드도 직접 경험해본 건 아니어서 재미없다고 생각할지 모르겠지만 후회하더라도 직접 경험 해보고 후회하고 싶었다.다른 사람들은 목표로 정한 회사가 있느냐고 물었지만, 나는 그냥 개발이 중심이고, 대우받는 그러한 환경에서 작업을 한다면 다른 건 크게 신경쓰지 않는 타입이다.어찌보면 어리석고 철이 덜 들은 건지 모르겠지만 개발 이외에는 하기가 싫다는 생각이 들었다. (물론 고쳐야할 생각이다.)따라서 일단은 회사를 목표로 하기 보다는 여러 기업에서 백엔드 개발자라면 어떤 걸 알고 있어야하는지 알아내는 게 중요했다.최대한 많은 회사에서 요구하는 것들부터 집중적으로 배워나가면 된다고 생각했기 때문이다. 좋았던 점배웠던 걸 써먹을 수 있었다.자바스크립트와 Node.js를 이용한 웹 크롤링 테크닉란 책으로 스터디를 한 적이 있었다.책의 구성은 큰 덩어리 덩어리로 나눠져 있지만, 그 내부의 작은 덩어리로 봤을 때는 되게 비슷한 내용들끼리 묶여져있어서스터디를 할 때도 계속 비슷한 예제 타이핑하고 실행해보고 하느라 다소 지루한 감이 없지 않았고, 후딱 끝내버리자는 의견도 나왔었다.책 안의 내용 자체는 좋았지만 ‘이걸 일일이 타이핑하고 실행해봐야하나’라는 의문이 들 정도였다.그래도 해당 주제로 스터디를 한 바람에 크롤러, 헤드리스 브라우저, 형태소 분석기 등등 어떤 키워드로 검색해야할지,샘플 코드는 뭘 참조해야할지에 대해 힌트를 많이 알고 있었기 때문에 크롤러를 만들어보는데 훨씬 수월하였다. 비동기 작업을 동기식으로 작성해 볼 기회가 많았다. 무한 스크롤을 하기 위해서는 순차적으로 스크롤을 아래로 계속 내려야하는 점. 채용 공고 하나 들어가서 수집하고 다시 다른 공고 들어가서 수집하고 순차적으로 이뤄져야한다는 점. 위 코드들을 작성하면서 async/await를 제대로 써본 것 같다.그러면서 Async/Await는 배열 표준 메소드에서 작동하지 않는다.라는 점도 알게 되었다. 아쉬웠던 점타입스크립트 넘나 어려운 것맨 처음에는 타입스크립트를 도입하려고 했다.하지만 팬텀 자체도 phantomjs에서 phantomjs-prebuilt라고 이름을 바꿀 만큼 변화가 많았는데phantomjs에 대한 d.ts는 있었는데 phantomjs-prebuilt에 대한 d.ts는 없었다.새로 만들자니 시간도 오래 걸릴 것 같고… 이거 때문에 너무 시간을 지체하는 느낌이 많이 들었다.약 만 하루동안 타입스크립트를 가지고 뻘짓을 해보다 과감히 포기하였다.나중에… 나중에는 기필코 타입스크립트를 다른 라이브러리들과 함께 써봐야겠다. 테스트 코드의 부재역시나 테스트 코드를 작성하는 건 감을 잡기 어렵다.테스트 코드를 작성하는 것보다 무엇을 테스트 해야할지를 감을 못 잡겠다.그러다보니 그냥 코드만 계속 작성하고 결국 테스트 코드는 작성하질 못했다…하… 나 혼자 스스로 능동적인 공부를 해 본 경험이 적다보니 역시 이런 쪽은 쥐약이다 ㅠㅠ… 외국어 형태소 분석의 부재mecab-ko-dic에는 한국어 단어만 들어가있어서 외국어의 형태소 분석이 되질 않는다.따라서 이 예제는 외국어로 작성된 채용 공고에는 부적합하다.형태소 분석을 두 번 돌려야하는 것 같은데… 넘나 어려워보여서 시도도 하지 않았다 ㅜㅜ하지만 역으로 국내 쪽 채용 공고는 기술 스택들만 영어로 기재하는 경우가 있어서 오히려 신뢰도가 높다는 장점도 존재한다. 이상한 키워드까지 분류된다형태소 별로 분석하다보니 구두점이나 쓸 데 없는 기호들, 을/를과 같은 조사 등등은 빠져서 참 좋다.명사만 필터링해서 좋긴 좋은데… 아래와 같은 단점이 존재한다. 웹 표준 이라는 키워드가 있으면 웹 따로 표준 따로 분류해버린다. 프론트 엔드 개발 같은 경우에도 세 가지를 따로 따로 분류해버린다. 기업이 채용 공고에 기술 스택만 올리는 게 아니다보니 관련 없는 단어들까지 분류돼서 나온다. 아직 실력이 많이 모자라서 일일이 수작업으로 해야하는데 손이 너무 많이 가는 작업이라 엄두도 못 내고 있다. 차트나 그래프로 표시하기에 부적합하다.이상한 키워드들이 너무 많이 뽑혀져 나오다보니… 차트나 그래프로 표시하면 알아보기 힘든 경우가 굉장히 많다.화면은 한정적인데 키워드들이 너무 많아서 렉이 걸리거나 마우스를 올려도 원하는 곳으로 올리기 힘든 경우도 있고…그렇다고 표로 표시하기에는 너무 길어지고 이쁘지도 않아서… 이 문제점은 확실히 이상한 키워드들을 전부 필터링해야 어느정도 해결이 될 것 같다. 특정 사이트에 한정적이다.이 예제만 하더라도 페이지네이션 페이지에는 부적합하고 무한 스크론 페이지에만 적합하다.또 내가 만든 원티드 크롤러만 하더라도 원티드의 마크업 구조가 달라지면 해당 내용을 제대로 크롤링하지 못할 수도 있다.원래 크롤러가 그런 건지 모르겠지만… 이거는 도저히 내 머릿 속에서는 해결이 불가능한 난제로 남을 것 같다. 남은 숙제들서버 구현하기매일 매일 정보를 크롤링해서 업데이트 하려면 24시간 켜져있는 서버 혹은 수동으로 매일 매일 해줘야한다.하지만 수동으로 하는 것은 비효율적이고 서버를 한 대 구동해야하는데 집에 남아있는 컴퓨터가 없다.이를 위해서 한 번 라즈베리 파이를 사서 리눅스도 올려보고, 웹 서버도 올려보고 이것저것 해보고 싶다.좀 더 검토해보고 라즈베리 파이를 사서 직접 서버를 구현해보면서 백엔드의 이것 저것을 공부해봐야겠다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"http://perfectacle.github.io/categories/기타/잡동사니/"}],"tags":[{"name":"review","slug":"review","permalink":"http://perfectacle.github.io/tags/review/"}]},{"title":"(자작) 키워드 크롤러","slug":"keyword-crawler","date":"2017-07-18T04:59:43.000Z","updated":"2017-08-03T08:32:20.000Z","comments":true,"path":"2017/07/18/keyword-crawler/","link":"","permalink":"http://perfectacle.github.io/2017/07/18/keyword-crawler/","excerpt":"","text":"소스 코드 보러가기사이트에서 원하는 내용만 수집해오는 크롤러.더 나아가 mecab-ko와 같은 형태소 분석기를 사용하면 키워드 별로 분류하고 빈도수도 알아낼 수 있다.무한 스크롤 페이지에 적합하게 만들었고, 페이지네이션 사이트를 크롤링 하려면 직접 구현해야한다.원티드의 프론트 개발 지원 자격을 크롤링 하여 키워드 별로 분류 후 나타낸 그래프 설치1npm i 형태소 분석기(한국어 버전) mecab-ko mecab-ko-dic 개발하기첫 번째로 태스크 러너를 실행해야한다. (gulp) eslint babel 1npm run dev 두 가지 태스크를 먼저 수행한 후에 ES5로 트랜스파일 된 파일을 실행하면 된다.혹시 다른 태스크를 실행하고 싶다면 gulpfile.js 를 수정한 후 package.json의 npm script를 수정하거나npm v5.2.0 이상이라면 npx를 사용하자.1npx gulp TASK_NAME 두 번째로 크롤러 코드를 작성해야한다. 크롤러 코드 (/src/crawlContents.js) 크롤링한 내용을 형태소로 분석하기 위한 코드(/src/morphemeParser.js) 형태소로 분류한 단어들의 빈도수를 구하기 위한 코드(/src/countKeyword.js) 이 프로젝트는 완성본이 아니기 때문에 위 코드들을 구현해줘야한다.실제로 구현된 내용은 페이지의 무한 스크롤 컨텐츠를 모두 로딩하는 것 밖에 없다.위 코드들을 어떻게 작성해야할지 감이 잡히지 않는 사람들은 demo 디렉토리에 있는 예제를 보자.해당 예제는 구인구직 사이트인 원티드에서 프론트 엔드 개발자의 지원 자격을 키워드 별로 뽑아내는 예제이다. 세 번째로 크롤러를 구동하자.1npm start 만약 다른 크롤러를 구동하고 싶다면 package.json의 npm script를 수정하거나npm v5.2.0 이상이라면 npx를 사용하자.1npx phantomjs ANOTHER_CRAWLER.js 데모 크롤러 구동해보기1npm test 무한 스크롤 콘텐츠를 모두 로딩하고 100 여 개가 넘는 채용 공고를 크롤링 하기 때문에 시간이 다소 걸린다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"자작","slug":"기타/자작","permalink":"http://perfectacle.github.io/categories/기타/자작/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://perfectacle.github.io/tags/node-js/"},{"name":"crawler","slug":"crawler","permalink":"http://perfectacle.github.io/tags/crawler/"},{"name":"phantomjs","slug":"phantomjs","permalink":"http://perfectacle.github.io/tags/phantomjs/"},{"name":"mecab","slug":"mecab","permalink":"http://perfectacle.github.io/tags/mecab/"}]},{"title":"(ES2015+) Async/Await는 배열 표준 메소드에서 작동하지 않는다.","slug":"es8-async-fact","date":"2017-07-17T11:00:04.000Z","updated":"2017-07-17T11:00:51.000Z","comments":true,"path":"2017/07/17/es8-async-fact/","link":"","permalink":"http://perfectacle.github.io/2017/07/17/es8-async-fact/","excerpt":"","text":"1234567891011const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 제대로 작동하질 않는다.nums.forEach(async (num) =&gt; &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;);&#125;); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 역시 마찬가지로 제대로 작동하지 않는다.(async() =&gt; &#123; nums.forEach(async (num) =&gt; &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;); &#125;);&#125;)(); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 이터레이터에서는 잘 작동한다.(async() =&gt; &#123; for(const num of nums) &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;); &#125;&#125;)(); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 물론 일반 반복문에서도 잘 작동한다.(async() =&gt; &#123; for(let i=0, len=nums.length; i&lt;len; i++) &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(nums[i]); res(); &#125;, 1000); &#125;); &#125;&#125;)(); 아마 실행 주도권이 배열 표준 메소드 내부의 콜백 함수가 가지게 되어서 그런 게 아닐까?","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://perfectacle.github.io/tags/promise/"},{"name":"ES2015+","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"async","slug":"async","permalink":"http://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"http://perfectacle.github.io/tags/await/"}]},{"title":"(자알쓰) 변수","slug":"js-011-variable","date":"2017-07-01T05:39:27.000Z","updated":"2017-07-01T05:39:27.000Z","comments":true,"path":"2017/07/01/js-011-variable/","link":"","permalink":"http://perfectacle.github.io/2017/07/01/js-011-variable/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 한 번째 시리즈는 변수를 주제로 진행하겠다. 변수란?이번 주제는 정재남 님의 자바스크립트 세미나를 듣고 해당 자료를 토대로 내 맘대로 해석한 포스트이다.책을 보다보면 변수는 그냥 값들을 담아놓는 상자 정도로 설명해놓는다.과연 이게 변수의 끝일까? 정말 변수는 이렇게 작동할까?뜬금없이 RAM이 왜 등장했냐 하면…컴퓨터의 프로그램이 실행되려면 모두 RAM에 해당 소스가 존재해야한다.그 말은 RAM에 우리가 짠 자바스크립트 소스, 변수가 어딘가에 존재한다는 것이다.하지만 RAM은 Random Access Memory, 즉 랜덤하게 데이터가 들어가게 된다.var a = 2; 라고 해서 어디에 우리의 데이터가 들어가있는지 알지 못한다.var a = 2; 라고 하면 2라는 값이 저장된 메모리 주소가 어딘가 있을 거다.그 때 그 주소가 0x1234라고 가정했을 때 변수가 많다보니 모든 변수의 메모리 주소를 외우는 것은 불가능하다.따라서 해당 메모리 주소에 이름을 붙인 것이 바로 변수이다.마치 네이버의 ip 주소(125.209.222.141)를 다 외우지 못해 www.naver.com으로 치는 격이다.ip 주소가 메모리 주소고, 도메인 네임이 바로 변수라고 보면 될 것 같다. 변수의 초기화 과정이는 호이스팅과 묶어서 보면 좋을 것 같다.아래와 같은 코드가 있다고 치자.123456var a = 2;console.log(a); // 2console.log(b); // undefinedvar b = a;console.log(b); // 2console.log(c); // ReferenceError: c is not defined 호이스팅 때문에 위 코드는 아래와 같이 바뀌게 될 것이다.12var a;var b; 그럼 위 과정과 메모리를 엮어서 한 번 봐보자.a와 b는 메모리 주소에 이름을 붙인 것이고, 실제 데이터는 해당 메모리 주소에 저장이 된다. a b 0x1234 0x1235 0x1234 0x1235 123var a;var b;a = 2; 그리고 3번 라인에 의해 아래와 같이 바뀐다. a b 0x1234 0x1235 0x1234 0x1235 2 12345678var a;var b;a = 2;console.log(a); // 2console.log(b); // undefinedb = a;console.log(b); // 2console.log(c); // ReferenceError: c is not defined 그리고 6번 라인에 의해 아래와 같이 바뀐다. a b 0x1234 0x1235 0x1234 0x1235 2 2 원시값은 위와 같이 메모리의 새로운 영역에 값을 ‘복사’하는 형태로 가고 있다.그럼 참조 타입인 객체들을 어떻게 만들어지는지 한번 살펴보자. 123456var a = &#123; name: '양권성', friends: ['양간장', '간장냥'], age: 25&#125;;var b = a; 그럼 이제 위 데이터들을 하나씩 까보자.12var a;var b; 먼저 호이스팅에 의해 아래와 같이 메모리를 잡을 것이다. a b 0x1234 0x1235 0x1234 0x1235 1234567var a;var b;a = &#123; name: '양권성', friends: ['양간장', '간장냥'], age: 25&#125;; 그리고 3번에 의해 아래와 같이 바뀔 것이다. a b 0x1234 0x1235 0x1236 0x1237 0x1238 0x1239 0x1240 0x1234 0x1235 0x1236 { name: 0x1237, friends: 0x1238, age: 0x1239 } 양권성 0x1240 25 [‘양간장’, ‘간장냥’] 0x1236의 객체를 보면 name, friends, age라는 키에 해당하는 값들도 어딘가 메모리에 적재가 돼있을 것이다.그 메모리 주소에 대한 이름을 키라고 보면 될 것 같다.그리고 friends는 원시값이 아니고 참조값이기 때문에 해당 메모리 주소로 이동하면 또 메모리 주소가 있고,그 메모리 주소를 타고 가야 비로소 우리가 원하는 값이 있다.12345678var a;var b;a = &#123; name: '양권성', friends: ['양간장', '간장냥'], age: 25&#125;;b = a; 마지막 라인에 의해 아래와 같은 결과가 나오게 된다. a b 0x1234 0x1235 0x1236 0x1237 0x1238 0x1239 0x1240 0x1234 0x1235 0x1236 0x1236 { name: 0x1237, friends: 0x1238, age: 0x1239 } 양권성 0x1240 25 [‘양간장’, ‘간장냥’] 객체는 거의 무한한 데이터를 담을 수 있으므로 복사보다는 참조하는 것이 메모리를 더 절약하기 때문인지 객체를 참조 타입으로 지정한 것 같다.역시 이런 기초 기반 지식들이 상당히 중요한 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"변수","slug":"변수","permalink":"http://perfectacle.github.io/tags/변수/"}]},{"title":"(자알쓰) 자료형(객체)","slug":"js-010-data-type-object","date":"2017-07-01T04:14:58.000Z","updated":"2017-07-01T05:11:56.000Z","comments":true,"path":"2017/07/01/js-010-data-type-object/","link":"","permalink":"http://perfectacle.github.io/2017/07/01/js-010-data-type-object/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 번째 시리즈는 자료형 중에 객체를 주제로 진행하겠다. 자료형0과 1로 이루어진 데이터를 메모리에서 꺼내서 써야하는데 어떻게 해석할지를 결정하는 유형.나는 위와 같이 이해하고 있는데 잘 이해가 가지 않는다면 그냥 넘어가도 무방하다.더 딥하게 알고 싶은 사람은 정적 타입의 언어(C, Java 등등)을 공부해보자. 자바스크립트에서 자료형은 크게 두 가지로 나뉜다. 원시값 객체 하나 하나 파헤쳐보자. 객체(Object)객체는 다음과 같은 유형이 있다.이번 글에서는 해당 내용들은 다루지 않고, 객체의 특성에 대해서만 다루도록 하겠다. 객체 배열 함수 정규 표현식 날짜 컬렉션(ES6에서 생김) 기타 등등 그리고 이 객체에는 다음과 같은 특징이 있다. 변하는(Mutable) 값이다. 값으로써 비교하는 게 아니라 참조하는 주소로써 비교한다. typeof 연산자로 구분하기 어려운 경우가 많다. 프로퍼티의 추가가 가능하다. 12345678910111213141516171819var a = [1];var b = a;b.push(2);console.log(a); // [1, 2], 건드리지도 않은 a가 왜...?var c = &#123;&#125;;var d = &#123;&#125;;console.log(c === d); // false, 둘은 똑같은 값이 아닌가...?? console.log(typeof function()&#123;&#125;); // 'function'console.log(typeof &#123;&#125;); // 'object'console.log(typeof []); // 'object', 배열의 타입도 objectconsole.log(typeof /a/); // 'object', 정규 표현식의 타입도 objectconsole.log(typeof new Date()); // 'object', 날짜의 타입도 objectconsole.log(typeof new WeakSet()); // 'object', 컬렉션의 타입도 objectvar e = function()&#123;&#125;;e.asdf = 'qwer';console.log(e.asdf); // 'qwer', 함수도 객체이므로 프로퍼티의 추가가 가능하다. 참조 타입(Reference Type)1번과 2번의 특징과 같이 작동하는 이유는 객체는 참조 타입이기 때문이다.그럼 뭘 참조하느냐? 바로 메모리 주소를 말한다.기본적으로 우리가 작성한 프로그램(그 안에 존재하는 모든 소스 코드 및 변수 등등)은 메모리에 있어야한다.메모리는 8GB 등등 다양한 용량을 가지고 있고 그 안에 우리의 변수가 여기 저기 산재돼있는 구조이다.1234var a = 2;var b = a;var c = [1];var d = c; 이렇게 코드를 짰다고 하면 사실은 아래와 같다고 보면 된다.0x1234 와 같은 메모리 주소는 내가 임의로 지정한 것이다.절대로 저런 식으로 메모리가 생기지 않았고, 이해를 돕기 위해 쉽게 설명하고자 적은 거다. a b c d 0x1234 2 2 0x1234 0x1234 [1] 즉 변수 c와 d에 [1]이 직접 저장되는 게 아니라 배열은 객체이고, 객체는 참조 타입이므로 메모리의 주소가 각각 저장되는 것이다.메모리의 주소를 참조하는 형태가 바로 참조 타입니다. 그럼 아래와 같은 경우에 한 번 어떻게 값이 변하는지 보자.123var a = [1];var b = a;b.push(2); 2번 라인까지 하면 아래와 같을 것이다. a b 0x1234 0x1234 0x1234 [1] 3번 라인에 의해서 다음과 같이 바뀌게 되는 것이다. a b 0x1234 0x1234 0x1234 [1, 2] 즉 b가 참조하고 있는 녀석과 a가 참조하고 있는 녀석이 같으니 b를 통해 바꿔도 a가 참조하는 녀석이 바뀌게 되는 격이다.하지만 아래와 같이 재할당을 하면 얘기는 달라진다.123var a = [1];var b = a;b = [1, 2]; 2번 라인까지 하면 아래와 같을 것이다. a b 0x1234 0x1234 0x1234 [1] 3번 라인에 의해서 다음과 같이 바뀌게 되는 것이다. a b 0x1234 0x1235 0x1234 0x1235 [1] [1, 2] 새로 할당을 하게 되면 새로운 메모리 공간에 해당 값을 만들고, 해당 메모리 주소를 바라보게 만든다. 자료형 검출하기위 코드를 봤을 때 function을 제외하고 모든 객체가 object라는 문자열이 나왔다.그럼 각기 다른 데이터 타입들을 어떻게 구분할까?아래와 같이 하면 된다.123456console.log(&#123;&#125;.toString() === '[object Object]'); // true, 객체 검출 성공console.log(Array.isArray([])); // true, 배열 검출 성공console.log(Object.prototype.toString.call(/a/) === '[object RegExp]'); // true, 정규표현식 검출 성공console.log(Object.prototype.toString.call(new Date()) === '[object Date]'); // true, 날짜 검출 성공console.log(new Map().toString() === '[object Map]'); // true, 컬렉션 검출 성공console.log(Math.toString() === '[object Math]'); // true, 컬렉션 검출 성공 얕은 복사? 깊은 복사?그렇담 참조 타입의 데이터를 동일한 메모리 주소를 참조하는 게 아니라 복사해서 새로운 메모리 공간에 할당하고 지지고 볶고 싶다면…?이런 걸 위해 자바스크립트에서는 참조 데이터의 복사가 가능하다.ES5는 아래 링크를 참조하자.직접 구현해본 JS 객체, 배열의 깊은 복사하는 방법 얕은 복사(Shallow Copy)배열의 복사를 진행해보자.12345const a = [1, 2];const b = [...a];b.push(3);console.log(a); // [1, 2]console.log(b); // [1, 2, 3] 결과는 아래와 같다. a b 0x1234 0x1235 0x1234 0x1235 [1, 2] [1, 2, 3] 그럼 이번에는 객체를 복사해보자.12345678const a = &#123;name: '양권성'&#125;;// 객체에 spread 연산자를 쓸 수 있게 해주는 것은 Stage-3 단계이다. // https://github.com/tc39/proposal-object-rest-spread// 따라서 바벨의 stage-3 preset이나 transform-object-rest-spread 플러그인을 사용하면 된다.const b = &#123;...a&#125;;b.age = 25;console.log(a); // &#123;name: '양권성'&#125;console.log(b); // &#123;name: '양권성', age: 25&#125; 결과는 아래와 같다. a b 0x1234 0x1235 0x1234 0x1235 {name: ‘양권성’} {name: ‘양권성’, age: 25} 위의 데이터들을 참조 단계가 1단계 밖에 없었다.뎁스가 깊어진다면 어떻게 될까…?123456const a = [1, [2]];const b = [...a];b.push(4);b[1].push(3);console.log(a); // [1, [2, 3]]console.log(b); // [1, [2, 3], 4] 참조 데이터 안에 참조 데이터가 있는 격이다.메모리를 까보면 아래와 같을 것이다. a b 0x1234 0x1235 0x1236 0x1234 0x1236 [1, 0x1235] [2, 3] [1, 0x1235, 4] 즉 뎁스가 한 단계만 깊어져도 수박 겉핥기 식으로 껍데기만 복사가 되는 것이다.그 속 알맹이는 재귀적으로 계속 타고 타고 들어가서 복사를 해줘야한다.이는 객체도 마찬가지다. 깊은 복사(Deep Copy)위 방식대로 얕은 복사를 진행하면 참조 단계가 한 뎁스만 깊어져도 제대로 된 복사가 이루어지지 않는 것을 알았다.그렇다면 그 안에 참조 데이터가 있는지 없는지 계속해서 얕은 복사를 재귀적으로 진행해나가는 걸 깊은 복사라고 한다.그럼 직접 깊은 복사를 구현해보자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 혹시 추후에 Array나 Object의 표준 메소드로 clone이 생길지 모르니 심볼을 통해 유니크한 값을 만들어서 쓰자.const symClone = Symbol('clone');Array.prototype[symClone] = function() &#123; // 배열의 얕은 복사(Shallow Copy)를 한 번 함. let copy = [...this]; // map 메소드는 원본 배열을 훼손시키지 않으므로 반환된 값을 원본 배열에 할당. copy = copy.map(v =&gt; &#123; // 현재 배열의 요소가 배열 또는 객체라면 // 그것들을 다시 얕은 복사하는 재귀함수를 호출. if(Array.isArray(v) || v.toString() === '[object Object]') v = v[symClone](); // 리턴 값이 없다면 배열에 undefined가 들어가게 됨. return v; &#125;); return copy;&#125;;Object.prototype[symClone] = function() &#123; // 객체의 얕은 복사(Shallow Copy)를 한 번 함. let copy = &#123;...this&#125;; // 객체의 키 값들을 순회 for(const key of Object.keys(copy)) &#123; // 현재 배열의 요소가 배열 또는 객체라면 // 그것들을 다시 얕은 복사하는 재귀함수를 호출. if(Array.isArray(copy[key]) || copy[key].toString() === '[object Object]') copy[key] = copy[key][symClone](); &#125; return copy;&#125;;// 무지하게 참조 뎁스가 복잡한 객체.const obj = &#123; name: 'asdf', arr: [ // 객체 안에 배열 1, 2, 3, [ // 객체 안에 배열 안에 배열 4, 5, 6, &#123; // 객체 안에 배열 안에 배열 안에 객체 age: 999 &#125; ] ]&#125;;const objClone = obj[symClone]();objClone.arr[2] = 4;objClone.arr[3].unshift(2);objClone.arr[3][4].qwer = 'qwer';// &#123;// name: 'asdf',// arr: [ // 객체 안에 배열// 1, 2, 4, [ // 객체 안에 배열 안에 배열// 2, 4, 5, 6, &#123; // 객체 안에 배열 안에 배열 안에 객체// age: 999,// qwer: 'qwer'// &#125;// ]// ]// &#125;;console.log(objClone);// &#123; 원본 값은 전혀 바뀌지 않았다.// name: 'asdf',// arr: [ // 객체 안에 배열// 1, 2, 3, [ // 객체 안에 배열 안에 배열// 4, 5, 6, &#123; // 객체 안에 배열 안에 배열 안에 객체// age: 999// &#125;// ]// ]// &#125;;console.log(obj); symClone은 모든 참조 데이터를 순회하면서 재귀적으로 얕은 복사를 수행하는 함수이다.결국엔 모든 참조 데이터를 얕은 복사하면서 그 깊숙한 곳까지 타고 들어가기 때문에 깊은 복사라고 부르는 것이다.이것이야말로 진또배기 복사라고 할 수 있다.하지만 이런 깊은 복사는 계속해서 함수를 호출하는 재귀함수이므로 콜스택을 많이 만들어내는 등등의 문제로 인해 값비싼 비용을 치르게 된다.즉 느리다는 뜻이다. (체감 못하는 경우가 많을테지만)이를 위해 Immutable.js가 나오고 여기서는 Immutable 자료형인 List와 Map을 권장하는 바이다.좀 더 궁금한 사람은 Immutable.js 공식 사이트를 참고하도록 하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"자료형","slug":"자료형","permalink":"http://perfectacle.github.io/tags/자료형/"},{"name":"객체","slug":"객체","permalink":"http://perfectacle.github.io/tags/객체/"}]},{"title":"(자알쓰) 자료형(원시값)","slug":"js-009-data-type-primitive-value","date":"2017-07-01T00:53:29.000Z","updated":"2017-07-01T04:19:07.000Z","comments":true,"path":"2017/07/01/js-009-data-type-primitive-value/","link":"","permalink":"http://perfectacle.github.io/2017/07/01/js-009-data-type-primitive-value/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 아홉 번째 시리즈는 자료형 중에 원시값을 주제로 진행하겠다. 자료형0과 1로 이루어진 데이터를 메모리에서 꺼내서 써야하는데 어떻게 해석할지를 결정하는 유형.나는 위와 같이 이해하고 있는데 잘 이해가 가지 않는다면 그냥 넘어가도 무방하다.더 딥하게 알고 싶은 사람은 정적 타입의 언어(C, Java 등등)을 공부해보자. 자바스크립트에서 자료형은 크게 두 가지로 나뉜다. 원시값 객체 하나 하나 파헤쳐보자. 원시값(Primitive Value)원시값에는 6가지 유형이 있다. boolean number string null undefined Symbol(ES2015에서 새로 생김) 그리고 이 원시값에는 다음과 같은 특징이 있다. 불변(Immutable)하는 값이다. 값으로써 비교가 가능하다. (심볼을 제외하고) typeof 연산자를 쓰면 각자 고유한 타입을 내뱉는다. (typeof null을 제외하고) 너무나 당연한 소리를 하고 있어서 이게 무슨 특징인가 싶을 수 있다.하지만 다음 파트인 객체를 보고 나면 생각이 달라질 것이다.1234567891011121314151617181920212223242526// 불변하는 값이다.var a = 'a';var b = a;b = 'b';console.log(a, b); // 'a', 'b'// 값으로써 비교가 가능하다.console.log(false === !!0); // true// 하지만 항상 유니크한 값을 가지는 심볼은 값으로써 비교가 불가능하다.var c = Symbol('c');var d = Symbol('c');console.log(c === d); // false// Symbol.for는 심볼 레지스트리에 해당 키값의 심볼이 있다면 새로 만들지 않고 해당 값을 반환한다.var e = Symbol.for('c');var f = Symbol.for('c');console.log(e === f); // true// 모두 고유한 타입을 내뱉어서 타입을 구분짓기가 쉽다. console.log(typeof false); // 'boolean'console.log(typeof 123); // 'number'console.log(typeof '123'); // 'string'console.log(typeof null); // 'object', 버그이다. 상단의 링크를 참조하자.console.log(typeof undefined); // 'undefined'console.log(typeof Symbol()); // 'symbol' 부울(Boolean)참/거짓을 나타내는 자료형이다.주로 조건을 명시해야하는 경우에 많이 쓴다.123456789var a = 1;var b = 2;if(a &gt; b) &#123; // 1. 조건문 console.log(123);&#125;for(var i=0; i&lt;10; i++) &#123; // 2. 반복문의 조건부 부분 console.log(i); // 0~9까지 출력하게 된다.&#125;var c = (a%2 === 1) ? 1 : 2; // 2. 삼항 연산자 형변환을 위해서는 다음과 같은 방법이 존재한다.12345console.log(new Boolean('').valueOf()); // falseconsole.log(Boolean('')); // false// ! 연산자는 참을 거짓으로, 거짓을 참으로 바꿔주는 Not 연산자이다. // !으로 한 번 뒤집고 !으로 한번 더 뒤집어주면 원래의 참/거짓 값이 나오게 되는 원리다.console.log(!!''); // false, 가장 짧아서 쓰기 간편해서 자주 쓴다. Falsy/Truthy Valueboolean으로 형변환 했을 때 거짓으로 판명되는 값이 Falsy Value, 참으로 판명되는 값이 Truthy Value이다.아래의 경우를 제외하고 모두 Truthy Value이다.자바스크립트의 유연한 동적 타입의 특성이 여기서 드러나는 것 같다.123456789101112console.log(!!0); // false, 숫자 0console.log(!!undefined); // false, undefinedconsole.log(!!null); // false, nullconsole.log(!!false); // false, boolean의 falseconsole.log(!!''); // false, 빈 문자열(공백 아님, 쌍따옴표 아님)console.log(!!NaN); // false, 숫자 NaN(Not a Number)// 위 경우를 제외하고 모두 Truthy Valueconsole.log(!!12341234); // true, 0을 제외한 숫자console.log(!!' '); // true, 공백이라도 true로 인식console.log(!!&#123;&#125;); // true, 빈 개체라도 true로 인식console.log(!![]); // true 빈 배열이라도 true로 인식 문자열(String)다른 프로그래밍 언어에서 문자열은 기본 자료형에 속하지 않는다.C에서는 문자의 배열로 문자열을 다루며, 자바에서는 클래스로 다루고 있는데 자바스크립트에서는 기본 자료형에 속해있다.C에서 문자의 배열이라고 말하듯이 자바스크립트에서도 배열과 같이 사용이 가능하다.12345678910111213141516171819// 쌍따옴표, 홑따옴표 개인의 기호에 맞게, 혹은 코딩 컨벤션에 맞게 사용하면 된다.var url = 'https://perfectacle.github.io/';// HTML 템플릿을 바인딩 할 때 HTML 템플릿은 쌍따옴표를 사용하므로 홑따옴표 사용을 주장하는 입장도 있다.var a = '&lt;a href=\"' + url + '\" target=\"_blank\"&gt;짱짱맨의 블로그&lt;/a&gt;';var b = \"&lt;a href=\\\"\" + url + \"\\\" target=\\\"_blank\\\"&gt;짱짱맨의 블로그&lt;/a&gt;\";// 또한 ES6 들어선 템플릿 리터럴 ``이 등장했기 때문에 이와 구별을 위해 쌍따옴표 사용을 주장하는 입장도 있다.var c = `&lt;a href=\"$&#123;url&#125;\" target=\"_blank\"&gt;짱짱맨의 블로그&lt;/a&gt;`;// 배열과 같이 인덱스로 접근이 가능하다.console.log(url[11], url[0], url[20]); // f h g// 덧셈 연산자를 쓰면 문자열이 아닌 것을 문자열로 바꾼 후 문자열끼리 합쳐준다. // 연산 순서가 매우 중요하므로 먼저 계산해주고 싶은 내용을 앞에 배치하던가 괄호로 묶어 우선순위를 높여줘야한다.var e = '10';console.log(e + 2 + 1); // '1021', '10' + '2' + 1 = '102' + '1'console.log(2 + e + 1); // '2101', '2' + '10' + 1 = '210' + '1'console.log(2 + 1 + e); // '310', 2 + 1 + '10' = '3' + '10' 형변환은 다음과 같이 할 수 있다.123console.log(new String(123).valueOf()); // '123'console.log(String(false)); // 'false'console.log(''+false); // 'false', 가장 간결해서 자주 쓰는 방법이다. Null값이 없음을 나타내기 위한 자료형이다.어떤 사람은 이 null을 할당해주는 작업이 해당 변수를 쓸 준비가 되었다는 것과 같다고 한다.또한 null은 어떠한 프로퍼티나 메소드의 사용도 불가능하다.123var a = null;a += ''; // 'null'console.log(null.valueOf()); // Cannot read property 'valueOf' of null Undefined값이 정의되지 않음을 나타내기 위한 자료형이다.null은 값이 정의 됐다, 변수에 할당된 상태이나 undefined는 값이 할당되지 않은 상태이다.undefined도 null과 마찬가지로 어떠한 프로퍼티나 메소드의 사용도 불가능하다.12345678var a;console.log(a); // undefinedvar b = 'asd';console.log(b[3]); // undefined// 자바스크립트는 요상하게도 초기화되지 않은 변수에 연산자를 써도 오류가 나질 않는다.// 최대한 프로그램이 죽지 않도록 설계한 것 같다.a += ''; // 'undefined'console.log(b[4].valueOf()); // Cannot read property 'valueOf' of undefined 분량이 길어졌으니 한 번 끊고 그 다음 자료형인 객체에 대해서 공부해보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"자료형","slug":"자료형","permalink":"http://perfectacle.github.io/tags/자료형/"},{"name":"원시값","slug":"원시값","permalink":"http://perfectacle.github.io/tags/원시값/"}]},{"title":"(함수형 JS) 함수형 프로그래밍(JS)이란...?","slug":"js-func-00-what","date":"2017-06-30T12:33:47.000Z","updated":"2017-07-01T04:16:17.000Z","comments":true,"path":"2017/06/30/js-func-00-what/","link":"","permalink":"http://perfectacle.github.io/2017/06/30/js-func-00-what/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? 목차포스트와는 무관하며 내가 정리한 함수형 JS의 포스트 목록이다. 왜 쓸까? filter map each reduce find curry pipe 함수형 JS?간단하게 생긴 모습을 보면 다음과 같다.123456// 객체 지향형[1, 2, 3].filter(v =&gt; v%2);// 함수형const filter = () =&gt; &#123;&#125;; // 구현했다고 가정.filter([1, 2, 3], v =&gt; v%2); 모두 다 그런 건 아니지만 대체적으로뭔가 .을 찍고 찍고 들어간다고 하면 그건 객체 지향형(객체에 존재하는 메소드나 프로퍼티 등등을 사용)그냥 함수로 시작해서 그 안에서 함수 쓰고 쓰고 뭐시기 지지고 볶고 하다가 함수로 끝나면 함수형이라고 보면 될 것 같다. 순수 함수?함수형 프로그래밍을 접하다 보면 순수 함수란 것을 많이 보게 된다.이는 객체 지향형에서 쓰이던 메소드와는 매우 다르다.1234567891011// 객체 지향형const arr = [1, 2, 3];arr.push(4);console.log(arr); // [1, 2, 3, 4]// 함수형const arr2 = [1, 2, 3];const push = () =&gt; &#123;&#125;; // 구현했다고 가정.const newArr = push(arr2, 4);console.log(arr); // [1, 2, 3];console.log(newArr); // [1, 2, 3, 4]; 객체 지향형(arr.push(4))이 어떻게 동작을 했는지 보면 다음과 같다. arr에 4라는 데이터를 제일 끝에 넣었다. arr은 push 메소드의 입력값이 아닌데 메소드 내부에서 사용을 하였다. push 메소드가 메소드 외부의 데이터를 손 댄 것이다. 사이드 이펙트(부수 효과)를 발생 시켰다. 물론 위와 같은 코드는 너무 간단해서 개발자가 당연히 사이드 이펙트를 기대하고 짠 코드이다.객체 지향형은 기본적으로 사이드 이펙트를 기대하고 개발하게 된다.따라서 실행 시점에 따라 출력값이 다르다.즉 평가 시점을 어느 한 시점으로 한정 지을 수 밖에 없다. 그럼 함수형 코드(push(arr2, 4))를 한 번 보자. arr2를 복사하여 그 뒤에 4를 넣었다. push 함수의 입력값에 arr2가 있고, 그 입력값을 가지고만 함수가 실행되었다. push 메소드가 메소드 외부의 데이터에 손을 대지 않았다. 사이드 이펙트가 발생하지 않았다. 타입스크립트에서 any가 적폐 세력이라면, 함수형 프로그래밍에서는 사이드 이펙트가 적폐 세력인 것 같다.사이드 이펙트가 없기 때문에 동일한 입력값을 넣으면 언제나 동일한 출력값이 나온다.따라서 언제 실행하던 동일한 출력값이 나오기 때문에 평가 시점으로부터 자유롭다.바로 이런 게 순수 함수다. (사이드 이펙트가 없다는 게 핵심)그렇다고 사이드 이펙트가 있는 함수를 불순 함수라고는 부르지 않는다. 수학 시간에 배웠던 바로 그 함수다.f(x)는 언제나 y이다.10년 후에 실행하던 100년 후에 실행하던 f(x)는 언제나 y이다.하지만 객체 지향 개념의 함수(메소드)는 너무나 많은 사이드 이펙트로 둘러쌓여 있어서 실행할 때 마다 동일한 결과를 보장할 수 없다. 일급 함수? 일급 객체? 일급 시민?아래 링크를 베꼈다.참고하였다.JavaScript의 함수는 1급 객체(first class object)이다 일급 시민(first class citizen) 변수(variable)에 담을 수 있다. 매개변수(parameter)로 전달할 수 있다. 반환값(return value)으로 전달할 수 있다. 즉, 우리가 생각하는 값으로써 역할을 하는 것을 일급 시민이라고 말하는 것 같다. 일급 객체(first class object)특정 언어에서 객체를 일급 시민으로써 다룰 수 있느냐를 뜻한다.자바스크립트에서 객체는 위 조건을 만족하는 일급 시민이므로 일급 객체이다.1234const obj = &#123;name: '양권성', age: 25&#125;; // 1. 변수(variable)에 담을 수 있다.const fn = obj =&gt; &#123; // 2. 매개변수(parameter)로 전달할 수 있다. return obj; // 3. 반환값(return value)으로 전달할 수 있다.&#125; 일급 함수(first class function)특정 언어에서 함수를 일급 시민으로써 다룰 수 있느냐를 뜻한다.자바스크립트에서 함수는 위 조건을 만족하는 일급 시민이므로 일급 함수이다.또 일급 시민에 더해서 일급 함수는 다음과 같은 조건까지 있어야한다고 주장하기도 한다. 런타임(runtime) 생성이 가능하다. 익명(anonymous)으로 생성이 가능하다. 1234567const fn = () =&gt; &#123;&#125;; // 1. 변수(variable)에 담을 수 있다.const _fn = fn =&gt; &#123; // 2. 매개변수(parameter)로 전달할 수 있다. return fn; // 3. 반환값(return value)으로 전달할 수 있다.&#125;;function a() &#123;&#125; // 함수 선언식은 스크립트 로딩 시점에 VO(Variable Object)에 저장됨.const b = () =&gt; &#123;&#125;; // 4. 함수 표현식은 런타임 시에 해석 및 실행이 된다. const c = () =&gt; () =&gt; &#123;&#125;; // 5. 익명으로 생성이 가능하다. VO와 함수 표현식 및 선언식에 대한 내용은 아래 사이트를 참고하자. Variable Object in JS Javascript : 함수(function) 다시 보기 하지만 자바스크립트에서 함수는 객체이다.123const a = () =&gt; &#123;&#125;;a.b = 123; // 객체와 같이 프로퍼티 추가가 가능하다.console.log(a.b); // 123 따라서 자바스크립트에서 함수는 일급 객체라고 주장도 하지만 나는 일급 함수가 좀 더 정확한 것 같다. (더 많은 조건을 충족하므로)뭐 자바스크립트에서 함수가 일급 시민이건 객체건 함수건 뭐가 중요한 지는 다음 고차 함수를 통해 알 수 있다. 고차 함수?함수형 프로그래밍을 접하다 보면 고차 함수란 것을 많이 보게 된다.뭔가 고차원적인 함수일 것 같은데 전혀 아니다.바로 다음과 같은 걸 고차 함수라고 말한다. 함수의 인자로 함수를 받는 경우 함수의 출력값이 함수인 경우 함수의 인자로 함수를 받으면서 출력값이 함수인 경우 (1+2번의 경우) 123const fn = fn =&gt; fn(); // 1. 함수의 인자로 함수를 받는 경우const fn2 = a =&gt; b =&gt; b; // 2. 함수의 출력값이 함수인 경우const fn3 = fn =&gt; fn; // 함수의 인자로 함수를 받으면서 출력값이 함수인 경우 함수형 프로그래밍의 장점은 여러가지 로직들을 추상화할 수 있는데,매개변수로 함수를 넘기기 때문이다.또 그 출력값으로 얻어낸 함수를 실행해서 여러 코드와 조합을 할 수 있다. 내가 아는 한도 내에서 틀렸을지 모르겠지만 함수형 자바스크립트에 대한 것은 다 적은 것 같으니 이제 목차를 보고 하나씩 터득해보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"(함수형 JS) pipe","slug":"js-func-08-pipe","date":"2017-06-30T12:30:56.000Z","updated":"2017-07-01T09:37:55.000Z","comments":true,"path":"2017/06/30/js-func-08-pipe/","link":"","permalink":"http://perfectacle.github.io/2017/06/30/js-func-08-pipe/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? pipe다음과 같은 함수를 작성해보자. [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]이란 배열을 만든다. 이 배열의 각 요소들을 x3한 배열을 구한다. x3한 배열에서 2의 배수만 추려내서 새로 배열을 구한다. 2의 배수들만 모아놓은 각 요소들을 합한 결과를 구하자. 함수형에 충실한 우리는 아래와 같이 짜게될 것이다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const _each = (list, iteratee) =&gt; &#123; if(list.toString() === '[object Object]') &#123; const objValList = []; for(const key of Object.keys(list)) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;const _filter = (list, predicate) =&gt; &#123; const newList = []; _each(list, item =&gt; predicate(item) &amp;&amp; newList.push(item)); return newList;&#125;;const _map = (list, iteratee) =&gt; &#123; const newList = []; _each(list, item =&gt; newList.push(iteratee(item))); return newList;&#125;;const _head = list =&gt; list.toString() === '[object Object]' ? Object.keys(list)[0] : list[0];const _tail = list =&gt; ( list.toString() === '[object Object]' ? Object.keys(list).slice(1) : list.slice ? list.slice(1) : Array.from(list).slice(1));const _reduce = (list, iteratee, memo) =&gt; &#123; if(memo === undefined) &#123; memo = _head(list); list = _tail(list); &#125; _each(list, item =&gt; memo = iteratee(item, memo)); return memo;&#125;;// 1번, 배열 만들기const nums = [];for(let i=1; i&lt;=10; i++) nums.push(i);console.log(nums); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]// 2번, x3한 배열 구하기.const mul3Nums = _map(nums, num =&gt; num*3);console.log(mul3Nums); // [ 3, 6, 9, 12, 15, 18, 21, 24, 27, 30 ]// 3번, 2의 배수 구하기.const getEven = _filter(mul3Nums, num =&gt; !(num%2));console.log(getEven); // [ 6, 12, 18, 24, 30 ]// 4번, 2의 배수들만 구한 배열의 합을 구하기.const sumEven = _reduce(getEven, (num, memo) =&gt; memo+num);console.log(sumEven); // 90 함수형에 더 충실한 사람은 아래와 같이 시도를 해봤을 것이다.123456789101112// 1번, 배열 만들기const nums = [];for(let i=1; i&lt;=10; i++) nums.push(i);console.log(nums); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]console.log( _reduce( // 4번, 2의 배수들만 구한 배열의 합을 구하기. _filter( // 3번, 2의 배수 구하기. _map(nums, num =&gt; num*3), num =&gt; !(num%2) // 2번, x3한 배열 구하기. ) , (num, memo) =&gt; memo+num)); // 90 소스를 거꾸로 읽어나가야하고, 마치 콜백 함수 지옥에 빠진 듯한 기분이 든다.이러한 콜백 함수 지옥을 헤쳐나가기 위해 나온 것이 pipe이다.마치 비동기 함수에서 콜백 함수 지옥을 탈출하기 위해 프로미스가 나온 것과 비슷해보인다.역시 콜백 함수가 문제다. 우리가 인자로 넘긴 함수를 하나 하나 순차적으로 실행할 수 있게 해주는 pipe 함수를 만들어보자.머리를 굴려도 생각이 나지 않아 아래 링크를 베껴참조 하였다.(함수형JS) 흐름 기반 프로그래밍최종 결과는 아래와 같을 것이다.1234567891011const nums = [];for(let i=1; i&lt;=10; i++) nums.push(i);// 함수 목록들을 리듀스 돌려버린다.const _pipe = (...fn) =&gt; _reduce(fn, (fn, memo) =&gt; fn(memo));console.log(_pipe( _map(nums, num =&gt; num*3), // 첫 번째 memo에 결과값이 담겨서 mul3Nums로 다음 함수에게 넘겨지고 있다. mul3Nums =&gt; _filter(mul3Nums, num =&gt; !(num%2)), // 두 번째 memo에 결과값이 담겨서 getEven으로 다음 함수에게 넘겨지고 있다. getEven =&gt; _reduce(getEven, (num, memo) =&gt; memo+num))); // 세 번째 memo에 결과값이 담겨서 로그 창에 찍힌다. // 이렇게 괄호를 쫙쫙쫙 닫아주는 게 함수형 프로그래밍 언어의 컨벤션이며 간지다. 역시 얕게 공부하다보니 간단하게 함수 만들고 예제 만들고 끝나는 것 같다.이제는 세미나 때 들었던 기억이 고갈되는 기분이라 좀 더 공부를 해야할 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"(함수형 JS) curry","slug":"js-func-07-curry","date":"2017-06-30T11:37:22.000Z","updated":"2017-06-30T12:33:29.000Z","comments":true,"path":"2017/06/30/js-func-07-curry/","link":"","permalink":"http://perfectacle.github.io/2017/06/30/js-func-07-curry/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? curry카레와 컬링과는 아무런 관련이 없다.백문이 불여일견, 간단한 예제를 하나 보자.123456789101112131415161718192021222324252627282930// 기존 방식const add = (a,b) =&gt; a+b;const sub = (a,b) =&gt; a-b;console.log(add(10, 10)); // 20console.log(add(10, 20)); // 30console.log(add(10, 30)); // 40console.log(add(10, 40)); // 50console.log(sub(10, 1)); // 9console.log(sub(10, 2)); // 8console.log(sub(10, 3)); // 7console.log(sub(10, 4)); // 6// 기존 방식의 함수를 커링을 이용하여 구성.const _add = a =&gt; b =&gt; a+b;const _sub = a =&gt; b =&gt; a-b;const add10 = _add(10);const sub10 = _sub(10);console.log(add10(10)); // 20console.log(add10(20)); // 30console.log(add10(30)); // 40console.log(add10(40)); // 50console.log(sub10(1)); // 9console.log(sub10(2)); // 8console.log(sub10(3)); // 7console.log(sub10(4)); // 6 기존에 n개의 인자를 받던 방식 대신 함수를 n번 호출하는 함수가 curry 함수, 그러한 기법을 currying이라 부른다.b =&gt; a+b 이 부분은 클로저이다.클로저는 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수, 생성 당시의 스코프에 대한 연결을 갖는 블록이라고 정리하고 있다.ES6는 블록 단위의 스코프라 b =&gt; a+b 에서 a는 모르지만 생명 주기가 끝난 외부 함수 a =&gt; b =&gt; a+b에서 a를 참조하고 있으므로 클로저이다.이런 걸 어디다 써먹느냐고 생각할 수 있는데 나중에 go나 pipe, 또한 우리가 작성했던 함수와도 엮어서 사용이 가능하다.위 _add와 _sub는 로직이 비슷해서 추상화가 가능하다. 12345678910111213const _curry = (a, fn) =&gt; b =&gt; fn(a, b);const add10 = _curry(10, (a, b) =&gt; a+b);const sub10 = _curry(10, (a, b) =&gt; a-b);console.log(add10(10)); // 20console.log(add10(20)); // 30console.log(add10(30)); // 40console.log(add10(40)); // 50console.log(sub10(1)); // 9console.log(sub10(2)); // 8console.log(sub10(3)); // 7console.log(sub10(4)); // 6 뭔가 추상화가 잘 된 것 같다, 인자가 두 개인 경우만…그럼 인자가 세 개인 경우에는 인자가 세 개인 커리 함수를 만들 것인가…?n개의 인자에 대해 대비할 수 있는 커리 함수를 다시 만들어보자.아래 링크를 보고 완전히 베낀 수준이며 ES6로 작성했을 뿐이다.아래 링크를 참고하면 좀 더 자세하고 ES5로 작성된 예제를 볼 수 있다.JavaScript에서 커링 currying 함수 작성하기 클로저는 함수가 아무리 호출되어도 다시 초기화 하지 않고, 유지되어야하는 값을 위해 쓴다고 나는 알고 있다.(혹시 틀렸다면 태클을…)기존 함수를 커리 함수로 호출할 때 유지해야할 값이 두 가지가 있다. 내가 호출하려는 원래 함수가 몇 개의 인자를 요구하는가 내가 지금까지 몇 개의 인자를 넘겼는가 이 두 가지 값은 함수를 아무리 호출해도 유지를 하고 있어야한다.그럼 커리 함수를 본격적으로 작성해보자. 내가 호출하려는 원래 함수가 몇 개의 인자를 요구하는가 12345const _curry = fn =&gt; &#123; // fnArgLen은 함수를 호출할 때 마다 유지돼야하고, 값이 변하지 않는다. const fnArgLen = fn.length; // 인자로 받은 함수(fn)에서 요구하는 인자의 갯수. return () =&gt; console.log(fnArgLen); // 외부 스코프의 변수인 fnArgLen을 사용하고 있다.&#125;; 간단하게 테스트를 위해 함수의 인자를 유지하고 있는지 테스트하기 위한 함수를 만들어보았다.아래와 같이 테스트 해보자.12_curry((a, b, c) =&gt; &#123;&#125;)(); // 3_curry((a, b, c, d, e) =&gt; &#123;&#125;)(); // 5 _curry 함수는 함수를 반환하는 고차함수다.따라서 ()()와 같이 함수를 호출해서 반환한 값을 또 호출할 수 있는 것이다.그 결과 우리가 두 번째 함수에는 딱히 인자를 넘기지 않았음에도 불구하고 그 값을 기억하고 있는클로저를 만들어냈다. (클로저가 뭐 그렇게 별 게 아니다.) 내가 지금까지 몇 개의 인자를 넘겼는가이 값은 함수를 호출할 때마다 값이 변해야한다.그렇다고 해서 처음부터 초기화를 하는 게 아니라 기존의 값을 기억하고 그 뒤에 현재 넘긴 인자를 추가하면 된다.값이 계속해서 동일하지 않더라도 값을 기억하고 있어야하기 때문에 클로저를 써야한다.위 함수에서 좀 더 작성해보자. 1234567891011121314151617181920212223242526const _curry = fn =&gt; &#123; // fnArgLen은 함수를 호출할 때 마다 유지돼야하고, 값이 변하지 않는다. const fnArgLen = fn.length; // 인자로 받은 함수(fn)에서 요구하는 인자의 갯수. console.log(fnArgLen); return (...args) =&gt; &#123; // 함수의 인자의 갯수를 기억하는 클로저 // 인자를 넘겼을 때 그 인자들의 목록은 매번 함수를 호출할 때마다 기억해야함. let memo = [...args]; // 처음 인자를 넘기고 호출했을 때 그 인자를 담을 배열. console.log(fnArgLen, memo); return function res(...args) &#123; // 여태까지 넘긴 인자들을 기억하는 클로저, 재호출을 위해 이름을 붙여줌. memo = [...memo, ...args]; console.log(fnArgLen, memo); return res; &#125; &#125;&#125;;const abcdef = (a, b, c, d, e, f) =&gt; &#123;&#125;;let a = _curry(abcdef); // 6let b = a(1); // 6, [1]let c = b(2); // 6, [1, 2]let d = c(3); // 6, [1, 2, 3]let e = d(4); // 6, [1, 2, 3, 4]let f = e(5); // 6, [1, 2, 3, 4, 5]let g = f(6); // 6, [1, 2, 3, 4, 5, 6]let h = g(7); // 6, [1, 2, 3, 4, 5, 6, 7]h(8); // 6, [1, 2, 3, 4, 5, 6, 7, 8] 함수를 계속 호출해도 원래 함수 인자의 갯수와 내가 여태까지 넘겼던 인자를 계속해서 들고있다.여기서 한가지 문제점이 존재한다.내가 원래 넘기려는 인자와 갯수가 일치하면 해당 함수를 실행해야하는데 여전히 계속해서 res 함수를 반환한다는 단점이 존재한다.적절히 조건문을 섞어주면 될 것 같다. 1234567891011121314151617181920212223242526272829const _curry = fn =&gt; &#123; // fnArgLen은 함수를 호출할 때 마다 유지돼야하고, 값이 변하지 않는다. const fnArgLen = fn.length; // 인자로 받은 함수(fn)에서 요구하는 인자의 갯수. console.log(fnArgLen); return (...args) =&gt; &#123; // 함수의 인자의 갯수를 기억하는 클로저 // 인자를 넘겼을 때 그 인자들의 목록은 매번 함수를 호출할 때마다 기억해야함. let memo = [...args]; // 처음 인자를 넘기고 호출했을 때 그 인자를 담을 배열. console.log(fnArgLen, memo); return function res(...args) &#123; // 여태까지 넘긴 인자들을 기억하는 클로저, 재호출을 위해 이름을 붙여줌. memo = [...memo, ...args]; console.log(fnArgLen, memo); // 인자의 갯수를 충분히 받았다면 원래 실행하려고 했던 함수를 실행한 결과를 반환, 그게 아니면 계속해서 인자를 누적시키는 res 함수를 반환. // fnArgLen과 같은 스코프에 공존하는 fn이라는 매개변수도 클로저 때문에 살아있기 때문에 사용이 가능하다. return memo.length &gt;= fnArgLen ? fn.apply(null, memo) : res; &#125; &#125;&#125;;const add = (a, b, c, d, e, f) =&gt; a + b + c + d + e + f;let a = _curry(add); // 6let b = a(1); // 6, [1]let c = b(2); // 6, [1, 2]let d = c(3); // 6, [1, 2, 3]let e = d(4); // 6, [1, 2, 3, 4]let f = e(5); // 6, [1, 2, 3, 4, 5]let g = f(6); // 6, [1, 2, 3, 4, 5, 6]console.log(g); // 21console.log(add(1, 2, 3, 4, 5, 6)); // 21let h = g(7); // TypeError: g is not a function Function.prototype.apply은 첫 번째 인자로 this로 바인딩할 값, 두 번째 인자로 매개변수들을 배열로 받는다.여태까지 입력받은 인자를 (1, 2, 3, 4)의 형태로 넘기는 게 가능한지는 모르겠으나(Function.prototype.call이 이런 식으로 동작)그것보다 매개변수를 배열로 ([1, 2, 3, 4])와 같이 넘기는 게 훨씬 편하다.우리가 원하는 형태로 n개의 매개변수를 넘기면 n번 호출해야 함수가 비로소 실행(지연해서 실행이라고 해야하려나)되는 커리 함수를 만들었다. curryr하지만 이것도 쓰다보면 어딘가 모르게 어색한 부분이 존재한다. 12345678const add = (a, b) =&gt; a + b;const sub = (a, b) =&gt; a - b;const _add = _curry(add);const _sub = _curry(sub);const add10 = _add(10)const sub10 = _sub(10);console.log(add10(3)); // 13console.log(sub10(3)); // 7 add를 할 때는 3에 10을 더해서 13이 나오는 듯한 느낌인데sub를 할 때는 3에 10을 빼서 -7이 나와야할 것 같은데 반대로 10에 3을 빼서 7이 나왔다.덧셈이야 순서가 상관이 없다지만 뺄셈의 경우에는 이야기가 달라진다.따라서 아래와 같이 하면 문제가 해결된다.1234const sub = (a, b) =&gt; b - a;const _sub = _curry(sub);const sub10 = _sub(10);console.log(sub10(3)); // -7 음… 함수를 커리에게 넘겨줄 때 반대로 쓰면 되는 문제인데…어쨌든 curryr(curry reverse)이라는 녀석이 존재한다.어떤 이유에서 생기긴 했을 거다. 그냥 보자.123456789101112131415161718const _curryr = fn =&gt; &#123; // fnArgLen은 함수를 호출할 때 마다 유지돼야하고, 값이 변하지 않는다. const fnArgLen = fn.length; // 인자로 받은 함수(fn)에서 요구하는 인자의 갯수. return (...args) =&gt; &#123; // 함수의 인자의 갯수를 기억하는 클로저 // 인자를 넘겼을 때 그 인자들의 목록은 매번 함수를 호출할 때마다 기억해야함. let memo = [...args]; // 처음 인자를 넘기고 호출했을 때 그 인자를 담을 배열. return function res(...args) &#123; // 여태까지 넘긴 인자들을 기억하는 클로저, 재호출을 위해 이름을 붙여줌. memo = [...memo, ...args]; // curry reverse이기 때문에 매개변수도 뒤집어서 실행해주면 된다. return memo.length &gt;= fnArgLen ? fn.apply(null, memo.reverse()) : res; &#125; &#125;&#125;;const sub = (a, b) =&gt; a - b;const _sub = _curryr(sub);const sub10 = _sub(10);console.log(sub10(3)); // -7 짱구를 굴려봤지만 _curry를 이용해서 추상화 할 수가 없었다 ㅠㅠ…아마 이 curryr의 진가는 pipe와 go를 익히면 알게 될 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"(함수형 JS) find","slug":"js-func-06-find","date":"2017-06-27T15:54:16.000Z","updated":"2017-06-30T12:33:29.000Z","comments":true,"path":"2017/06/28/js-func-06-find/","link":"","permalink":"http://perfectacle.github.io/2017/06/28/js-func-06-find/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? findfind는 두 말 하면 입 아프겠지만, 기존 데이터 사이에서 원하는 것을 찾을 때 사용한다.아래 예제를 보자.1234567891011121314151617const nums = [1, 3, 5, 7, 100];let no = 0;for(const num of nums) &#123; if(!(num % 2)) &#123; // 짝수인지 no = num; break; &#125;&#125;const users = [ &#123;name: 'asdf', age: 12&#125;, &#123;name: 'qwer', age: 33&#125;];let name = ''; let over30 = null;for(const user of users) if(user.age &gt; 30) return over30 = user;console.log(no); // 100console.log(over30.age ); // 33 위 코드를 보면 일단 반복문이 반복해서 쓰이고 있고, 뭘 구할지도 반복되고 있다.이 부분들을 추상화해보자.12345678910111213141516const _find = (list, predicate) =&gt; &#123; for(const item of list) if(predicate(item)) return item; // 새로운 변수를 만들어서 거기다 값을 담고 리턴하려니 추상화를 해도 오히려 코드가 길어져서 복잡해보인다. //let match; //_each(list, item =&gt; &#123; // if(predicate(item)) match = item; //&#125;); //return match&#125;;const nums = [1, 3, 5, 7, 100];const users = [ &#123;name: 'asdf', age: 12&#125;, &#123;name: 'qwer', age: 33&#125;];console.log(_find(nums, num =&gt; !(num % 2))); // 100console.log(_find(users, user =&gt; user.age &gt;= 30).age); // 33 findIndex이렇게 배열(과 ArrayLike)을 넘겨서 그 요소 중에서 내가 원하는 조건을 추상화시킨 _find를 써서 원하는 값을 얻어낼 수 있다.그럼 이 요소들이 몇 번째에 있는지 구하는 _findIndex도 만들어보자.기본적으로 순서가 없는, 인덱스로 접근이 불가능한 객체는 무시하고 만들도록 하겠다.123456789const nums = [1, 3, 100, 2, 7];let idx = -1; for(let i=0, len=nums.length; i&lt;len; i++) &#123; if(nums[i] &gt;= 100) &#123; idx = i; break; &#125;&#125;console.log(idx); // 2 새 리스트를 만들어서 그 리스트에 할당하는 부분은 없으니 반복문은 추상화시키지 못할 것 같다.또한 인덱스를 반환해야하니 for of 구문은 쓰지 못할 것 같다.추상화시킬 건덕지는 조건문 밖에 없어보인다.12345678910111213const _findIndex = (list, predicate) =&gt; &#123; for(let i=0, len=list.length; i&lt;len; i++) if(predicate(list[i])) return i; return -1; // 새로운 변수를 만들어서 거기다 값을 담고 리턴하려니 추상화를 해도 오히려 코드가 길어져서 복잡해보인다. //let idx = -1; //_each(list, item =&gt; &#123; // _each는 인덱스를 리턴하는 게 아니라 매칭된 값을 리턴하기 때문에 추상화 불가. // if(predicate(item)) idx = item; //&#125;); //return idx;&#125;;const nums = [1, 3, 100, 2, 7];console.log(_findIndex(nums, num =&gt; num &gt;= 100)); // 2 왜 -1을 리턴하는지 모르겠는 사람은 ~(Tilde) 연산자를 참고하자. somesome은 하나라도 조건을 만족하면 true를 반환하는 함수다.||(or)의 특성을 지닌다고 보면 될 것 같다.바로 어떤 녀석이 some인지 보자.1234567891011121314let nums = [1, 3, 100, 2, 7];let no3 = false;for(const num of nums) if(!(num % 3)) &#123; // 3의 배수라면 no3 = true; break;&#125;console.log(no3); // truenums = [3, 6, 20, 9];no3 = false;for(const num of nums) if(!(num % 3)) &#123; // 3의 배수라면 no3 = true; break;&#125;console.log(no3); // false 조건문 부분만 추상화가 가능해보인다.바로 구현해보자.12345678const _some = (list, predicate) =&gt; &#123; for(const item of list) if(predicate(item)) return true; return false;&#125;;let nums = [1, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // truenums = [4, 8, 16, 20];console.log(_some(nums, num =&gt; !(num % 3))); // false 위 함수를 보면 find에서 return 구문만 바뀐 걸 볼 수 있다.find 함수와 조합을 해보면 더 추상화 할 수 있을 것 같다.1234567const _some = (list, predicate) =&gt; ( !!_find(list, item =&gt; predicate(item)));let nums = [1, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // truenums = [0, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // flase 0은 3으로 나눴을 때 0이므로 조건식을 만족해서 find 함수로 0을 땡겨온다.하지만 0은 falsy value이므로 거짓이 나온다.따라서 find의 반환값으로 falsy value를 의도적으로 검출해낼 수도 있으므로 위와 같이 _find로는 추상화하지 못한다. 123456789101112const _findIndex = (list, predicate) =&gt; &#123; for(let i=0, len=list.length; i&lt;len; i++) if(predicate(list[i])) return i; return -1;&#125;;const _some = (list, predicate) =&gt; _findIndex(list, item =&gt; predicate(item)) !== -1;// 비트단위의 논리 연산자(Not)인 ~(Tilde)를 쓰면 다음과 같이 할 수 있다.// const _some = (list, predicate) =&gt; !!~_findIndex(list, item =&gt; predicate(item));let nums = [1, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // truenums = [0, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // true _find는 조건을 만족하는 값이면 어떤 값이든 땡겨올 수 있고 falsy value는 물론,심지어 undefined도 땡겨올 수 있으므로 boolean으로 캐스팅해도 올바른 결과를 얻어낼 수 없다._findIndex는 -1만 아니면 참인 것이기 때문에 -1에 대해서만 대비하면 되므로 추상화하기에 적당하다. everyevery는 하나라도 조건을 만족하지 않으면 false를 반환하는 함수다.&amp;&amp;(and)의 특성을 지닌다고 보면 될 것 같다.바로 어떤 녀석이 every인지 보자.1234567891011121314let nums = [1, 3, 100, 2, 7];let no3 = true;for(const num of nums) if(!(num % 3 === 0)) &#123; // 3의 배수가 아니라면 no3 = false; break;&#125;console.log(no3); // falsenums = [4, 8, 16, 20];no3 = true;for(const num of nums) if(!(num % 2 === 0)) &#123; // 2의 배수가 아니라면 no3 = false; break;&#125;console.log(no3); // true 위 코드는 모두 3의 배수인지, 모두 2의 배수인지를 구한 반복문이다.그럼 한 번 추상화해보자. 12345678const _every = (list, predicate) =&gt; &#123; for(const item of list) if(!(predicate(item))) return false; return true;&#125;;let nums = [1, 3, 100, 2, 7];console.log(_every(nums, num =&gt; num % 3 === 0)); // falsenums = [4, 8, 16, 20];console.log(_every(nums, num =&gt; num % 2 === 0)); // true 위에 반복문 부분도 _find로 추상화해보고 싶지만 위의 _some과 같이 falsy value 이슈가 있을 것 같다.그럼 falsy value로 부터 자유로운 _findIndex를 가지고 추상화해보자. 123456789101112const _findIndex = (list, predicate) =&gt; &#123; for(let i=0, len=list.length; i&lt;len; i++) if(predicate(list[i])) return i; return -1;&#125;;const _every = (list, predicate) =&gt; _findIndex(list, item =&gt; !predicate(item)) === -1;// 비트단위의 논리 연산자(Not)인 ~(Tilde)를 쓰면 다음과 같이 할 수 있다.//const _every = (list, predicate) =&gt; !~_findIndex(list, item =&gt; !predicate(item));let nums = [1, 3, 100, 2, 7];console.log(_every(nums, num =&gt; num % 3 === 0)); // falsenums = [4, 8, 16, 20];console.log(_every(nums, num =&gt; num % 2 === 0)); // true 오늘은 여기까지만 알아보도록 하자.다음 시간에는 함수형의 꽃이라 할 수 있는 curry에 대해 알아보도록 하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"(함수형 JS) reduce","slug":"js-func-05-reduce","date":"2017-06-25T16:26:21.000Z","updated":"2017-07-01T09:37:55.000Z","comments":true,"path":"2017/06/26/js-func-05-reduce/","link":"","permalink":"http://perfectacle.github.io/2017/06/26/js-func-05-reduce/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? reduce기본적으로 reduce는 기존 데이터들을 가공해 아예 새로운 데이터를 얻고자 할 때 쓰인다.1~6까지의 배열이 존재할 때 해당 수들을 가지고 새로운 수를 얻고자 할 때 쓰인다. 1234567const nums = [1, 2, 3, 4, 5, 6];let sum = 0;for(const num of nums) sum += num*2;console.log(sum); // 42sum = 0;for(const num of nums) if(num%2) sum+= num;console.log(sum); // 1 + 3 + 5 = 9 뭐 딱히 추상화할 건 별로 없어보이지만 이런 반복스런 냄새들을 잘 맡고 캐치하는 것이 중요하다.반복문 부분, 그리고 arrayLike와 객체를 위해 일단 추상화를 진행해보자. 123456789101112131415161718const _each = (list, iteratee) =&gt; &#123; if(list.toString() === '[object Object]') &#123; const objValList = []; for(const key of Object.keys(list)) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;// memo는 디자인 패턴 중 하나인 메모제이션 패턴을 이용한다는 것을 뜻하는 것 같다.// 또한 데이터들을 어떻게 가공할지는 반복된 함수(iteratee)에게 위임, 추상화 하였다.const _reduce = (list, iteratee, memo) =&gt; &#123; // for(const item of list) memo = iteratee(item, memo); // 위 코드는 리스트의 반복문을 돌기 때문에 아래와 같이 추상화가 가능하다. _each(list, item =&gt; memo = iteratee(item, memo)); return memo;&#125;;const nums = [1, 2, 3, 4, 5, 6];console.log(_reduce(nums, (num, memo) =&gt; memo + num*2, 0)); // 42 head, tail하지만 초기값인 메모제이션 인자가 제공되지 않으면 위 함수는 죽고 만다.좀 더 사용하기 쉽게 함수를 만드려면 초기값은 생략이 가능해야한다.12345678910111213141516171819202122232425262728293031323334const _each = (list, iteratee) =&gt; &#123; if(list.toString() === '[object Object]') &#123; const objValList = []; for(const key of Object.keys(list)) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;// 리듀스에 초기값이 제공되지 않는 경우 그 초기 값을 얻어내기 위한 함수// 인덱스로 접근할 수 없는 객체에 대해서 처리를 해줘야 함.const _head = list =&gt; list.toString() === '[object Object]' ? Object.keys(list)[0] : list[0];// 초기값을 제외한 값들const _tail = list =&gt; ( // slice 메소드가 없는 객체의 경우에는 키값들을 퉁친 배열로 반환 list.toString() === '[object Object]' ? Object.keys(list).slice(1) : // slice 메소드(프로토타입 등등)가 있으면 고대로 쓰면 되고 ArrayLike 같은 경우에는 Array로 바꿔준 후에 호출하면 됨. list.slice ? list.slice(1) : Array.from(list).slice(1));const _reduce = (list, iteratee, memo) =&gt; &#123; if(memo === undefined) &#123; // 초기 값이 없다면 // 해당 리스트의 첫 번째 값을 초기값으로 삼으면 된다. memo = _head(list); // 해당 리스트의 첫 번째 값을 제외한 녀석을 리스트로 삼으면 된다. list = _tail(list); &#125; _each(list, item =&gt; memo = iteratee(item, memo)); return memo;&#125;;const nums = [1, 2, 3, 4, 5, 6];const doms = document.querySelectorAll('*');const obj = &#123;name: 'ㅁㄴㅇㄹ', age: 9999&#125;;console.log(_reduce(nums, (item, memo) =&gt; memo + item*2)); // 41console.log(_reduce(doms, (node, memo) =&gt; `$&#123;memo&#125;노드 이름은 $&#123;node.nodeName&#125;\\n`, ''));console.log(_reduce(obj, (key, memo) =&gt; `$&#123;memo&#125;$&#123;key&#125;: $&#123;obj[key]&#125;\\n`, '')); 세미나 들은 걸 토대로 머리를 굴려봐서 짜봤는데 틀린 부분은 없는지 확신은 못 하겠다.여튼 뭐 돌아는 가니… curry와 curryr, 그리고 pipe와 go가 정말 함수형의 꽃인 것 같은데…일단 다음 포스트인 find를 보도록 하자!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"(함수형 JS) each","slug":"js-func-04-each","date":"2017-06-25T16:26:15.000Z","updated":"2017-07-01T09:37:55.000Z","comments":true,"path":"2017/06/26/js-func-04-each/","link":"","permalink":"http://perfectacle.github.io/2017/06/26/js-func-04-each/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? each기본적으로 each는 반복문을 추상화 할 때 쓰인다.완벽할 것 같은 이 _filter와 _map도 다시 보면 중복이 존재한다.이런 중복을 제거하고 추상화 하는 것들이 함수형의 묘미가 아닐까 싶다. 123456789101112131415161718192021const _filter = (list, predicate) =&gt; &#123; const newList = []; if(list.toString() === '[object Object]') &#123; const objValList = []; for(const key of Object.keys(list)) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;const _map = (list, iteratee) =&gt; &#123; const newList = []; if(list.toString() === '[object Object]') &#123; const objValList = []; for(const key of Object.keys(list)) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) newList.push(iteratee(item)) return newList;&#125;; 바로 for 반복문 부분과 객체를 배열화 시키는 부분이 굉장히 반복스런(?) 냄새를 풍긴다.저 부분까지 추상화 해낼 수 있다. 12345678910111213141516171819202122232425262728const _each = (list, iteratee) =&gt; &#123; if(list.toString() === '[object Object]') &#123; const objValList = []; for(const key of Object.keys(list)) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;const _filter = (list, predicate) =&gt; &#123; const newList = []; _each(list, item =&gt; predicate(item) &amp;&amp; newList.push(item)); return newList;&#125;;const _map = (list, iteratee) =&gt; &#123; const newList = []; _each(list, item =&gt; newList.push(iteratee(item))); return newList;&#125;;const users = [ &#123;id: 0, name: '양간장', age: 55&#125;, &#123;id: 1, name: '간장냥', age: 45&#125;, &#123;id: 2, name: '장냥이', age: 35&#125;, &#123;id: 3, name: '양권성', age: 25&#125;];const over40 = _filter(users, user =&gt; user.age &gt;= 40);const over40Name = _map(over40, person =&gt; person.name);console.log(over40);console.log(over40Name); 사실 추상화 해놓고 보면 약간 함수 외부에 있는 리스트에 요소를 넣는다거나 사이트 이펙트를 발생시키긴 하지만…최소한의 사이드 이펙트 정도는 눈감아줘도 되지 않을까… 싶다.음… 그리고 코드가 크게 줄어들지 않아서 와닿지 않을 수도 있는데…ES5 식 코드로 보면 정말 크게 와닿는다. 1234567891011121314151617181920212223242526// ES5var __filter = function(list, predicate) &#123; var newList = []; if(list.toString() === '[object Object]') &#123; const objValList = []; for(var i=0, len=Object.keys(list).length; i&lt;len; i++) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(i=0, len=list.length; i&lt;len; i++) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;// ES6const _each = (list, iteratee) =&gt; &#123; if(list.toString() === '[object Object]') &#123; const objValList = []; for(const key of Object.keys(list)) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;const _filter = (list, predicate) =&gt; &#123; const newList = []; _each(list, item =&gt; predicate(item) &amp;&amp; newList.push(item)); return newList;&#125;; ES5 식으로 작성한 반복문은 굉장히 실수를 하기 좋다.(물론 ES6도 아주 가끔…)조건문을 잘못 쓴다거나 등등…하지만 잘 작성해 놓은 반복문 하나(each)를 추상화해서 배열의 갯수만큼 순서대로 반복문을 돌릴 때반복문 로직을 직접 짜지 않고, 저 추상화한 each 메소드를 쓰면 실수를 할 여지가 많이 줄어드는 것 같다. 그럼 이제 바로 다음 포스트인 reduce를 공부해보자!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"(함수형 JS) map","slug":"js-func-03-map","date":"2017-06-25T16:26:10.000Z","updated":"2017-07-02T13:23:23.000Z","comments":true,"path":"2017/06/26/js-func-03-map/","link":"","permalink":"http://perfectacle.github.io/2017/06/26/js-func-03-map/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? map기본적으로 map은 수집, 원본 데이터들을 어떠한 형태로 가공해서 수집할까의 기능을 한다. 기존 프로그래밍우선 얻어온 데이터들을 우리가 만든 _filter 함수를 써서 필터링된 결과를 얻은 이후부터 생각해보자.이제 그 데이터(객체)에서 우리가 원하는 나이나 이름(가공)만 뽑아내보자.1234567891011121314151617181920const _filter = (list, predicate) =&gt; &#123; const newList = []; for(const item of list) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;const users = [ &#123;id: 0, name: '양간장', age: 55&#125;, &#123;id: 1, name: '간장냥', age: 45&#125;, &#123;id: 2, name: '장냥이', age: 35&#125;, &#123;id: 3, name: '양권성', age: 25&#125; ];const over40 = _filter(users, user =&gt; user.age &gt;= 40);const over40Age = [];for(const person of over40) &#123; over40Age.push(person.age);&#125;const over40Name = [];for(const person of over40) &#123; over40Name.push(person.name);&#125; 위 로직을 보니 역시 반복문 부분과 배열에 넣는 부분, 그리고 객체에서 어떤 걸 뽑아서 넣을지요 부분들이 추상화가 가능할 것 같다.그래서 아래와 같이 함수로 추상화가 가능할 것 같다.1234567891011const __map = (list, key) =&gt; &#123; const newList = []; for(const item of list) &#123; newList.push(item[key]); &#125; return newList;&#125;;const over40Age = __map(over40, 'age');const over40Name = __map(over40, 'name');console.log(over40Age); // [ 55, 45 ]console.log(over40Name); // [ '양간장', '간장냥' ] 잘 추상화 한 것 같다.객체의 다른 프로퍼티를 구한다고 할 때도 두 번째 키 인자만 바꿔주면 된다.읭? 객체 말고 다른 녀석인 경우에는? 배열의 요소에다가 모두 1을 더한 배열을 얻고 싶을 때는?이런… 추상화의 포커스가 객체의 키 값들을 얻어내는 데만 맞춰져있었다.다시 함수형 본연의 모습을 되찾을 때가 됐다. 함수형12345678910111213// 리스트의 아이템을 어떠한 형태로 수집할지를 iteratee 함수로 추상화하였다.// 이제 _map 함수는 데이터를 어떻게 수집할지에 대한 책임을 iteratee에게 위임하였다. // iteratee는 반복하는 행위를 하는 함수를 뜻하는 것 같다.// 그 함수는 요소를 인자로 받아서 그 요소를 가지고 지지고 볶고 하는 건 사용할 때 결정하면 될 일이다. // 위처럼 '어떻게 지지고 볶을지'를 추상화 해놓지 않고 직접 정의해놓으면 다르게 지지고 볶을 때마다 함수를 계속 만들어줘야한다.const _map = (list, iteratee) =&gt; &#123; const newList = []; for(const item of list) newList.push(iteratee(item)) return newList;&#125;;// 두 번째 함수에서는 데이터들을 어떻게 지지고 볶아서 가져올지에 대해 정의를 해주면 된다.console.log(_map(over40, person =&gt; person.age+1));console.log(_map(over40, person =&gt; person.name)); 하지만 아직 우리에게는 숙제가 하나 남아있다.filter에서는 딱히 필요성을 느끼지 못해 돌림직한 객체를 건너뛰었지만 이번 map 예제는 객체에서도 나름 쓸모가 있어 보인다.아래와 같이 객체의 값들을 얻어오고 싶다고 가정을 해보자.조금 복잡하게 설명했지만 객체는 배열과 같이 for of 구문으로 반복문을 돌릴 수 있는 녀석이 아니다.왜냐하면 객체는 순서가 없기 때문이다. (사실은 Symbol.Symbol(iterator) 프로퍼티가 없기 때문)원리가 궁금한 사람은 아래 포스트들을 참고하자.간단하게 Iterator 포스트 정도만 참고해도 될 것 같다. Interface Symbol Iterator123456const obj = &#123;name: '간장이', age: 255&#125;;// Object는 이터러블(반복을 돌릴 수 있는 애)이 아니기 때문에 이터레이터(반복해서 돌릴 수 있는 녀석)가 아니다. // 따라서 for of와 같은 구문을 만나면 오류가 나게 되는 것이다.console.log(_map(obj, v =&gt; v));// 물론 아래와 같이 에러를 회피할 수 있지만 위와 같이 쓰는 게 더 간결하지 않은가?console.log(_map(Object.keys(obj), key =&gt; obj[key])); // ['간장이', 255] key와 value의 쌍으로 이루어져있는 돌림직한 객체도 map으로 돌려버릴 수 있게 코드를 좀 손보자.간단하게 한 줄만 추가해주면 된다.1234567891011const _map = (list, iteratee) =&gt; &#123; const newList = []; if(list.toString() === '[object Object]') &#123; const objValList = []; for(const key of Object.keys(list)) key !== 'length' &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) newList.push(iteratee(item)) return newList;&#125;;console.log(_map(obj, v =&gt; v)); // ['간장이', 255] 그럼 이제 바로 다음 포스트인 each를 공부해보자!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"(함수형 JS) filter","slug":"js-func-02-filter","date":"2017-06-25T16:26:04.000Z","updated":"2017-06-25T16:35:17.000Z","comments":true,"path":"2017/06/26/js-func-02-filter/","link":"","permalink":"http://perfectacle.github.io/2017/06/26/js-func-02-filter/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? filter기본적으로 filter는 필터링, 조건에 맞는 녀석들만 걸러내서 새로운 데이터를 얻는 역할을 한다. 기존 프로그래밍우선 서버와 ajax로 통신해서 db에서 다음과 같은 json 데이터를 얻어왔다고 가정해보자.123456const users = [ &#123;id: 0, name: '양간장', age: 55&#125;, &#123;id: 1, name: '간장냥', age: 45&#125;, &#123;id: 2, name: '장냥이', age: 35&#125;, &#123;id: 3, name: '양권성', age: 25&#125; ]; 이 유저들 중에 40대 이상인 사람과 40대 미만인 사람을 구분하는 필터링을 구현해보자.1234567891011121314const over40 = [];for(const user of users) &#123; if(user.age &gt;=40) &#123; over40.push(user); &#125;&#125;const under40 = [];for(const user of users) &#123; if(user.age &lt; 40) &#123; under40.push(user); &#125;&#125;console.log(over40);console.log(under40); 위 코드를 보니 반복문 구문과 새로운 배열에 만족하는 녀석들을 삽입하는 부분이 반복된다.요것들을 어떻게 추상화 시켜서 재사용이 가능하게 끔 한번 해보고 싶어졌다.123456789const __filter = users =&gt; &#123; const tmp = []; for(const user of users) &#123; if(?????) &#123; tmp.push(user); &#125; &#125; return tmp;&#125; 우리가 기존에 객체 지향으로 프로그래밍을 했을 때는 조건문 부분은 추상화하기가 힘들다.이런 간지러운 부분을 함수형으로 바꾸면 바로 해결이 가능하다. 함수형 프로그래밍123456789101112131415161718// predicate는 참인지 거짓인지를 판별하는 함수?를 뜻하는 것 같다.// 또한 사용자만 받는 users라는 인자 보다는 좀 더 범용적인 이름인 list를 쓰는 게 좋다.const _filter = (list, predicate) =&gt; &#123; // 나는 그냥 임시로 쓰고 말 녀석이기 때문에 별 생각 없이 tmp 등등으로 쉽게 네이밍을 했다. // 하지만 순수 함수는 사이드 이펙트를 발생시키지 않고, // 입력값을 토대로 새로운 값을 출력하는 불변성을 가지니 new라는 키워드를 붙여주는 게 좋다. const newList = []; // 필터링의 조건을 predicate 함수로 추상화시켰다. // 구현부에서는 조건문을 신경쓰지 않고 해당 함수에게 위임하면 된다. // 또한 함수형 프로그래밍에서는 뭔가 한 줄로 적는 게 간지 같아서 조건문을 논리 연산자로 함축시키고, 중괄호도 다 생략했다. for(const item of list) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;// 이 유저들 중에 40대 이상인 사람과 40대 미만인 사람을 구분하는 필터링을 구현해보자. const over40 = _filter(users, user =&gt; user.age &gt;= 40);const under40 = _filter(users, user =&gt; user.age &lt; 40);console.log(over40);console.log(under40); 위에 _filter 함수를 보면 조건(predicate)를 함수의 인자로 받아서그 내부가 어떻게 구현됐건 신경쓰지 않고 predicate 함수에게 배열의 요소만 넘겨서 조건이 참이면 새 배열에 넣게 끔 구현했다.이렇게 _filter는 조건을 추상화, predicate 함수에게 위임했기 때문에 좀 더 사용성이 높아졌다.위와 같이 짜게 되면 ArrayLike의 대표적인 케이스인 NodeList도 필터링이 가능하다. 그리고predicate(item) &amp;&amp; newList.push(item);위 구문이 이해 안 가는 사람은 똑똑한 논리 연산자와 값 vs 식 vs 문을 참고해보자. 1234const nodeList = document.querySelectorAll('*');console.log(_filter(nodeList, node =&gt; node.nodeName === 'HTML'));// Uncaught TypeError: nodeList.filter is not a functionconsole.log(nodeList.filter(node =&gt; node.nodeName === 'HTML')); key와 value의 쌍으로 이루어져있는 돌림직한 객체를 필터링하는 것은 세미나에서 다루지 않았기 때문에 정리하지 않겠다.key와 value의 쌍으로 이루어져있는 돌림직한 객체를 필터링하는 것은 예제가 잘 떠오르지 않고,필요성을 잘 느끼지 못했기 때문에 정리하지 않도록 하겠다.혹시 관련된 예제나 필요성 등등을 아신다면 댓글을… ^^ 그럼 이제 바로 다음 포스트인 map을 공부해보자!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"(함수형 JS) 왜 쓸까?","slug":"js-func-01-why-make","date":"2017-06-25T16:25:57.000Z","updated":"2017-06-25T16:57:08.000Z","comments":true,"path":"2017/06/26/js-func-01-why-make/","link":"","permalink":"http://perfectacle.github.io/2017/06/26/js-func-01-why-make/","excerpt":"","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? 왜 쓸까?우선 함수형 프로그래밍의 핵심을 꼽아보라고 하면 Filter Map Reduce Find 등등을 꼽아볼 수가 있다. 기본적으로 ES5부터는 Array.prototype.map Array.prototype.filter Array.prototype.reduce Array.prototype.find 등등의 메소드가 이미 존재한다.단순히 메소드이기 때문에 함수로 만들고자 이 행위를 하는 것일까?아니다.이 메소드들은 ArrayLike나 돌림직한(?), 돌릴 수 있는 데이터(key와 value의 쌍으로 이루어져있는 object 등등)들에게는 적용되지 못한다. ArrayLike…?ArrayLike는 배열 같지만 배열이 아니다.다음과 같은 특징을 갖는다. length 프로퍼티가 존재한다. index로 접근이 가능하다. Symbol(Symbol.iterator) 프로퍼티가 있기 때문에 이터러블하다. 하지만 Array의 프로토타입을 상속받지 않는다. 1~3번 때문에 배열 같지만, 정작 4번 때문에 배열의 메소드들은 사용하지 못한다는 점이 특징이다.여하튼, 위 메소드들은 순수 배열만 사용 가능하지만 이제부터 우리가 만들어 볼 애들은 돌림직한 녀석들이면 모두 가능하다!즉 언어가 특정 기능을 추가해줄 때까지 기다릴 필요 없이 내 입맛대로 원하는 녀석들을 구현할 수가 있다.이게 바로 함수형이 가지는 장점이다! 또한 함수형으로 프로그래밍을 하다보면 기존에 객체 지향 프로그래밍을 할 때보다 더 추상화할 수 있는 요소가 많아진다.기존에 코딩을 하다보면 분명 반복된 것 같은데… 라는 생각은 들지만 마땅히 어떻게 추상화를 해야할지 찾아내기가 힘들었던 경험이 많다.하지만 함수형에서는 단순 변수에 값을 변화시키는 것을 뛰어넘어서 조건문, 반복문 등등 다양한 것들이 추상화가 가능하다.그래서 비슷한 일을 하는 녀석을 하나로 퉁쳐서 사용하기 때문에 비슷한 코드를 짤 필요가 없어진다. 그리고 함수형 프로그래밍을 할 때 장점이 이것 저것 조합해서 만들 수 있는 일이 많아진다.따라서 추상화 할 수 없을 것 같았던 부분도 여러 함수들로 조합을 하다보면 전부 추상화가 가능해 생산성이 올라간다.추상화가 가능하다는 것은 이 코드를 여기 저기서 쓸 수 있다는 것이고, 그렇게 된다면 당연히 코드를 짜는 시간이 줄어들기 때문이다.따라서 정말 보다보면 아무런 의미 없는 undefined를 리턴하는 함수, 값을 입력받아서 그대로 리턴하는 함수 등등뭐 이런 거까지 함수로 뽑아내나? 싶은 녀석들까지 있다고 한다. (아직 그런 걸 배워본 경지는 아니라서…) 이렇게 작은 단위로 쪼개서 함수를 만들다보면 테스트하기도 쉬워지고 오류가 날 가능성도 적어진다.또한 기존 객체 지향 프로그래밍에서는 사이드 이펙트 때문에 함수의 평가 시점에 따라서 결과가 다르게 나왔다.하지만 함수형 프로그래밍에서는 기본적으로 사이드 이펙트가 없는 순수 함수를 지향하기 때문에 어느 시점에 평가가 이루어져도 된다.따라서 기존 객체 지향 프로그래밍에서는 싱크를 맞추거나 락을 걸어놓거나 쓰레드 풀을 만들어 놓고기타 뻘짓을 했어야 했다는데(자바를 잘 몰라서 죄송합니다 ㅠㅠ) 함수형 프로그래밍으로 작성을 하면 언제 실행되던 간에 상관이 없는 것이다. 따라서 이러한 진가를 발휘하는 게 또 Node.js이다.기본적으로 자바와 같은 프로그램에서는 하나의 요청이 들어오면 하나의 쓰레드를 만들고,그 쓰레드는 그 유저의 요청이 끝날 때까지 해당 유저만 점령할 수 있는 것으로 알고 있다.하지만 Node는 하나의 요청이 들어오면 요청에 대한 처리를 돌리고, 그 처리가 끝나는 동안 다른 유저의 요청들을 받는다.그 이후에 기존 유저의 처리가 끝나면 콜백함수가 실행되는 싱글 스레드 형태이다.이렇게 비동기 I/O로 서버를 구성하다보니 동접에 있어서 훨씬 적은 자원으로 효율성이 올라간다고 한다.이 비동기에서 중요한 것은 언제 실행하던 동일한 결과를 보장받아야 한다는 것이다.유저의 요청이 언제 끝나는지에 따라 실행 결과가 달라진다면 기존 자바와 같이 락을 걸어놓아야 할 것이다.하지만 순수 함수로 하다보면 이런 요청에 대한 평가가 언제 이루어지던 동일한 결과를 보장받으므로비동기 I/O의 동시성, 병렬성 뭐시기 이런 것들을 더욱 쓸 수 있다는데… 요런 놈도 더 공부를 해야겠다. 이런 것들을 알고 보니 lodash나 underscore는 단순히 유틸성 라이브러리가 아니라함수형 프로그램 패러다임을 준수하여 코딩하는 걸 도와주는 차원의 라이브러리였다는 걸 깨닫게 되었다. 그럼 이제 바로 다음 포스트인 filter를 공부해보자!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/함수형-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"http://perfectacle.github.io/tags/함수형/"}]},{"title":"Node.js란...?","slug":"what-is-node-js","date":"2017-06-18T12:12:33.000Z","updated":"2017-06-25T16:59:15.000Z","comments":true,"path":"2017/06/18/what-is-node-js/","link":"","permalink":"http://perfectacle.github.io/2017/06/18/what-is-node-js/","excerpt":"","text":"이 글을 쓰게 된 계기는 다음과 같다. Q: Node.js는 서버인가요?A: 네, 백엔드 개발자들이 Node.js를 씁니다. ‘백엔드 개발자도 쓸 뿐, 프론트 엔드 개발자도 쓸 수 있다’가 내가 내린 결론이고,오늘은 그에 대해 하나 하나 검증해보는 시간을 가져보고, 다른 사람들에게 잘못된 지식이 전파되는 걸 막고자 한다.혹시 내가 내린 결론이 잘못된 부분은 무한 태클을 환영한다. Node.js란…?Node.js는 Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임이다.V8 자바스크립트 엔진은 여기서 중요한 포인트가 아니므로 직접 찾아보길 바란다. 런타임에 대해 정리한 다른 블로그의 포스트를 빌려보자면 다음과 같다. 런타임이란 프로그래밍 언어가 구동되는 환경 예전에는 자바스크립트 런타임이 브라우저 밖에 존재하질 않았다.하지만 그러한 한계를 극복하고 Node.js가 나왔다. Javascript 실행 환경?첫 번째로 Node.js는 REPL(Read, Eval, Print, Loop)을 통해서 런타임을 제공한다. Read: 유저의 입력 값을 받아서 메모리에 저장 Eval: 입력 값의 평가, 실행 Print: Eval로 인해 반환된 값을 출력 Loop: 1~3을 반복. 이러한 REPL은 Babel REPL과 같이 웹에서 제공해주기도 하고,Node.js에서 제공하는 REPL은 윈도우의 CMD, 맥의 터미널 등등에서 제공을 해준다. 두 번째로 따로 자바스크립트 파일을 Node.js에서 제공하는 자바스크립트 런타임을 통해 실행이 가능하다.위와 같이 REPL에서 개발을 하면 간단한 테스트 정도면 몰라도 어플리케이션을 개발하는 데 적합하지 않다.따라서 repl 보다는 따로 스크립트 파일을 만들어서 그 스크립트 파일을 node.js, V8이 해석 후 실행하는 형태로 작업을 많이 하게 된다.아래 소스 코드를 node.js에서 돌리는 것은 위의 REPL에서 실행한 것과 동일하다.12345// a.jsconst a = 2;a;a + 4;console.log(a); 그럼 왜 Node.js는 백엔드 영역이라는 오해가 생겼을까?Node.js를 통해서 서버도 만들 수 있기 때문이다. 123456// server.jsconst http = require('http');http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end(\"Hello World\\n\");&#125;).listen(8080); 그럼 프론트 엔드 개발자는 언제 Node.js를 쓰는가?매우 빈번하게 쓰이는데 그 중에서 대표적으로 ES2015+ 문법을 ES5 문법으로 트랜스파일 해주는 Babel을 예로 들어보겠다.먼저 babel의 기본적인 요소들을 설치하겠다.1npm i -S babel-cli babel-preset-env babel-cli, CLI이기 때문에 터미널 위에서 돌아간다는 점을 염두해두자. 그리고 간단한 바벨 설정 파일(.babelrc)을 만들어주자.123&#123; \"presets\": [\"env\"]&#125; 그 다음에 package.json의 npm script 부분을 다음과 같이 추가해주면 된다.12345&#123; \"scripts\": &#123; \"babel\": \"babel\" &#125;&#125; 그리고 ES2015+의 간단한 파일을 하나 만들어보겠다.12// a.jsconst a = 1; 터미널에서 babel-cli를 통해 해당 파일을 ES5로 트랜스파일 된 결과를 보자. 이게 뭐가 Node.js를 통해 실행한 내용인지 확인해보자.기본적으로 npm script는 node_modules 디렉토리 안의 .bin 디렉토리에 있는 디렉토리를 인식한다. 그리고 그 내용은 다음과 같다.123#!/usr/bin/env noderequire(\"../lib/babel\"); #!/usr/bin/env node 요 구문으로 인해 node.js에서 cli를 만들 수 있게 해주는 것이라고 생각하면 된다.그럼 직접 ../lib/babel을 찾아가보자. Node.js에서 기본적으로 디렉토리 뒤에 따로 파일이 명시되지 않으면 index.js 파일을 찾아가는 규칙이 있다.index.js 파일의 상단 부분을 보면 다음과 같다. 123456789101112131415161718#!/usr/bin/env node\"use strict\";var _keys = require(\"babel-runtime/core-js/object/keys\");var _keys2 = _interopRequireDefault(_keys);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var fs = require(\"fs\");var commander = require(\"commander\");var kebabCase = require(\"lodash/kebabCase\");var options = require(\"babel-core\").options;var util = require(\"babel-core\").util;var uniq = require(\"lodash/uniq\");var glob = require(\"glob\");// 이하 생략 소스 코드 첫 라인에 #!/usr/bin/env node을 보면 CLI임을 짐작할 수 있다.그럼 다음과 같이도 실행을 해볼 수도 있다는 말이 된다. 하지만 우리가 접근한 파일은 우리가 흔히 보고 있는 js 파일이다.Node.js는 자바스크립트를 실행해줄 수 있는 환경인 런타임을 제공해주기 때문에 다음과 같이도 할 수 있다. 즉, 바벨을 쓴다면, 프론트 엔드 개발자도 Node.js를 쓴다는 결론을 내릴 수가 있다.바벨 뿐만 아니라 웹팩, 걸프, CRA, Vue-CLI 등등 npm으로 설치하는 모든 CLI는 Node.js를 이용한다고 보면 된다.그리고 npm(Node Package Manger)을 쓴다는 것 자체가 Node.js를 이용한다고 보면 된다. 웹을 벗어난 Node.jsNode.js는 확장성 있는 네트워크 애플리케이션을 위해 설계했다고 나온다.네트워크 어플리케이션, 즉 서버, 서버를 위해서 설계된 플랫폼이다.따라서 Node.js로 실제 구현하는 내용도 서버가 많다는 것에는 동의한다.또한 많은 프론트 엔드 개발자들이 주로 노드를 이용하는 사례인npm으로 의존성 모듈 관리, 바벨, 웹팩과 같은 CLI를 Node.js 위에서 구동하는 경우이 경우에 나 노드 할 줄 안다 라고 누군가에게 어필하기에는 다소 무리가 있을 수가 있다.왜냐면 노드로 서버를 구축하는 사례가 너무 많고, 이미 그런 오해가 정석처럼 받아들여지는 상황이라필드에 나가서 노드 할 줄 안다고 했을 때 나 노드로 서버 만들 줄 안다. 나 노드로 의존성 모듈 관리하고 CLI를 Node.js 위에서 돌릴 줄 알아.둘 중에 누구의 말로 받아들이는 경우가 더 많을까…이런 고민을 하다보니 그럼 웹이 아닌 경우에는 무엇이 있을까 고민하게 됐다. 데스크탑 어플리케이션을 제작해주는 일렉트론(Electron)맥, 윈도우 등등의 크로스 플랫폼 데스크탑 어플리케이션을 HTML, CSS, JS를 통해 만들 수 있다.자세히 몰라서 아래의 사진으로 대체하겠다.슬랙과 atom, vs code가 일렉트론으로 만들어졌다 하니 믿을만 하다고 할 수 있을 것 같다. 결론Node.js를 할 줄 안다고 하면 Node.js로 서버를 구성할 줄 안다라고 인식되는 것은 어느 정도 이해할 수 있다.하지만 Node.js 그 자체를 백엔드 자체만의 기술, 웹 서버 자체만으로 받아들이고프론트 엔드 개발자들은 Node.js를 쓸 줄 모른다는 그런 잘못된 지식으로 남들에게 더 이상 인식되지 않는 환경이 조성되길 바란다.명심하자.Node.js는 백엔드, 웹 서버가 아니라 자바스크립트 실행 환경에 불과하다 참조 링크 런타임이란? REPL 터미널 Electron으로 웹 앱 만들듯 데스크톱 앱 만들기","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"Node.js","slug":"Programming/Node-js","permalink":"http://perfectacle.github.io/categories/Programming/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"}]},{"title":"(자알쓰) 연산자","slug":"js-008-operator","date":"2017-06-01T15:35:42.000Z","updated":"2017-06-01T15:35:42.000Z","comments":true,"path":"2017/06/02/js-008-operator/","link":"","permalink":"http://perfectacle.github.io/2017/06/02/js-008-operator/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 여덟 번째 시리즈는 연산자를 주제로 진행하겠다. 캐스팅(Casting) 연산자캐스팅이라 하면 형변환이랑 동일하다고 보면 된다. Any -&gt; String123456console.log(false.toString()); // 'false'console.log(new String(true).toString()); // 'true'console.log(String(null)); // 'null'// 제일 간결해서 추천한다.console.log('' + undefined); // 'undefined' Any -&gt; Number123456789101112console.log(parseInt(true)); // NaNconsole.log(parseFloat(null)); // NaNconsole.log(new Number('11a').valueOf()); // NaNconsole.log(Number('123')); // 123console.log(1 * '334'); // 334console.log('123.4' / 1); // 123.4console.log(-(-'445.2')); // 445.2console.log(~~'112.2'); // 112// + 연산자가 제일 간결하고, 소수점 이하 보존도 되고, ES6+에서 생긴 이진수, 십진수 리터럴도 지원한다. console.log(+'0b1111'); // 15console.log(+'1233.3'); // 1233.3 Any -&gt; Boolean12345console.log(Boolean(null)); // falseconsole.log(new Boolean(undefined).valueOf()); // false// 아래가 제일 간결해서 아래를 추천한다.console.log(!!2); // true = 연산자의 비밀= 은 우항의 값을 좌항의 변수에 할당할 때 쓰는 할당 연산자이다.하지만 모든 연산자에는 반환 값이 존재한다. 반환값 없는 연산자는 존재하지 않는다.1234567var a = 2;var b;var c;console.log(c = b = a = 3); // 3console.log(a); // 3console.log(b); // 3console.log(c); // 3 a = 3에 의해 3이 a에 할당된다. b = a에 의해 a의 값인 3이 b에 할당된다. c = b에 의해 b의 값인 3이 c에 할당된다. = 연산자는 우항의 값을 반환하는 연산자이므로 3이 반환된다. 이렇게 = 연산자는 변수 할당문으로 쓸 수 있지만 그 자체가 연산자이기 때문에 표현식으로써의 기능도 충실히 수행할 수 있다.표현식이기 때문에 변수에 할당할 수 있다는 것은 당연한 소리다.위를 보고 변수 할당 체이닝이라 부르려나.. 쉼표(,) 연산자의 비밀, 또한 연산자이다. 그 말은 반환값이 있다는 것이다.우선 ,의 사용 사례를 보도록 하자.1234567891011121314151617181920// 1. 변수 선언문var i = 2;var j = 3;var k;// 아래와 같이 할 수도 있다.// var i = 2, j = 3, k;// 2. 함수 선언문(표현식)function a(b, c) &#123; return b*c; &#125;// 3. 함수 호출문a(2, 3); // 6// 그렇다면 , 연산자의 반환 결과는 무엇일까?console.log((1, 2, 3)); // 3var a = 2, b = 2;console.log((a += 2, b += 3, a*b)); // 20console.log(a); // 4console.log(b); // 5 쉼표 또한 연산자이고 가장 우측에 있는 녀석의 값을 반환한다는 사실을 알았다.신기하다. n제곱 연산자(ES2016+)ES2016+이기 때문에 웬만해서는 바벨을 돌려야할 것이다.1console.log(2 ** 3); // 8 기타 유용한 연산자&amp;&amp;, ||와 같은 똑똑한 논리 연산자, ~(Tilde) 연산자도 참고해보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Value","slug":"Value","permalink":"http://perfectacle.github.io/tags/Value/"},{"name":"Expression","slug":"Expression","permalink":"http://perfectacle.github.io/tags/Expression/"},{"name":"Statement","slug":"Statement","permalink":"http://perfectacle.github.io/tags/Statement/"}]},{"title":"(자알쓰) 값 vs 식 vs 문","slug":"js-007-value-expression-statement","date":"2017-06-01T15:35:27.000Z","updated":"2017-06-01T15:35:27.000Z","comments":true,"path":"2017/06/02/js-007-value-expression-statement/","link":"","permalink":"http://perfectacle.github.io/2017/06/02/js-007-value-expression-statement/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 일곱 번째 시리즈는 값 vs 식 vs 문을 주제로 진행하겠다. 값(Value)값은 고정적이다. 변하지 않는다. 너무 쉬워서 뭐라 달리 설명할 게 없다.아래와 같은 것을 값이라고 부른다.123456789101112131415161718192021222324252627282930313233// 1. Undefinedconsole.log(undefined);// 2. Nullconsole.log(null);// 3. Booleanconsole.log(true);console.log(false);// 4. Numberconsole.log(1);console.log(0);console.log(-2.1);console.log(NaN);console.log(-0);console.log(Infinity);console.log(-Infinity);// 5. Stringconsole.log('');console.log('\\n');console.log('aa qq');// 6. Symbol (ES2015+)console.log(Symbol('aa'));console.log(Symbol.for('qqq'));// 7. Objectconsole.log(function()&#123;&#125;);console.log([]);console.log(&#123;&#125;);console.log(/a/); Falsy Value &amp;&amp; Truthy valueFalsy Value는 조건식에서 false로 취급되는 모든 경우를 뜻한다.다음과 같다.123456console.log(!!0);console.log(!!NaN);console.log(!!'');console.log(!!undefined);console.log(!!null);console.log(false); Truthy Value는 조건식에서 true로 취급되는 값이고 위의 경우를 제외하고 전부이다. 식(Expression)표현식이라고도 부른다.평가(실행)했을 때 값을 반환하는 녀석은 전부 식이라고 한다.다음과 같이 말도 안 되는 것 같이 보이는 것들도 식이라고 할 수 있다.123456789101112var a = 2;function b(c) &#123; return c*c; &#125;// 대부분은 아래와 같이 변수 할당'문'(?)의 형태로만 써봤을 것이다.// a = 3;console.log(a = 3); // 3console.log(b(2)); // 8console.log((a=3, false, 3+7)) // 10// 아래 코드를 다음과 같이 쓸 수 있다. 물론 권장하지 않는다.// a = 1 &gt; a ? 3 : 2;1 &gt; a ? a = 3 : a = 2; 제일 기괴한 것은 a = 3을 문이 아닌 식으로써 쓸 수 있다는 것이다.대부분 a = 3; 과 같이 문으로써는 써봤어도 식으로써는 써본 적이 적거나 없을 것이다.여기서는 일단 위 구문을 식으로써 써서 값을 반환한다는 정도만 알아두자.다음에 연재할 연산자 파트에서 자세히 알아보도록 하자.여기서 알아둘 점은 식은 값을 반환하고 그 값을 변수에 할당이 가능, 즉 변수 할당문 우변에 사용이 가능하다는 뜻이다.혹은 반복문이나 조건문의 조건식, 반복문의 증감식 등등에도 쓰일 수 있고 삼항 연산자,함수의 반환값 등등에서도 충분히 사용이 가능하니 꼭 알아둬야할 부분이다. 문(Statement)세미콜론을 만나면 문이라고 생각하면 된다.단 조건문, 반복문, 함수 선언문, 예외 처리 구문 등등과 같이 블록({})이 들어간 구문은문 끝에 세미콜론이 포함되면 문법 상 옳지 않다.123456789101112if(1 &gt; 10) &#123; alert(1); &#125; // 조건문while(false) &#123; alert(2); &#125; // 반복문function x()&#123;&#125; // 함수 선언문// 예외 처리 구문try &#123;&#125;catch(e) &#123;&#125;var z; // 변수 선언문z = 2; // 변수 할당문x(); // 함수 호출문var y = function(a)&#123; // 변수 초기화 구문 return a; // 값 반환 구문&#125;; 문 중에는 변수 할당문과 함수 호출문 같이 식으로써 쓰일 수 있는 것도 있다.하지만 다른 문들은 값, 식과는 달리 할 수 없는 게 있다.바로 문은 변수에 할당이 불가능하다.상식적으로 if 문을 변수에 할당한다고 생각하면 말이 안 된다고 볼 수 있다.예외로 함수 선언문은 함수 표현식으로 변환이 되어 변수에 할당이 가능하다. 막상 적고 보니 별로 생각나는 게 없으니 이만 마무리하고 연산자 파트까지 보도록 하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Value","slug":"Value","permalink":"http://perfectacle.github.io/tags/Value/"},{"name":"Expression","slug":"Expression","permalink":"http://perfectacle.github.io/tags/Expression/"},{"name":"Statement","slug":"Statement","permalink":"http://perfectacle.github.io/tags/Statement/"}]},{"title":"(자알쓰) 반복문의 진실 (번외편)","slug":"js-loop-truth","date":"2017-06-01T15:35:00.000Z","updated":"2017-06-01T15:39:41.000Z","comments":true,"path":"2017/06/02/js-loop-truth/","link":"","permalink":"http://perfectacle.github.io/2017/06/02/js-loop-truth/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에도 번외편 격으로 반복문의 진실에 대해 알아보도록 하자. 반복문의 진실?사실 리덕스의 하나의 진실의 근원(Single Source of Truth)에서 영향을 받았다.우선 가장 간단한 1~10까지 더해서 출력하는 for 문을 살펴보도록 하자.12345var sum = 0;for(var i=1; i&lt;11; i++) &#123; sum += i;&#125;console.log(i); // 55 for 문은 아래와 같이 나눌 수 있다.다른 곳에서는 선언 및 초기화, 조건식, 증감식으로 했는데나는 거기다 표현식까지 붙였다. 위 구문은 아래와 같이 줄일 수 있다.for, while, if 문 등등은 실행 구문이 한 줄이면 대괄호가 생략 가능하다.12var sum = 0;for(var i=1; i&lt;11;) sum += i++; 증감 표현식은 필수가 아니다.또한 초기화 및 선언 구문도 필수가 아니기 때문에아래와 같이 줄일 수 있지만 전역 스코프를 더럽힐 가능성이 있기 때문에해당 변수를 스코프 외부에서도 쓰려는 특수한 경우가 아닌 이상은 권장하지 않는다.1234var sum = 0;var i = 1;for(; i&lt;11;) sum += i++;console.log(sum); // 55 이제부터 나오는 걸 실무에서 사용했다간 협업자나 사수에게 등짝 스매싱을 당할 수도 있다.하지만 증감 표현식을 달리 생각해보면 그냥 표현식으로 볼 수도 있다.반복문의 실행 구문, {} 안의 내용(여기선 생략했지만),이 끝난 이후에 한 번 실행되는 표현식에 불과하다고 볼 수 있다.아래와 같이 말이다.1234var sum = 0;var i = 1;for(; i&lt;11; sum += i++);console.log(sum); // 55 sum += i++ 이게 문이 아니라 표현식으로써 쓰일 수가 있다.표현식이라 하면 평가(실행)를 하여 값을 반환할 수 있으면 표현식이라 부를 수 있다.sum += i++에 의해 우선 sum에 sum + i++의 값이 할당되게 된다.그리고 그 반환값은 sum + i++이 된다.하지만 우리에게 중요한 것은 sum에 sum + i++의 값이 담겼다는 게 중요하지 그것의 반환값은 중요하지 않다.또한 그 자체만으로 표현식이기 때문에 조건과 관련이 있는 i에 i++과 같은 증감의 내용을 담고 있다면증감 표현식 자리에 반복문의 실행 구문이 들어갈 수 있게 되는 것이다. 하지만 여기서 멈춘다면 진실의 근원으로부터 멀어질 수가 있다.이 증감 표현식 부분 마저도 줄여버릴 수가 있다.아래와 같이 말이다.1234var sum = 0;var i = 1;for(; i&lt;11 &amp;&amp; (sum += i++););console.log(sum); // 55 &amp;&amp; 뒷부분을 괄호로 묶어주지 않으면 &amp;&amp; 연산자가 우선순위가 더 높아11 &amp;&amp; sum을 먼저 평가하고 거기다가 += 연산을 수행하므로 괄호로 묶어줘야한다.&amp;&amp; 연산자의 동작 원리가 궁금한 사람은 을 참고하자. 물론 해당 내용은 while에게도 적용이 된다.12345678910111213var sum = 0;var i = 1;while(i&lt;11) &#123; sum += i; i++;&#125;console.log(sum); // 55sum = 0;i= 1;// 위 while문을 줄이고 줄여보자.while(i&lt;11 &amp;&amp; (sum += i++));console.log(sum); // 55 do-while은 귀찮으니 그만 알아보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Loop","slug":"Loop","permalink":"http://perfectacle.github.io/tags/Loop/"}]},{"title":"(자알쓰) 훼이크 연산자 (번외편)","slug":"js-fake-operator","date":"2017-05-29T15:39:29.000Z","updated":"2017-05-30T13:24:02.000Z","comments":true,"path":"2017/05/30/js-fake-operator/","link":"","permalink":"http://perfectacle.github.io/2017/05/30/js-fake-operator/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에는 번외편 격으로 훼이크 연산자를 배워보도록 하자.아이디어를 제공해주신 백성훈 님께 감사를 전한다. 훼이크 연산자?말 그대로 훼이크 연산자이다. 공식 명칭은 아니다.의도한 대로 동작하지 않는 연산자를 뜻한다.어찌보면 왜 이렇게 스펙에 구현됐는지 이해하기 힘든 내용이라서 굳이 몰라도 될 것 같기도 하다. 기본적으로 함수 선언문은 함수의 이름이 필수적이다.12function a() &#123;&#125;function() &#123;&#125; // Uncaught SyntaxError: Unexpected token ( 그에 반해 함수 표현식은 함수의 이름이 옵션이다.디버깅을 위해서 권장을 한다지만 크롬에서는 이마저도 기본으로 제공해주는 것 같다.12const a = function a() &#123;&#125;;const b = function() &#123;&#125;; 에러가 전혀 나질 않는다.하지만 여기서 공통된 부분이 보인다.12345// 함수 선언문에서 이름을 뺀 부분, 비록 에러가 나지만...function() &#123;&#125;// 함수 표현식에서 이름을 뺀 부분const b = function() &#123;&#125;; 위 두 구문에서 변수 선언을 제외하고는 완전히 일치한다.이 내용들이 아래 (훼이크)연산자들을 만나면 시너지(?)를 발휘한다.모두 단항(Unary) 연산자들이다. 1+ - ! ~ 단항 연산자가 뭐라고 훼이크 연산자라고 말하는지 모르겠다면최신 스펙 문서인 ES2017 스펙의 Unary Operator 부분에서 대표적으로 Unary + Operator만 살펴보자. 맨 위에 보이듯이 우선 우리가 예측하는, + 연산자의 기능은 뒤에 있는 표현식의 평가 결과로써 얻어지는 값을 숫자형으로 변환해주는 기능을 한다.그렇다. + 뒤에있는 녀석은 무조건 표현식으로 취급한다.그 뒤에 있는 녀석이 표현식으로서의 문법만 지켰다면 선언문이어도 표현식인 것처럼 강제로 문변환? 식변환?이 일어나게 되는 것이다.그렇다면 우리가 살펴볼 훼이크 오퍼레이터 부분은 아래 부분에 나온다.evaluating UnaryExpression. + 뒤에 나오는 단항 표현식을 평가한다고 하는 것 같다.그렇다면 여기서 한 번 짱구를 굴려봐서 선언문을 표현식으로서 강제시켜서 써먹을 수 있는 방법이 있을까? 라는 생각까지 미치게 된다. (사실 나도 다른 글을 보고 유추한 거지만…)그렇다면 선언문과 표현식이 같은 문법으로 쓰이는 경우를 찾아보니 위에 적어논 익명(?) 함수 선언문과 익명 함수 표현식이었다.익명 함수 선언문은 오류를 뿜지만 이를 표현식으로써 사용한다면 문법상 오류를 뿜어내질 않는다.확인해보자.12345678// 함수 표현식을 평가해서 나오는 것은 함수 그 자체이다.// 왜냐하면 함수를 호출해서 true를 반환한 게 아니기 때문이다.// 이 함수 그 자체를 숫자형으로 바꾸니 Not a Number(NaN)이 나오는 것이다.console.log(isNaN(+function() &#123;return true;&#125;)); // true// 내 말이 안 믿긴다면 아래의 결과로 확인해보자.const a = function() &#123;return true;&#125;;console.log(+a); // NaN 이렇게만 쓰면 의미가 없으니 대부분 IIFE(Immediately Invoked Function Expressions, 즉시 실행 함수)와 엮어서 많이 쓴다.1234// 이렇게 쓰는 이유는 두 가지가 있는 것 같다.// 즉시 실행 함수의 가독성이 떨어지거나 보기 흉해서 보기 좋게 표현하려고,// 혹은 반환값을 가지고 다른 연산을 해야하는 경우인 것 같다.+function() &#123;return true;&#125;() === 1; 그런데 나는 딱히 즉시 실행 함수의 가독성이 나쁘다고 생각해본 적이 없고,즉시 실행 함수의 반환값을 가지고 뭘 해본 적이 없어서 딱히 필요성은 잘 모르겠다.다만 선언문 형태를 표현식으로서 취급한다는 게 신기했다. 참고 링크 JavaScript plus sign in front of function name Fake operator overloading in JavaScript","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Operator","slug":"Operator","permalink":"http://perfectacle.github.io/tags/Operator/"},{"name":"Unary","slug":"Unary","permalink":"http://perfectacle.github.io/tags/Unary/"}]},{"title":"성공(?)한 겜덕이 되다","slug":"become-successful-gamtaku","date":"2017-05-25T16:07:59.000Z","updated":"2017-05-25T16:07:59.000Z","comments":true,"path":"2017/05/26/become-successful-gamtaku/","link":"","permalink":"http://perfectacle.github.io/2017/05/26/become-successful-gamtaku/","excerpt":"","text":"나의 유년시절을 함께한 슈퍼 패미콤6세 경에 명절이 되면 할머니 집에 친척들이 다 같이 모여 슈퍼 패미콤으로 게임을 하였다.당시 미국에 살았던 친척 형네서 사온 것으로 알고 있는데, 그 형이 게임을 잘해서 덕분에 명절 때마다 항상 즐거웠다.슈퍼 스트리트 파이터 2, 슈퍼 동키콩 2, 슈퍼 마리오 월드, 요시 아일랜드 등등 정말 재미있게 했다.지금도 그 때 그 시절을 회상하면 참 그립다. 따라서 나는 아직도 슈퍼 패미콤이란 단어만 들어도 가슴이 뛰고 항상 그립다.초등학생 때 슈퍼 마리오 RPG의 한글패치를 접하면서 게임을 한글로 바꿀 수 있다는 사실을 알게 되었다.하지만 당시 나는 프로그래밍의 ‘프’자도 모르던 상황이라 미완성 패치를 즐기는 것으로 만족할 수 밖에 없었다. 그렇게 기억 속에 묻어뒀던 한글패치였는데 대학을 컴공으로 진학하게 되고,강좌를 보고 롬파일들을 분석하면서 어느 정도 할 수 있게 되면서 여러 게임들을 한글로 패치하게 되었다. 분석부터 번역가를 구하고 최종 검수까지 험난한 여정이 진행되지만,내 대학 생활은 그런 취미 생활로 인해 활력이 부여된 것 같다.지금은 생업과 다른 취미가 생겨 한글화를 접었지만, 후일에 또 할지도 모르겠다.내가 한 한글화는 다음과 같다. 초오공전 돌격편 초오공전 각성편 슈퍼마리오 RPG 고스트 트릭 제절초 생전 처음으로 팬(?)이 생기다위에서 한 게임 중에 가장 네임드 있는 작품은 슈퍼마리오 RPG와 고스트 트릭이다.그 중에서도 슈퍼마리오 RPG는 발매된 지 20년이 넘은 작품이라 그런지요즘 콘솔 게임을 즐기는 사람들보다 더 추억에 젖어있고 연배가 있는 매니아 층이 형성된 것 같다.그래서인지 2월 경에 직접 팩에다가 납땜을 해서 한글패치 된 팩을 제작해서 보내주신 분도 계신다. 정말 정말 뿌듯했다.한글화 하면서 가장 뿌듯했던 적이 아닐까 싶다.나름 유명(?)해졌다는 착각에 빠지기도 하면서 마냥 기분이 좋았다 ㅎㅎ 실기로 한글 패치 구동하기슈퍼 패미콤을 약 9세 경에 친척에게 떠나보내고, 실물을 보지 못한 지 어언 16년이 되었다.아직도 슈패하면 가슴이 뛴다. 하지만 막상 사라고 하면 사고 싶진 않은 걸 왜일까…요 근래 생일을 맞아 고스트 트릭을 번역해줬던 지인이 슈퍼 패미콤을 선물해주었다.하지만 110v 전원이라 바로 구동하진 못하고 변압기를 다시 구매하고 오늘에서야 도착을 했다.부푼 마음으로 연결하고 구동을 해봤는데, 레트로 TV가 아니라 화면이 많이 뭉개지지만 너무 가슴이 벅차 올랐다. 정말 인복이 타고난 것 같다.내심 내가 한글 패치 제작했으니 누군가 나에게 선물해 줬으면… 하는 마음도 가졌지만정말 뜻 깊고 내 유년시절로 돌아간 것 같은 시간이었다.잠깐 추억팔이 하고 말 줄 알았는데 게임을 하다보니 한글에다가 옛 추억들이 새록새록 피어나서 은근히 재미있다.역시 게임은 실기로 해야 제맛인 것 같다.언젠가 다시 한글화를 재개할 지는 모르겠지만… 이 맛에 한글화 하는 게 아닌가 싶다 ㅎㅎ행복한 밤이다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"http://perfectacle.github.io/categories/기타/잡동사니/"}],"tags":[{"name":"잡동사니","slug":"잡동사니","permalink":"http://perfectacle.github.io/tags/잡동사니/"}]},{"title":"(자알쓰) 모듈화 Part. 2","slug":"js-006-module","date":"2017-05-20T12:43:33.000Z","updated":"2017-06-01T14:36:06.000Z","comments":true,"path":"2017/05/20/js-006-module/","link":"","permalink":"http://perfectacle.github.io/2017/05/20/js-006-module/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 여섯 번째 시리즈는 ES2015+의 Module(모듈)을 주제로 진행하겠다.일단 ES5 이하에서 모듈화를 읽고 오길 바란다. import/exportES5 이하에서는 네임스페이스 패턴을 이용해 모듈화를 진행했지만 전역 스코프를 더럽힌다는 단점,전역 스코프를 더럽히지 않으려면 즉시 실행함수 패턴을 이용해야하지만 외부에서 접근이 불가능하다는 단점이 존재했다.진정한 모듈이라고 하면 외부에서 참조가 가능하면서 전역 스코프를 더럽히면 안 된다.그를 해결한 게 ES2015의 import/export 문법인데 지원 가능한 브라우저/노드가 없다.바벨이라는 트랜스파일러를 사용해서 ES5로 변환해도 Node.js에서 밖에 안 되고,브라우저에서는 모듈들을 하나로 합쳐주는 웹팩과 같은 모듈 번들러를 이용하는 수 밖에 없다.일단 스펙에는 표준으로 등록됐으니 한 번 알아보도록 하자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344// export 키워드로 모듈(변수라고 보이지만 이 변수가 하나의 일을 수행하는 모듈이 될 수도 있다.)을 내보내고 있다.// a.jsexport const a = 11;export const b = 22;const ajax = function(url) &#123; // 비동기 통신을 하는 함수.&#125;;// 그걸 외부에서 사용할 수 있게 끔 모듈로 만듦.// default로 만들 수 있는 모듈은 파일 당 한 개 뿐이다. export default c;// b.jsexport const a = 33;export const b = 44;const getLastIndex = function(arr) &#123; // 배열의 마지막 인덱스를 구하는 함수.&#125;;// 그걸 외부에서 사용할 수 있게 끔 모듈로 만듦. export default c;// a파일에 존재하는 모듈과 b파일에 존재하는 모듈들을 써서 실제로 앱을 만들어보자 // app.js// default 키워드로 export 한 모듈은 &#123;&#125; 안에 안 써줘도 된다.// 그냥 export 한 모듈은 &#123;&#125; 요 안에 모듈 이름을 적어줘야한다.// export 한 모듈을 한 번에 다 import 하려면 * as A 하면 A 객체의 프로퍼티로 모듈이 전부 바인딩 된다.import ajax, * as A from './a.js';// default 키워드로 export 한 모듈은 이름을 어떻게 불러와도 사용이 가능하다.// b.js에 a란 모듈을 불러오려고 했는데 이미 a란 모듈이 불러와졌거나 a라는 이름이 마음에 안 들면// as 라는 별칭 키워드를 써서 _a로 이름을 바꿔서 불러오고 있다.// b는 export 했지만 안 쓴다면 export하지 않아도 된다.import getLastIdx, &#123;a as _a&#125; from './b.js'console.log(A.a); // 11console.log(A.b); // 22console.log(_a); // 33// 모듈을 마음대로 불러다 쓸 수 있다.ajax('http://www.naver.com');getLastIdx([1, 2, 3, null, undefined, 7]); 전역 스코프를 더럽히지도 않으면서 네이밍도 자유로워지고 불러올 때도 입맛에 맞춰 불러올 수 있다.사실 여기서 설명한 모듈화는 빙산의 일각이고(내가 일각만 알고 있기도 하고…),import / export에서 좀 더 자세한 설명을 참고하고,추가적으로 Node.js 진영에서 모듈화를 위해 사용하는 CommonJS 스펙과 브라우저 진영에서 사용했던 AMD 스펙을 비교/정리 해주는JavaScript 표준을 위한 움직임: CommonJS와 AMD 포스팅을 참고하길 바란다.다음으로는 자료형과 변수에 대해서 정리를 해 볼 예정이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Module","slug":"Module","permalink":"http://perfectacle.github.io/tags/Module/"},{"name":"import","slug":"import","permalink":"http://perfectacle.github.io/tags/import/"},{"name":"export","slug":"export","permalink":"http://perfectacle.github.io/tags/export/"}]},{"title":"(자알쓰) 모듈화 Part. 1","slug":"js-005-module","date":"2017-05-19T15:14:47.000Z","updated":"2017-05-20T12:32:22.000Z","comments":true,"path":"2017/05/20/js-005-module/","link":"","permalink":"http://perfectacle.github.io/2017/05/20/js-005-module/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 다섯 번째 시리즈는 모듈화를 주제로 진행하겠다. 모듈화란?저번 시간에 아래와 같은 문제점이 존재한다는 것을 발견했다.1234&lt;script src=\"a.js\"&gt;&lt;/script&gt;&lt;!-- 요 사이에 내 부사수가 작성한 c.js를 로딩시켰다. --&gt;&lt;script src=\"c.js\"&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt; 123456789101112131415161718192021'use strict';// 내가 작성한 a.jsvar num = 1;// 내 부사수가 작성한 c.js// 블라블라var num = 2;// 블라블라// 내가 작성한 b.jswindow.onload = function() &#123; 'use strict'; var btnA = document.getElementById('a'); var btnB = document.getElementById('b'); btnA.onclick = function() &#123; console.log(num); &#125;; btnB.onclick = function() &#123; console.log(num); &#125;&#125;; a와 b 버튼을 누르면 내가 작성한 a.js의 num이 아닌 부사수가 작성한 c.js의 num값인 2가 출력된다.a보다 c.js를 더 늦게 불러왔고 js의 스코프는 모듈(이해하기 쉽게 설명하면 파일) 단위가 아니기 때문이다. 이런 문제점을 극복하고자 아래와 같은 패턴이 존재한다. 네임스페이스 패턴C++에서 처음 이 단어를 접했는데 일단 뭐 그 부분은 알아서들 찾아보고,그럼 어떻게 활용하는지 알아보자.1234567891011121314151617181920// 내가 작성할 a.jsvar util = util || &#123;&#125;;util.num = util.num || 1;// 부사수가 작성할 c.jsvar util2 = util2 || &#123;&#125;;util2.num = util2.num || 2;// 내가 작성할 b.jswindow.onload = function() &#123; 'use strict'; var btnA = document.getElementById('a'); var btnB = document.getElementById('b'); btnA.onclick = function() &#123; console.log(util.num); &#125;; btnB.onclick = function() &#123; console.log(util.num); &#125;&#125;; 이제 부사수가 지지고 볶고 자신의 스크립트를 어디서 불러오든간에부사수가 util 객체만 건드리지 않는다면 내 코드는 안전을 보장받는 것이다. 그럼 저 || or 연산자는 왜 썼는지 알아보자.||의 원리가 궁금한 사람은 (ES) 똑똑한 논리 연산자를 참고하자.1234567891011121314151617181920212223242526// 내가 작성한 util 모듈// util 이라는 1차 네임 스페이스var util = util || &#123;&#125;;// array라는 2차 네임 스페이스util.array = util.array || &#123;&#125;;util.array.getIdx = util.array.getIdx || function(val, array) &#123; // 블라블라&#125;;// 자바스크립트 파일이 너무 많아서 util이란 모듈이 존재하는지 모르고// || 연산자(기본값 지정)을 사용하지 않고 util 모듈을 재정의할 경우var util = &#123; string: &#123; getLastChar: function(str) &#123; // 블라블라 &#125; &#125;&#125;// 내가 작성한 util 모듈을 쓴 다른 코드var arr = [1, 4, 7];// 부사수가 정의한 util 모듈에 의해 array 네임스페이스는 날아간 상태임.// 따라서 오류가 발생함.var midIdx = util.array.getIdx(7, arr); 위와 같은 상황이 발생할까봐 좀 귀찮더라도 || 연산자를 써서 모듈을 정의할 것을 추천한다.아래와 같이 작성해야한다.12345678910111213141516171819202122232425262728293031323334// 내가 작성한 util 모듈// util 이라는 1차 네임 스페이스var util = util || &#123;&#125;;// array라는 2차 네임 스페이스util.array = util.array || &#123;&#125;;util.array.getIdx = util.array.getIdx || function(val, array) &#123; // 블라블라&#125;;// 자바스크립트 파일이 너무 많아서 util이란 모듈이 존재할까봐 기본값 패턴을 써서 util 모듈을 정의한 경우var util = util || &#123;&#125;;util.string = util.string || &#123;&#125;;util.string.getLastChar = function(str) &#123; // 블라블라&#125;;// 따라서 util 모듈은 아래와 같은 형태를 띈다.// 내가 작성한 util 모듈을 전혀 훼손시키지 않고 부사수의 모듈과 결합이 되었다.// 뭐 사실 모듈 간에 이름은 최대한 겹치지 않고 작하는 게 맞는 것 같다.util = &#123; array: &#123; getIdx: function(val, array) &#123;&#125; &#125;, string: &#123; getLastChar: function(str) &#123;&#125; &#125;&#125;;// 내가 작성한 util 모듈을 쓴 다른 코드var arr = [1, 4, 7];// 내가 작성한 util 모듈의 array 네임스페이스는 살아있음.var midIdx = util.array.getIdx(7, arr); 하지만 매번 있는지 없는지 기본 연산자로 체크하고 귀찮기도 하고,만약에 그 값이 존재한다면 내가 쓰려고 하는 값이 아닌 기존의 값으로 대체가 돼버리니재정의가 불가능해질 수도 있다.이를 위해서 ES2015에 대한 모듈화 포스팅을 참고하자. 스코프 강제 형성ES2015+는 블록 단위의 스코프라 {}만 써도 강제로 스코프가 형성이 됐었다.그럼 함수 단위의 스코프인 ES5에서는 어떻게 할 수 있을까?123456789101112131415// 함수를 임의로 만들면 된다.// 근데 함수는 만든다고 실행하는 게 아니니 함수를 만들자마자 실행해야한다.(function() &#123; // 즉시 실행할 것이기 때문에 재호출할 일이 없으니 이름이 필요 없으니 익명함수로 작 var a = 11; console.log(a);&#125;)(); // 그 함수를 실행// 이를 즉시 실행함수(IIFE: Immediately Invoked Function Expressions)라고 부른다. // 대개 1회성 함수, 한번만 쓰는 코드, 클로저 등등에 쓰는데// 전역 스코프를 더럽히지 않는다는 장점 때문에 나는 무조건 쓴다. // 하지만 외부에서 참조해야하는 경우에는 네임스페이스 패턴을 이용해 모듈화를 진행해서 쓰는 편이다.// 사실 ES2015+ 들어가면 이렇게 절대 안 쓰니 딥하게 파고들 필요는 없는 것 같다.(function() &#123; console.log(a); // a is not defined&#125;()); 위와 같은 즉시 실행함수 패턴은 단순 1회성 코드, 즉 다시는 참조할 일이 없는 코드들만 넣을 때 썼다.전역의 스코프를 더럽히지 않아 변수 네이밍이 자유롭다는 장점이 있다.다음 포스트에서는 ES2015+에서 모듈화를 어떻게 진행하는지 알아보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Module","slug":"Module","permalink":"http://perfectacle.github.io/tags/Module/"},{"name":"Namespace","slug":"Namespace","permalink":"http://perfectacle.github.io/tags/Namespace/"}]},{"title":"(자알쓰) Scope Part. 2","slug":"js-004-scope","date":"2017-05-18T15:14:47.000Z","updated":"2017-05-20T12:02:22.000Z","comments":true,"path":"2017/05/19/js-004-scope/","link":"","permalink":"http://perfectacle.github.io/2017/05/19/js-004-scope/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 네 번째 시리즈는 ES2015+의 Scope(스코프)를 주제로 진행하겠다.일단 ES5 이하에서 스코프를 읽고 오길 바란다. ES5와의 차이점ES2015+ 들어서 변수를 선언할 때 const와 let이 추가되었다.이에 대한 설명은 추후 포스트에서 정리할 예정이다.ES2015+를 쓴다 하더라도 var를 쓰면 큰 차이점이 없다.var와 const, let을 비교해보자.1234const a = 1;var b = 2;// const와 let은 window 객체의 프로퍼티에 할당되지 않는다.console.log(window.a, window.b); // undefined 2 블록 단위의 스코프ES5의 var는 함수 단위의 스코프라고 얘기했다.블록은 {} 요 구문을 뜻 하고 요 안에서만 변수가 살아 숨쉰다고 보면 된다.123456789101112131415161718192021222324252627// for문 - ()와 &#123;&#125;을 포함 - 에서 선언한 변수 i가// for 문 밖에서도 살아 숨쉬고 있다.for(var i=0; i&lt;10; i++) &#123;&#125;console.log(i); // 11// var와는 달리 let은 for문 안에서 선언했으면// for 문 외부에서는 참조가 불가능하다.for(let j=0; j&lt;10; j++) &#123;&#125;console.log(j); // j is not defined// for 문 외부에서 선언해야 for 문 외부에서도 사용이 가능하다.let k = 0;while(k++ &lt; 10) &#123;&#125;console.log(k); // 11// &#123;&#125;으로 명시적으로 스코프를 만들 수도 있다.// 이 다음 모듈화 포스트에 얘기할 즉시 실행함수 패턴과 유사하다고 보면 된다.&#123; const a = 1; console.log(a); // 1&#125;&#123; const a = 2; console.log(a); // 2&#125; ES5와 공통점이 역시 파일 별로 스코프를 가지는 게 아니라 역시 전역 스코프를 더럽힌다는 단점이 있다.12345// a.jsconst a = 2;// b.jsconst a = 3; // Identifier 'a' has already been declared 이를 극복하기 위해 import/export 문법이 있지만 다음 모듈화 포스트에서 다룰 예정이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Scope","slug":"Scope","permalink":"http://perfectacle.github.io/tags/Scope/"}]},{"title":"(JS) 숫자가 증가하는 애니메이션 구현하기","slug":"js-async-number-animation","date":"2017-05-02T15:39:29.000Z","updated":"2017-05-20T11:34:21.000Z","comments":true,"path":"2017/05/03/js-async-number-animation/","link":"","permalink":"http://perfectacle.github.io/2017/05/03/js-async-number-animation/","excerpt":"","text":"숫자가 0~100까지 순서대로 변하는 예제를 만들어볼 것이다.일단 예제 파일에 쓰일 index.html을 하나 만들어보자.123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이제 index.js 파일을 만들자.1~10까지 출력이니 반복문을 쓰면 될 것 같다.아래와 같이 콘솔창에 찍어보면 1~10까지 아주 잘 나온다. 123for(var i=1; i&lt;11; i++) &#123; console.log(i);&#125; 이제 실제 DOM에다 렌더링 시켜보자.예제 보기 숫자를 보여줄 때 그냥 보여주기만 하면 재미 없죠?한 번 쯤은 0~100까지 숫자가 순차적으로 올라가면서 보여주면더 역동적일 것 같다고 생각해보신 적들 있을 겁니다.저도 같은 생각을 해보며 글을 작성해보았습니다.콜백 함수, Promise, Async 123456var domRoot = document.getElementById('root');domRoot.innerText = 0; // 0으로 초기값 설정.for(var i=1; i&lt;11; i++) &#123; domRoot.innerText = i;&#125; 결과를 확인하면 너무 한 순간에 값이 바뀌어서 눈으로 확인이 불가능할 정도다.그렇다면 setTimeout으로 딜레이를 걸어보자!예제 보기 12345678910111213141516171819var domRoot = document.getElementById('root');domRoot.innerText = 0; // 0으로 초기값 설정.for(var i=1; i&lt;11; i++) &#123; // ES5까지는 함수 단위의 스코프여서 아래와 같이 하면 함수를 실행하는 시점은 // 반복문이 끝난 시점이라 i에는 10이 10번 들어가게 된다. //setTimeout(function() &#123; // domRoot.innerText = i; //&#125;); // ES5까지는 함수 단위의 스코프라 즉시 실행함수를 통해 변수의 스코프를 가두었다. // 즉시 실행 함수의 내부에 있는 함수를 실행하는 시점은 역시 반복문이 끝난 시점이다. // 하지만 즉시 실행 함수를 통해 변수를 가둬두었으므로 클로저를 통해 해당 변수에 들어간 값을 렌더링한다. (function(i) &#123; setTimeout(function() &#123; domRoot.innerText = i; &#125;, 100) &#125;(i));&#125; 하지만 위의 결과도 우리가 원하던 결과가 아니다.100ms 동안은 가만히 있지만 그 이후에 함수가 물밀듯 실행한다.setTimeout 함수는 동기식으로 동작하는 게 아니라 비동기 식으로 동작하기 때문이다.이를 위해서 우리에겐 콜백 함수란 게 존재한다!예제 보기 12345678910111213141516171819202122232425262728293031323334353637383940// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.var changeNum = function(dom, num) &#123; dom.innerText = num;&#125;;var MS = 100;var domRoot = document.getElementById('root');domRoot.innerText = 0; // 0으로 초기값 설정.setTimeout(function() &#123; changeNum(domRoot, 1); setTimeout(function() &#123; changeNum(domRoot, 2); setTimeout(function() &#123; changeNum(domRoot, 3); setTimeout(function() &#123; changeNum(domRoot, 4); setTimeout(function() &#123; changeNum(domRoot, 5); setTimeout(function() &#123; changeNum(domRoot, 6); setTimeout(function() &#123; changeNum(domRoot, 7); setTimeout(function() &#123; changeNum(domRoot, 8); setTimeout(function() &#123; changeNum(domRoot, 9); setTimeout(function() &#123; changeNum(domRoot, 10); &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS)&#125;, MS); 코드가 보기 좋은가?이를 위한 대안으로 ES2015에 나온 Promise를 써보자.예제 보기 12345678910111213141516171819202122232425262728293031323334353637383940// promise 함수는 콜백 함수를 매개변수로 받아서 Promise 객체를 반환한다. // 그 Promise 객체는 매개변수로 받은 콜백 함수를 실행한다.const promise = cb =&gt; new Promise(res =&gt; &#123; // 요 res 위치에 앞으로 실행할 콜백 함수가 들어온다고 생각하면 된다. cb(res);&#125;);// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.const changeNum = (dom, num) =&gt; dom.innerText = num;// promise 함수에 전달할 콜백 함수.// 비동기 함수인 setTimeout을 동기식으로 실행시켜주게 바꾼 코드이다.const syncSetTimeout = (cb, ms, promiseCb) =&gt; setTimeout(() =&gt; &#123; cb(); // 함수 마지막에 이 콜백 함수는 위에 promise 함수의 cb(res) 요 부분이 실행되는 거라고 보면 된다. promiseCb();&#125;, ms);const MS = 100;const domRoot = document.getElementById('root');domRoot.innerText = 0; // 0으로 초기값 설정.promise( // promise 함수의 콜백으로 (동기식으로 바꾼) 비동기 함수가 들어가게 된다. syncSetTimeout.bind(null, // 매개변수로 콜백 함수를 넘겨줘야하기에 bind 함수 사용. // 콜백함수로 dom에 숫자를 렌더링하는 changeNum 함수 실행 changeNum.bind(null, domRoot, 1), MS))// 요 then을 타고 cb(res) 요 안으로 계속해서 함수를 침투시킨다고 생각하면 된다.// 그렇게 침투시켜서 콜백 함수 피라미드와 같은 효과를 내는 거다..then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 2), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 3), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 4), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 5), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 6), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 7), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 8), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 9), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 10), MS))); 뭐 썩 보기 좋은 건 아니지만 콜백 함수 지옥에 비하면 훨씬 봐주기가 좋아졌다.하지만 숫자를 1~10이 아닌 100까지 표현해야한다면…?저걸 100줄을 쓰고 있어야한다.그럼 이제 남은 방안은 ES2017의 async/await가 있다!예제 보기 12345678910111213141516171819202122232425262728293031323334353637// promise 함수는 콜백 함수를 매개변수로 받아서 Promise 객체를 반환한다. // 그 Promise 객체는 매개변수로 받은 콜백 함수를 실행한다.const promise = cb =&gt; new Promise(res =&gt; &#123; // 요 res 위치에 앞으로 실행할 콜백 함수가 들어온다고 생각하면 된다. cb(res);&#125;);// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.const changeNum = (dom, num) =&gt; dom.innerText = num;// promise 함수에 전달할 콜백 함수.// 비동기 함수인 setTimeout을 동기식으로 실행시켜주게 바꾼 코드이다.// promiseCb는 promise 함수로부터 전달받은 콜백함수이다.const syncSetTimeout = (cb, ms, promiseCb) =&gt; setTimeout(() =&gt; &#123; cb(); // 함수 마지막에 이 콜백 함수는 위에 promise 함수의 cb(res) 요 부분이 실행되는 거라고 보면 된다. promiseCb();&#125;, ms);const MS = 100;const domRoot = document.getElementById('root');domRoot.innerText = 0; // 0으로 초기값 설정.(async() =&gt; &#123; // async는 함수이기 때문에 실행하려면 즉시 실행 함수를 써야한다. for(let i=1; i&lt;101;) &#123; // 반복문을 통해 1~100까지 반복하고 있다. // await 함수는 비동기 함수를 동기식으로 실행시키는 데 쓰이는 함수이다. // 내가 알기로는 Promise 없이는 죽도 밥도 안되는 것으로 알고 있다. await( promise( // promise 함수의 콜백으로 (동기식으로 바꾼) 비동기 함수가 들어가게 된다. syncSetTimeout.bind(null, // 매개변수로 콜백 함수를 넘겨줘야하기에 bind 함수 사용. changeNum.bind(null, domRoot, i++), // 콜백함수로 dom에 숫자를 렌더링하는 changeNum 함수 실행 MS) ) ); &#125;&#125;)(); 하지만 async/await와 Promise를 학습하는 것은 어느 정도 러닝 커브가 있다.한번 내가 만들어본 async-to-sync 라이브러리를 이용하여 바꿔보자.예제 보기1234567891011121314151617181920212223242526272829303132// 비동기 함수를 동기식으로 실행해주는 async-to-sync 모듈을 로드하자.import ats from 'async-to-sync';// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.const changeNum = (dom, num) =&gt; dom.innerText = num;// 기본적으로 async-to-sync 모듈은 위 async/await + Promise를 짬뽕한 라이브러리다.// 비동기 함수를 동기 함수로 바꾸는 방법은 위의 예제와 같다.// 함수 매개변수에 promise 함수에서 전달받은 promiseCb를 추가하고, 함수 마지막 부분에 그 콜백 함수를 실행시키면 된다.// promise 함수에 전달할 콜백 함수.// 비동기 함수인 setTimeout을 동기식으로 실행시켜주게 바꾼 코드이다.const syncSetTimeout = (cb, ms, promiseCb) =&gt; setTimeout(() =&gt; &#123; cb(); // 함수 마지막에 이 콜백 함수는 위에 promise 함수의 cb(res) 요 부분이 실행되는 거라고 보면 된다. promiseCb();&#125;, ms);const arrAsync = []; // async-to-sync는 비동기 함수들이 담겨있는 배열을 매개변수로 받아서 실행시킨다.const MS = 100;const domRoot = document.getElementById('root');domRoot.innerText = 0; // 0으로 초기값 설정.for(let i=1; i&lt;101;) &#123; // 반복문을 통해 1~100까지 반복하고 있다. arrAsync.push( // 배열에 비동기 함수들을 하나씩 담고 있다. syncSetTimeout.bind(null, // 매개변수로 콜백 함수를 넘겨줘야하기에 bind 함수 사용. changeNum.bind(null, domRoot, i++), // 콜백함수로 dom에 숫자를 렌더링하는 changeNum 함수 실행 MS) );&#125;ats(arrAsync); // 배열에 담은 비동기 함수들을 한 번에 실행시키고 있다. 더 쉬운 방법역시 구글링을 해보니 더 쉬운 방법이 존재하였다.왜 이런 뻘짓을 했는지…1234567891011121314151617181920let current = 0; // 현재 숫자// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.// 외부에 있는 변수를 건드리므로 좋지는 않지만 어쩔 수 없다.const changeNum = (dom) =&gt; dom.innerText = ++current;// setTimeout 말고 setInterval이 더 간결하다.const SetInterval = (cb, ms) =&gt; setInterval(() =&gt; &#123; if(current &gt;= 100) return clearInterval(SetInterval); cb();&#125;, ms);const MS = 100;const domRoot = document.getElementById('root');domRoot.innerText = 0; // 0으로 초기값 설정.// 이 함수를 실행할 때는 current가 1이 되므로 계속해서 1로 고정하게 된다. // 그래서 부득이하게 콜백 함수 안에서 외부 변수를 불러오게 했다.SetInterval(changeNum.bind(null, domRoot), MS);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"promise","slug":"promise","permalink":"http://perfectacle.github.io/tags/promise/"},{"name":"ES6+","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"async","slug":"async","permalink":"http://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"http://perfectacle.github.io/tags/await/"},{"name":"callback","slug":"callback","permalink":"http://perfectacle.github.io/tags/callback/"}]},{"title":"(자작) async-to-sync (자바스크립트 비동기 함수 헬퍼)","slug":"async-to-sync","date":"2017-05-01T03:47:00.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2017/05/01/async-to-sync/","link":"","permalink":"http://perfectacle.github.io/2017/05/01/async-to-sync/","excerpt":"","text":"async-to-syncasync-to-sync는 자바스크립트 비동기 함수를 동기 함수로 바꿔주는 헬퍼 함수이다.async/await는 물론 Promise를 몰라도 된다!! npm github 왜 async-to-sync를 만들었는가?드디어 async/await가 ES2017에 추가 되었다(아직 최종 스펙이 나온 건 아니지만).async/await는 자바스크립트 비동기 함수를 동기 함수로 바꿔주는 기능을 한다.하지만 여전히 사용하기가 어렵고, 또한 ES2015의 Promise를 알고 있다는 전제 하에 사용이 가능하다.그래서 비동기 함수를 동기 함수로 만들 때 사용하기 편하려고 만들었다. 시작하기설치npm1npm i -S async-to-sync yarn1yarn add async-to-sync 사용법만약 타겟 브라우저/노드의 async/await 및 Promise 지원 여부를 모른다면 아래 링크를 확인하자.ECMAScript 6 compatibility table | PromiseNode.js ES2015/ES6 | PromiseECMAScript 2016+ compatibility table | asyncNode.js ES2017 support | async주의!async-to-sync는 babel-polyfill을 포함하지 않았다.따라서 babel-polyfill을 사용해야한다면 설치를 하자.npm1npm i -S babel-polyfill yarn1yarn add babel-polyfill 혹은 CDN을 이용하면 된다.아래 구구절절한 사용 방법 대신 빠르게 사용 방법을 익히고 싶다면 examples를 참조하자. async-to-sync 모듈을 불러오는 방법웹팩async/await &amp; Promise 지원 브라우저인 경우1import ats from 'async-to-sync'; async/await &amp; Promise or ES2015 미지원 브라우저인 경우babel-polyfill 사용이 필수이다.또한 async-to-sync 모듈을 불러오기 전에 babel-polyfill을 불러와야만 한다.만약 바벨과 같은 트랜스파일러를 쓰지 않는다면, ES2015 문법 사용은 지양하자. (MS 진영은 암담하기에…)12import 'babel-polyfill';import ats from 'async-to-sync/module/no-es2017'; 브라우저 (CDN은 지원 예정이니 잠시만 기다리자!)async/await &amp; Promise 지원 브라우저1&lt;script src=\"node_modules/async-to-sync/browser/es2017/index.min.js\"&gt;&lt;/script&gt; async/await &amp; Promise or ES2015 미지원 브라우저babel-polyfill 사용이 필수이다.또한 async-to-sync 모듈을 불러오기 전에 babel-polyfill을 불러와야만 한다.만약 바벨과 같은 트랜스파일러를 쓰지 않는다면, ES2015 문법 사용은 지양하자. (MS 진영은 암담하기에…)12&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.23.0/polyfill.min.js\"&gt;&lt;/script&gt;&lt;script src=\"node_modules/async-to-sync/browser/no-es2017/index.min.js\"&gt;&lt;/script&gt; Node.jsasync/await &amp; Promise를 지원할 때만약 import 문법을 쓰고 싶다면 바벨과 같은 트랜스파일러를 이용하자.1const ats = require('async-to-sync'); In async/await &amp; Promise or ES2015 not support Nodebabel-polyfill 사용이 필수이다.또한 async-to-sync 모듈을 불러오기 전에 babel-polyfill을 불러와야만 한다.만약 import 문법을 쓰고 싶다면 바벨과 같은 트랜스파일러를 이용하자.12require('babel-polyfill');const ats = require('async-to-sync/module/no-es2017'); 어떻게 쓰는가비동기 함수에는 몇 가지 종류가 있다. setTimeout(or setInterval) 1234567891011var a = function() &#123; setTimeout(function() &#123; console.log(123); &#125;, 2000);&#125;;var b = function(b) &#123; setTimeout(function() &#123; console.log(b); &#125;, 1000);&#125;; AJAX(Asynchronous Javascript And XML)bluebird, axios, jQuery slim과 같은 써드 파티들을 사용해도 된다.XHR(XMLHttpRequest)이나 fetch를 쓸 때는 Promise를 써야한다.then 메소드는 성공 콜백 함수와 같고, catch 메소드는 실패 콜백 함수와 같다.주의!몇몇 AJAX 요청은 IE9에서 문제가 되지만 이것은 async-to-sync의 문제가 아니다.아래 링크를 참조하자. Can I Use Cross-Origin Resource Sharing? IE9 jQuery AJAX with CORS returns “Access is denied” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var fallback = function(e) &#123; alert('Error: ' + e);&#125;;var xhr = function(url, method) &#123; method = method || 'get'; return new Promise(function(res, rej) &#123; var xhr = new XMLHttpRequest(); xhr.open(method, url, true); xhr.responseType = \"json\"; xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful res(xhr.response); &#125; else &#123; rej(xhr.status); &#125; &#125; &#125;; xhr.send(); &#125;);&#125;;var _fetch = function(url, method, headers, body) &#123; method = method || 'get'; headers = headers || null; body = body || null; return fetch(url, &#123; method, headers, body &#125;).then(function(res) &#123; return res.json(&#123;&#125;); &#125;);&#125;;var c = function(url) &#123; xhr(url).then(function(data) &#123; console.log(data); &#125;).catch(function(e) &#123; fallback(e) &#125;);&#125;;var d = function(url) &#123; _fetch(url).then(function(data) &#123; console.log(data); &#125;).catch(function(e) &#123; fallback(e) &#125;);&#125;; 주의!다음의 규칙들을 따라서 함수를 재작성하자. 함수의 파라미터에 콜백 함수를 추가해주자. 비동기 함수 맨 마지막에 콜백 함수를 실행해주자. 12345678910111213141516171819202122232425262728293031323334// 모든 비동기 함수마다 콜백 함수를 파라미터로 추가해줘야한다.var a = function(cb) &#123; setTimeout(function() &#123; console.log(123); // 비동기 함수의 맨 마지막에는 콜백 함수를 반드시 실행해줘야한다. cb(); &#125;, 2000);&#125;;// 콜백 함수는 파라미터 제일 끝 부분에 추가해주자.var b = function(b, cb) &#123; setTimeout(function() &#123; console.log(b); cb(); &#125;, 1000);&#125;;var c = function(url, cb) &#123; xhr(url).then(function(data) &#123; console.log(data); cb(); &#125;).catch(function(e) &#123; fallback(e) &#125;);&#125;;var d = function(url, cb) &#123; _fetch(url).then(function(data) &#123; console.log(data); cb(); &#125;).catch(function(e) &#123; fallback(e) &#125;);&#125;; 진짜 사용 방법ats(Array arrAsync[, Function fallback]) arrAsync의 타입은 배열이다.이 배열은 비동기 함수들을 포함하고 있다.이 함수들은 동기적으로 실행될 것이다. fallback의 타입은 함수이며, 필수 사항이 아니다.이 함수는 에러 발생시 실행되며, 그 이후에 실행될 함수들의 실행을 모두 멈춰버린다. 123456789101112131415161718var arrUrl = [ 'https://perfectacle.github.io/mock/test.json', 'https://perfectacle.github.io/mock/test2.json'];var arrAsync = [ a, // 인자를 넘겨주거나 this 값을 바인딩해야할 경우 bind 메소드를 사용하면 된다. c.bind(null, arrUrl[0]), // 물론 인자를 넘길 때 ES2015의 arrow function을 사용해도 된다. // 하지만 이 때는 콜백 함수까지 같이 매개변수 및 인자로 넘겨줘야한다. cb =&gt; b(2, cb), a, cb =&gt; d(arrUrl[1], cb), b.bind(null, 33)];ats(arrAsync, fallback); 지원하는 플랫폼 Latest ✔ Latest ✔ 9+ ✔ 6+ ✔","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"자작","slug":"기타/자작","permalink":"http://perfectacle.github.io/categories/기타/자작/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Promise","slug":"Promise","permalink":"http://perfectacle.github.io/tags/Promise/"},{"name":"async","slug":"async","permalink":"http://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"http://perfectacle.github.io/tags/await/"}]},{"title":"(자알쓰) Scope Part. 1","slug":"js-003-scope","date":"2017-04-26T15:14:47.000Z","updated":"2017-05-20T11:51:16.000Z","comments":true,"path":"2017/04/27/js-003-scope/","link":"","permalink":"http://perfectacle.github.io/2017/04/27/js-003-scope/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 세 번째 시리즈는 Scope(스코프)를 주제로 진행하겠다. Scope? 스코프?흔히 변수의 Scope라고 부른다. Scope(무엇을 하거나 이룰 수 있는) 기회; (주제・조직・활동 등이 다루는) 범위 후자의 범위라고 보면 될 것 같다.즉 변수의 Scope는 변수를 사용할 수 있는 범위가 된다.ES5까지는 함수 단위의 스코프를 가진다.백문이 불여일견, 일단 코드로 보고 이해하자.1234567891011121314151617// 전역 공간은 스코프를 공유한다.var a = 1;var b = 2;if(a &lt; b) &#123; var i = 3;&#125; else &#123; // 사실 전역에 있는 변수는 공유되기 때문에 여기서는 var를 생략해도 된다. var i = 4;&#125;var c = function() &#123; // 함수 단위의 스코프가 시작됐다. var a = 5; var d = 6; console.log(a); // 5, 현재 스코프에 a가 있기 때문에 현재 스코프에 있는 a를 출력한다.&#125;console.log(i); // 3, 함수 단위의 스코프이기 때문에 같은 전역 공간에 있다고 간주해서 변수를 공유하기 때문에 사용 가능하다.c();console.log(d); // Uncaught ReferenceError: d is not defined, 함수 단위의 스코프이기 때문에 함수에서 쓰인 변수는 함수에서만 사용할 수 있다. 이것 또한 전통 방식의 자바, C와 큰 차이점 중 하나이다.기존 프로그래밍 언어들은 블록 단위의 스코프라고 해서 if 문도 별도의 스코프를 가졌는데자바스크립트에는 쌩뚱맞은 함수 단위의 스코프라는 게 존재한다.왜 이렇게 만들었는지 나도 모르겠다. Scope Chaining(스코프 체이닝) Chaining체이닝, 연쇄(적 처리) 뭔가를 연쇄적으로 처리하는 내용이다.이번에도 코드를 봄으로써 이해해보자.12345678910111213141516171819var a = 1;var b = function() &#123; // 외부 함수 스코프(b)의 시작 var c = 2; var d = function() &#123; // 내부 함수 스코프(d)의 시작 // 1. 현재 스코프(d)에는 a란 변수가 없다. // 2. 스코프 체인을 타고 스코프 b로 올라간다. // 3. 스코프 b에도 a란 변수가 없다. // 4. 스코프 체인을 타고 전역 스코프로 올라간다. // 5. 전역 스코프에는 a란 변수가 있으므로 그 a를 출력한다. console.log(a); // 1 // 1. 현재 스코프(d)에는 c란 변수가 없다. // 2. 스코프 체인을 타고 스코프 b로 올라간다. // 3. 스코프 b에도 c란 변수가 있으므로 그 c를 출력한다. console.log(c); // 2 &#125; d(); // 내부 함수 d를 호출&#125;b(); // 함수 b를 호출 하지만 이 스코프 체이닝은 변수 사용에서만 존재하는 게 아니다.변수 선언에 있어서도 스코프 체이닝이 발생할 수 있다.1234567891011121314151617181920212223242526272829303132333435363738394041var b = 1;var c = function() &#123; // 외부 함수 스코프(c)의 시작 var d = 2; var e = function() &#123; // 내부 함수 스코프(e)의 시작 // 변수의 선언을 var 없이 하면 스코프 체이닝이 발생한다. // 1. 현재 스코프(e)에는 d라는 변수가 없다. // 2. 스코프 체인을 타고 상위 스코프인 c로 이동한다. // 3. 스코프 c에는 변수 d가 있으므로 그 변수에 3을 할당한다. d = 3; // 1. 현재 스코프(e)에는 d라는 변수가 없다. // 2. 스코프 체인을 타고 상위 스코프인 c로 이동한다. // 3. 스코프 c에는 변수 b가 없다. // 4. 스코프 체인을 타고 상위 스코프인 전역 스코프로 이동한다. // 5. 전역 스코프에는 변수 b가 있으므로 그 변수에 4를 할당한다. b = 4; // 1. 현재 스코프(e)에는 d라는 변수가 없다. // 2. 스코프 체인을 타고 상위 스코프인 c로 이동한다. // 3. 스코프 c에는 변수 b가 없다. // 4. 스코프 체인을 타고 상위 스코프인 전역 스코프로 이동한다. // 5. 전역 스코프에는 변수 f가 없으니 새로 만들고 5를 할당한다. f = 5; &#125; // 똥 싸기 전에는 2를 가지고 있다가 console.log(d); // 2 e(); // 내부 함수 e를 호출 // 똥싸고 나니 3으로 변하였다. console.log(d); // 3&#125;// 똥 싸기 전에는 1을 가지고 있고 f는 벌써 호이스팅 처리가 전부 끝난 건지 5가 할당되어있다.console.log(b); // 1console.log(f); // 5c(); // 함수 c를 호출// 똥싸고 나니 3과 5라는 변수로 바뀌었다.console.log(b); // 4console.log(f); // 5 이렇게 var를 쓰지 않고 변수를 선언하면 상위 스코프로 체인을 타고 해당 변수를 찾아 여정을 떠난다.전역 스코프에도 해당 변수가 없다면 새로 만들게 된다.이렇게 var를 쓰지 않고 변수를 선언하다보면 변수의 스코프가 뒤죽박죽이 되어버린다.따라서 이렇게 코딩하는 걸 사전에 방지하고 오류를 뿜어주는 게 존재한다. strict modeES5에서 새로 생긴 모드다.이 포스트에서는 변수 선언에 대해서만 다룰테니 자세한 내용은 아래 링크를 확인하자.Strict mode - JavaScript | MDN코드의 문법을 좀 더 깐깐하게 검사해서 오류를 내뿜어 개발자로 하여금 의도한 바대로 실행 결과를 도출하게끔 하는 모드이다.나는 사용을 권장한다.혹시 IE8 같은 경우에는 지원하지 않아서 오류를 뿜지 않을까 걱정이라면 붙들어 메도 된다.일단 코드로 보자.1234567891011121314'use strict';// 이렇게 전역 스코프 상단에 저 구문을 넣어주거나 // 사용하려는 함수 바디 상단에만 넣어주면 된다. // 미지원 브라우저는 그냥 문자열로 인식하고 오류를 뿜지 않는다.var a = 1;var b = function() &#123; // 얘는 전역 스코프에 존재하는 녀석이어서 그 변수를 덮어씌우면 되니 오류를 뿜지 않는다. a = 1; // 스코프 체인 상에 존재하지 않는 변수를 var 없이 선언하면 오류를 뿜게 된다. d = 2; // Uncaught ReferenceError: d is not defined&#125;// 스코프 체인 상에 존재하지 않는 변수를 var 없이 선언하면 오류를 뿜게 된다. c = 3; // Uncaught ReferenceError: c is not definedb(); 아주그냥 난장판인 스코프하나의 html 파일에는 여러가지 자바스크립트 파일이 들어가게 된다.그럼 2개의 자바스크립트 파일을 썼다고 가정해보고 코드를 보자.12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"a.js\"&gt;&lt;/script&gt; &lt;script src=\"b.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"a\"&gt;a&lt;/button&gt;&lt;button id=\"b\"&gt;b&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; a.js를 작성해보자.12'use strict';var num = 1; b.js를 작성해보자.1234567891011window.onload = function() &#123; 'use strict'; var btnA = document.getElementById('a'); var btnB = document.getElementById('b'); btnA.onclick = function() &#123; console.log(num); &#125;; btnB.onclick = function() &#123; console.log(num); &#125;&#125;; 버튼을 누르면 1이 출력된다.그러다가 내 부사수 마니똘이 추가 작업을 하다가 아래와 같이 c.js를 만들고 html에 추가하였다.1234'use strict';// 코드 블라블라var num = 2;// 코드 블라블라 그리고 b.js 보다 먼저 처리해야할 로직이 있어서 스크립트를 아래와 같은 순서로 로딩하게 하였다.1234&lt;script src=\"a.js\"&gt;&lt;/script&gt;&lt;!-- 요 사이에 내 부사수가 작성한 c.js를 로딩시켰다. --&gt;&lt;script src=\"c.js\"&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt; 그리고 나서 다시 버튼들을 클릭해보자.그럼 내가 기대했던 1이 아닌 부사수가 작성한 2가 찍히게 된다.사실 위 3가지 js 파일을 아래와 같이 바꿀 수도 있다.123456789101112131415161718192021'use strict';// 내가 작성한 a.jsvar num = 1;// 내 부사수가 작성한 c.js// 블라블라var num = 2;// 블라블라// 내가 작성한 b.jswindow.onload = function() &#123; 'use strict'; var btnA = document.getElementById('a'); var btnB = document.getElementById('b'); btnA.onclick = function() &#123; console.log(num); &#125;; btnB.onclick = function() &#123; console.log(num); &#125;&#125;; num이 더 뒤에 할당된 2가 찍히게 되는 것이다.자바의 경우에는 파일(클래스) 별로 별도의 스코프가 존재했는데, js는 그렇지 못하다.이 또한 기존에 다른 언어 개발자들을 미치게 하는 요인 중에 하나다. 마치며…글이 길어져서 일단 한 템포 끊어서 가야할 것 같다.다음 포스트에서는 ES2015+의 스코프를 다루고,그 다음에는 스코프의 한계를 극복한 모듈화에 대해 다뤄야할 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Scope","slug":"Scope","permalink":"http://perfectacle.github.io/tags/Scope/"}]},{"title":"(자알쓰) Hoisting","slug":"js-002-hoisting","date":"2017-04-26T14:25:29.000Z","updated":"2017-05-20T11:42:17.000Z","comments":true,"path":"2017/04/26/js-002-hoisting/","link":"","permalink":"http://perfectacle.github.io/2017/04/26/js-002-hoisting/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 두 번째 시리즈는 Hoisting(호이스팅)을 주제로 진행하겠다. Hoisting? 호이스팅?이 처음보는 단어는 뭐지 싶을 수도 있다. Hoisting끌어 올리기; 들어올려 나르기. 말 그대로 끌어올리는 것이다. 무엇을? 코드를!1console.log(qwer); // Uncaught ReferenceError: qwer is not defined 누구나 예상한 결과일 것이다.qwer이란 녀석은 선언된 적이 없으니 사용도 불가능한 것이다.하지만 아래 예제를 보자. 12345678910console.log(asdf); // undefined, 오류가 나질 않는다. 즉 프로그램이 뻗질 않는다.console.log(qwer); // undefinedconsole.log(zxcv); // function zxcv() &#123; console.log(456); &#125;var asdf = 'asdf';var qwer = function() &#123; console.log(111);&#125;;function zxcv() &#123; console.log(456);&#125; 전통적인 C언어나 자바와 같은 프로그래밍 언어로 개발하던 사람들이 이해하지 못하는 부분 중 하나가 바로 이거다.내가 선언하기 전에 사용된 변수, 즉 없는 변수인데 왜 갑자기 툭 튀어나와서undefined를 내뱉고 프로그램이 죽지 않는 거지?바로 호이스팅이 일어났기 때문이다.위의 코드는 아래와 같이 변환된다고 보면 된다.123456789101112var asdf;var qwer;function zxcv() &#123; console.log(456);&#125;console.log(asdf);console.log(qwer);console.log(zxcv);asdf = 'asdf';qwer = function() &#123; console.log(111);&#125;; 함수 선언문에서는 변수 없이 함수를 선언한 것이므로 전체 코드가 호이스팅 된다.하지만 함수 표현식은 변수 선언과 할당을 구분할 수 있으므로 선언 부분만 호이스팅이 일어났다.따라서 오류가 날 것으로 예상했던 코드가 예측한 대로 작동하질 않는다.오류를 최소화하려는 전략이었는지 모르겠지만 의도대로 코드가 작동하지 않는 것은 옳지 않다.소스 코드를 분석하다가도 본 적 없는 변수나 함수가 갑자기 튀어나오면 요 놈이 어디서 나온 녀석인지 혼란스럽게 하기 마련이다.그래서 나는 차라리 오류를 안 나게 호이스팅을 하는 것보다 오히려 오류를 내는 쪽이 더 안전하게 코드를 설계하는 건 아닐까 싶다.따라서 사용할 변수와 함수는 최소한 사용하기 전에 미리 선언해야 의도한대로 코드가 동작한다고 확신을 가질 수 있다. ES2015+에서는?이렇게 짧게 끝내기 아쉬우니 ES2015+에서는 호이스팅이 어떻게 처리되는지 알아보자.일단 ES2015+에서는 변수를 선언할 때 const와 let으로 대신해서 쓴다.이에 대해서는 다른 포스트에서 자세히 다룰테니 일단은 그런 놈들이 있다고만 알자.그럼 똑같은 코드를 ES2015+ 식으로 작성해보자.1234console.log(asdf); // Uncaught ReferenceError: asdf is not definedconsole.log(qwer);const asdf = 'asdf';let qwer = 'qwer'; 1번 라인에서 오류가 나서 2번 라인은 실행도 못하고 바로 뻗어버린다.우리의 바람대로 호이스팅이 사라진 것 같다.과연 정말일까…? TDZ(Temporal Dead Zone)임시적 사각 지대, 변수가 임시로 죽어있는 공간이라고 이해하면 될 것 같다.뭔소린지 글로만 봐서는 모르니 코드를 통해서 보자.123456const asdf = 'asdf';const qwer = function() &#123; console.log(asdf); // Uncaught ReferenceError: asdf is not defined let asdf = 'qwer';&#125;qwer(); 호이스팅이 일어나지 않았다면 3번 라인에서는 ‘asdf’가 찍혀야 정상일 것이다.혹은 호이스팅이 일어났다면 undefined라도 찍혀야하는데 오히려 에러를 내뱉었다.이건 무슨 경우일까? 답은 바로 TDZ!위 코드를 다시 TDZ라는 것과 연관 지어서 풀어보겠다.123456789const asdf = 'asdf';const qwer = function() &#123; let asdf; // 사실 이렇게 변수 선언부가 호이스팅에 의해 스코프 상단으로 끌어올려진다. // 변수의 초기화 구문을 만나기 전까지 TDZ가 형성됨. console.log(asdf); // TDZ에서 해당 변수가 쓰였다면 에러를 발생! // 여기까지 TDZ. asdf = 'qwer';&#125;qwer(); TDZ는 변수 선언(호이스팅에 의해 스코프 상단으로 끌어올려진 부분)부터 변수의 할당을 만나기 전 부분까지 형성이 되는 구간인데이 TDZ에서는 해당 변수가 임시적으로 죽어있는 구역인데 이 구역에 해당 변수가 끼어들면서 오류가 발생하게 되는 것이다. 마치며…오늘 올린 호이스팅은 사실 스코프와 연관지어 생각해봐야 이해하기가 쉬운 부분이다.따라서 다음에 포스팅 할 예정인 스코프 포스트까지 꼭 보길 바란다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"},{"name":"Hoisting","slug":"Hoisting","permalink":"http://perfectacle.github.io/tags/Hoisting/"}]},{"title":"(자알쓰) ECMASCript? ES?","slug":"js-001-es","date":"2017-04-25T15:44:42.000Z","updated":"2017-08-09T06:16:11.000Z","comments":true,"path":"2017/04/26/js-001-es/","link":"","permalink":"http://perfectacle.github.io/2017/04/26/js-001-es/","excerpt":"","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 첫 번째 시리즈는 ECMAScript(이하 ES)를 주제로 진행하겠다. ES의 탄생 배경브라우저 전쟁 시절 개발자들은 몸살을 앓았다.넷 스케이프 사의 자바스크립트가 부러웠는지 사용자 층을 더 끌어내기 위해 MS의 IE 3에도 JScript라는 이름으로 자바스크립트를 탑재하였다.하지만 둘의 내용이 매우 달랐는지, 같은 기능을 구현하기 위해 개발자가 해야하는 일들이 더 많아졌다.날이 가면 갈 수록 사용자를 끌어내기 위해 서로 기능을 넣다보니 Javascript와 JScript는 날이 가면 갈 수록 달라지는 경향을 보였다.이에 대한 심각성을 파악하고, European Computer Manufacturers Association(ECMA, 현 ECMA International)에서는이러한 자바스크립트에 대한 표준을 내리게 된다.또한 ECMA에서는 자바스크립트의 표준만 내리는 게 아니라 다른 표준안도 정하기 때문에 그와 구분하기 위해 숫자를 붙였는데 262다.ECMA262라고 보인다면 아, 자바스크립트 표준 규격이구나라고 생각하면 될 것 같다. JS? ES?자바스크립트는 언어이고, ES는 스펙이다.IE8에서는 ES3 스펙을 준수한 거고, IE9에서는 ES5 스펙을 준수한 거다.그럼 우리가 여태까지 알고 있던 자바스크립트를 ES라고 불러야할까?나도 이 문제에 대해서는 아직도 잘 모르겠다.지금 내가 말할 뉘앙스대로라면 ES는 자바스크립트의 표준을 세운 언어라는 느낌이고,그냥 자바스크립트하면 비표준 언어라는 느낌이 많이 드는데 나는 아래와 같이 구분해서 부른다. 자바스크립트ES5까지의 내용을 나는 그냥 자바스크립트라고 부른다.ES3나 5의 특징을 설명해야할 때는 콕 찝어서 ES3다 뭐다 하고 부르지만,그렇지 않은 경우에는 그냥 자바스크립트라고 퉁쳐서 부른다.또한 많은 사람들이 생각하는 웹 브라우저에서 돌아가는 자바스크립트의 기준은 아래의 범주도 포함하는 것 같다.ES + DOM(Document Object Model) + BOM(Browser Object Model)DOM은 document.뭐시기~ 요런 애들이고 BOM은 window.머시기~(window를 생략하기도 한다.) 이런 애들이라고 알아두면 될 것 같다. ESES2015(a.k.a ES6)+나 ES3, 5의 특징과 같은 걸 콕 찝어 말할 때 ES라고 부른다.왜 ES2015 이상의 내용을 얘기할 때 ES를 쓰냐면 ES5와 ES2015 사이에 너무나 큰 변화가 있었기 때문이다.그래서 일반적으로 자바스크립트라고 알고 있는 ES5의 내용으로 사람들이 이해하지 않길 바라는 마음에 ES2015라고 구분해서 부르고 있다.또한 위에 자바스크립트에서도 언급 했 듯이 ES에는 DOM과 BOM을 포함하지 않는다는 점을 유념해둬야한다.즉 ES2015가 되건 2020이 되건 BOM과 DOM의 내용하고는 전혀 관련이 없다는 점을 알아둬야한다. ES3 (1999)대중적으로 많이 아는 그냥 자바스크립트라고 생각하면 될 것 같다.함수 단위의 스코프, 호이스팅, 모듈화 미지원, 프로토타입, 클로저 등등 자바스크립트의 기본적인 특징들이 들어있다.대부분의 브라우저에서 지원한다.IE8까지 크로스브라우징하는 환경이면 ES3를 쓰고 있다고 생각하면 된다. ES5 (2009)4는 너무 급변하는 내용이 있었던지 거절되고, 그 후에 점진적인 개선을 하고자 5가 나온 것으로 알고있다.기본적으로 IE9부터 본격적인 지원을 하지만 es5-shim을 사용하면 하위 버전에서도 특정 기능들을 지원해준다.5부터는 아래와 같은 내용들이 추가되었다. 배열배열과 관련해서 새로운 메소드들이 많이 생겼는데 대표적으로forEach, map, filter, reduce, some, every와 같은 순환 메소드들이 생겼다.이 메소드들은 개발자가 반복 횟수나 조건을 잘못 입력하는 등의 실수를 줄여주는 효과가 있다. 객체일단 눈에 띄는 점은 객체의 프로퍼티에 대한 설정을 할 수 있다는 것이다.객체를 생성/수정/복사하는 표준 메소드들(Object.create(), Object.defineProperty(), Object.freeze(), Object.assign() 등등)과 getter/setter 등등또한 Object.keys 메소드를 쓰면 for in 메소드도 대체할 수 있게 된다. strict 모드문법을 좀 더 깐깐하게 체크하는 모드이다.물론 이유없이 그러는 게 아니라 좀 더 코드를 안전하게(에러가 안 나게, 미연에 방지하고자) 등장했다.특징은 아래 링크를 통해 확인해보자.Strict mode - JavaScript | MDN bind() 메소드this를 강제로 bind 시켜주는 메소드이다. 실행 컨텍스트 내에 존재하는 Lexical Environment JSON(JavaScript Object Notation)과거 통신을 할 때 데이터를 XML 형태로 많이 주고 받았다.하지만 JSON이 좀 더 경량화 돼있는지 요새는 JSON이 대세다.JSON은 자바스크립트의 객체 리터럴과 생긴 건 유사한데 다음과 같은 차이점이 존재한다. 키는 무조건 쌍따옴표(“”)로 감싼 문자열이어야한다. 주석은 사용할 수 없다. 프로퍼티로 메소드는 불가능하다. 프로퍼티에서도 메소드의 사용이 불가능하다.통신을 위해 Object를 JSON으로 바꾸는 방법은 JSON.stringify(obj)이고, 자바스크립트 코드에서 사용하기 위해 JSON은 Object로 바꾸는 방법은 JSON.parse(json)이다. ES2015(ES6)원래는 ES6였는데 사람들이 끝자리인 6과 2016년을 연관짓는 습성 때문에 2016년에 나온 걸로 착각을 해서인지 ES2015로 바꾼 것 같다.그냥 갤럭시 노트 6가 7으로 바로 건너뛴 것처럼 ES도 그냥 건너뛰면 어떨까… 싶은 생각이 든다. (개인적으로 연도 다 붙이기 너무 귀찮다.)ES6 Harmony라고도 불리우는 것 같다.ES2015 들어서면서 다음과 같은 문제점들이 해결되었다. 호이스팅이 사라진 것 같은 효과 함수 단위 스코프에서 블록 단위 스코프로 변경 this를 동적으로 바인딩하지 않는 애로우 펑션 모듈화 지원 콜백 지옥의 구원자, Promise (ES6) ajax 위주의 promise 실습 (ES6) Promise에 파라미터를 넘겨서 사용해보자 Default, Rest 파라미터 해체 할당, Spread 연산자 템플릿 리터럴 클래스이 외에도 특징은 엄청나게 많아서 사람들이 이 부분에서 많은 장벽을 느끼는 것 같다.일단 브라우저(특히 MS 계역)에서 지원해주지 않는 경우가 많아바벨이라는 트랜스파일러를 써야하는데 바벨 웹 사이트 REPL에서도 즉시 변환이 가능하다.하지만 매번 번거롭게 하기 귀찮으니 바벨을 설치해야하는데… 바벨은 웹 브라우저가 아닌 노드 JS 위에서 돌아가고… 노드 JS에서 바벨을 설치하려면 NPM을 알아야하고… 또 모듈화를 사용하려면 웹팩과 같은 모듈 번들러를 사용해야하고… 이런 다양한 장벽 때문에 사람들이 ES2015를 겁내고 쉽사리 접근하지 못하는 경향도 있는 것 같다.하지만 공부를 위해서라면 바벨 없이도 크롬에서 돌리면 원활한 공부가 가능하고,모듈화 부분은 지원하는 브라우저가 없기 때문에 건너 뛰고 공부해야할 것 같다. ES2015+현재 ES2016이 작년 6월 경에 발표됐다.ES2017은 조만간 발표될 예정이다.ES2015에서 너무 내용이 많이 바뀌어 겁을 먹었다면 여기서부터는 크게 겁 낼 필요 없는 게 그렇게 큰 내용이 변하지 않았다는 점이다.3에서 5까지 10년, 5에서 6까지 7년이라는 공백 때문에 엄청난 변화들이 있거나 했는데이제는 매년 표준을 제정하면서 그런 혼란을 줄일 예정인 것 같다.또한 이후에 나올 ES를 통칭해서 ES.Next라고도 부르는 것 같다. 마치며…ES3 ~ ES.Next까지 많은 내용을 다룬 것 같은데 너무 ES2015+를 어려워하지 않았으면 좋겠다.막상 공부해보면 새로운 특성도 있지만, 기존에 사용하던 패턴들을 조금씩 변경하는 내용들이 많고,오히려 복잡하게 구현하던 것을 간편하게 구현할 수 있게 만들어줘서 더 편한 것 같다.다음 시간에는 호이스팅(Hoisting)과 함수 단위의 스코프에 대해서 알아보도록 하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/자알쓰/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"http://perfectacle.github.io/tags/자알쓰/"}]},{"title":"ES6 Generator","slug":"ES6-Generator","date":"2017-04-22T08:17:14.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2017/04/22/ES6-Generator/","link":"","permalink":"http://perfectacle.github.io/2017/04/22/ES6-Generator/","excerpt":"","text":"들어가기에 앞서이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.(ES6) Interface와 (ES6) Symbol, (ES6) Iterator에 대한 내용은 링크를 참조하도록 하자. 사용 사례이 사용 사례가 전부는 아니겠지만, 제너레이터는 이터레이터를 구현할 때 좀 더 쉽게 만들어준다.우리는 지난 포스트에서 다음과 같이 배열의 요소를 거꾸로 사용하는 이터레이터를 구현해보았다.12345678910111213141516171819202122232425262728// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorResultObject = function(idx) &#123; return &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 value: this.slice(-idx)[0], // value 값이 반환됨. done: --idx === this.length &#125;;&#125;;// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorObject = function() &#123; let idx = 0; return &#123; // Iterator 인터페이스를 준수한 객체를 반환 next: () =&gt; &#123; // 이 next 함수 안에 있는 내용은 매번 실행됨. // IteratorResult 인터페이스를 준수한 객체를 반환 return makeIteratorResultObject.call(this, ++idx); &#125; &#125;&#125;;const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function() &#123; // 요 함수에 있는 내용은 한 번만 실행됨. // Iterator 인터페이스를 준수한 객체를 반환 return makeIteratorObject.call(this);&#125;;const arr2 = [...arr]; // [0, undefined, 3, 2, 1] IteratorResult 객체, Iterator 객체, Iterable 객체, 이 3개를 다 구현하기란 매우 귀찮고 어렵다.따라서 제너레이터를 사용하면 아래와 같이 바꿀 수 있게 된다.1234567891011121314151617181920212223242526const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function*() &#123; // Iterator 인터페이스를 준수한 객체를 반환 for(let i=0, length=this.length; i&lt;length; i++) yield this.slice(-i)[0];&#125;;// 반복문의 횟수를 오타낼 염려가 있으니 아래와 같이도 할 수 있다.// arr[Symbol.iterator] = function*() &#123;// yield* this.map(function(v, idx)&#123;// return this.slice(-(++idx))[0];// &#125;, this);// &#125;; const gen = arr[Symbol.iterator]();console.dir(gen); // 제너레이터 함수의 실행 결과는 Iterator 객체를 반환한다.console.log(gen.next()); // &#123; value: 0, done: false &#125;console.log(gen.next()); // &#123; value: undefined, done: false &#125;console.log(gen.next()); // &#123; value: 3, done: false &#125;console.log(gen.next()); // &#123; value: 2, done: false &#125;console.log(gen.next()); // &#123; value: 1, done: false &#125;console.log(gen.next()); // &#123; value: undefined, done: true &#125;for(const a of arr) console.log(a); // 0 undefined 3 2 1 마법과도 같은 일이 일어났다.그럼 이 마법같은 일을 낱낱이 파헤쳐보자. Generator일단 두 가지 케이스가 눈에 띄었다.function 키워드 뒤의 *와 yield.funcion 키워드 뒤의 *는 이 함수가 제너레이터 함수라는 것을 명시해주는 기능을 한다.그리고 그 일반 함수가 아닌 제너레이터 함수에서는 yield 키워드를 쓸 수 있다.이 yield는 return과 마찬가지로 값을 반환하는 기능을 하는데, 함수는 종료시키지 않는다.next를 호출할 때마다 yield 구문까지의 코드를 실행하고 yield 값을 반환하게 되는 것이다.그리고 실행 컨텍스트를 어디선가 물고 있어서 코드의 흐름과 상관없이 next를 호출할 때마다 그 실행 결과를 보장받게 되는 것이다.몇 가지 예제들을 통해 그 특성들을 알아보자.123456789101112131415161718192021222324252627282930313233343536const gen = function*() &#123; console.log('내가 실행됐니?'); yield 1; const b = yield 3; console.log(b); const c = yield 4; console.log(c); return 4; yield 5;&#125;;let a = gen(); // 이터레이터 객체를 반환// 내가 실행됐니?가 출력되고, 1을 반환console.log(a.next());// b에 yield 3이 할당되고, 3이 반환됨.console.log(a.next());// 하지만 yield 3 자체는 undefined를 반환해서 b에는 undefined가 찍힘.// 그리고 c에 yield 4가 할당되고, 4가 반환됨.console.log(a.next());// 원래 c에는 yield 4가 할당돼 undefined가 찍혀야하지만, next에 매개변수를 주면 c에 새로운 값을 할당하게 됨.// 따라서 9를 출력.console.log(a.next(9));// return 이후로는 닿질 못한다.console.log(a.next()); // &#123; value: undefined, done: true &#125;console.log('-----------------');// 이터레이터 내부의 요소(yield)들을 모두 소모했으므로 재충전(?)a = gen();// 이터레이터이므로 for of 구문을 사용할 수 있다. // 반환 값으로는 yield에 지정한 값들이 반환된다.for(const v of a) console.log(v); yield는 모든 타입을 반환할 수 있다.1234567891011121314151617181920212223242526272829303132333435const gen = function*() &#123; const a = &#123;obj: 2&#125;; yield a; yield () =&gt; console.log(7777777); yield* [1, 2, 3, 4]; yield* (function*() &#123;yield 5; yield 6;&#125;)(); yield function*() &#123;yield 7; yield 8;&#125;;&#125;;// 제너레이터 함수의 실행 결과로 이터레이터 객체가 a에 담기게 된다.const a = gen();// a.next()까지 하게 되면 IterableResult 객체인 &#123; value: &#123; obj: 2 &#125;, done: false &#125;가 반환된다.// 실제 for of와 같은 문법에서도 value 값을 반환하게 되는 것이다.console.log(a.next().value);// 반환값이 함수이니 반환된 함수를 실행하니 7777이 콘솔 로그에 찍힘.console.log(a.next().value());// yield에도 *(asterisk)를 찍어줄 수 있는데 yield를 쪼갠다고 보면 된다.console.log(a.next().value); // 1console.log(a.next().value); // 2console.log(a.next().value); // 3console.log(a.next().value); // 4// 그 다음엔 제너레이터 함수를 즉시 실행했으므로 이터레이터 객체가 반환된다.// 그 반환된 이터레이터 객체를 *을 써서 또 쪼갰다.console.log(a.next().value); // 5console.log(a.next().value); // 6// 이번엔 제너레이터 함수의 실행 결과가 아닌 함수 자체를 리턴했으므로 쪼갤 수가 없다.// 따라서 그 함수를 실행한 이터레이터 객체를 b에 따로 담아서 쪼개줘야한다.const b = a.next().value();console.log(b.next().value); // 7console.log(b.next().value); // 8 제너레이터 함수의 스코프를 벗어나는 공간에 yield를 쓸 수 없다.12345const gen = function*() &#123; const arr = [1, 2, 3]; // 콜백 함수는 제너레이터 함수가 아니므로 yield를 쓸 수 없다. arr.forEach(v =&gt; yield v);&#125; 제너레이터를 통해 비동기 함수를 제어하는 방법이 있지만 ES2017의 async와 await를 적극 활용하기 바란다. (ES6+) ajax를 위한 fetch와 async/await (ES6+) 비동기 함수를 깔끔하게 처리해보자. 참조 링크 [es6] GDG 2016 발표자료 function* - JavaScript | MDN ES6 In Depth: 제너레이터(Generator) ★ Mozilla 웹 기술 블로그 ES6 Generator with Aysnc | programmist","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"Interface","slug":"Interface","permalink":"http://perfectacle.github.io/tags/Interface/"},{"name":"Symbol","slug":"Symbol","permalink":"http://perfectacle.github.io/tags/Symbol/"},{"name":"Iterator","slug":"Iterator","permalink":"http://perfectacle.github.io/tags/Iterator/"},{"name":"Generator","slug":"Generator","permalink":"http://perfectacle.github.io/tags/Generator/"}]},{"title":"(ES6) Iterator","slug":"ES6-Iterator","date":"2017-04-22T07:17:14.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2017/04/22/ES6-Iterator/","link":"","permalink":"http://perfectacle.github.io/2017/04/22/ES6-Iterator/","excerpt":"","text":"들어가기에 앞서이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.(ES6) Interface와 (ES6) Symbol에 대한 내용은 링크를 참조하도록 하자.또한 이 글을 다 읽고 나서 ES6 Generator도 읽어보자.Iterator는 반복자란 뜻을 가지고 있으며, 대충 반복과 관련된 용어라는 것만 알고 글을 읽어보자. 다음에 나오는 예제는 이터레이터를 쓴다.ES6에서는 다음과 같은 문법에서 알게 모르게 이터레이터를 쓰고 있다.123456789101112131415// 1. for offor(const num of [1, 2, 3, 4]) console.log(num); // 1 2 3 4// 2. spread operatorconst arr = [1, 2, 3];const arr2 = [...arr]; // shallow copy// 3. destructuring assignmentconst str = 'asdf';const [a, ...b] = str;console.log(a, b); // 'a', ['s', 'd', 'f']// 4. rest parameterconst func = (a, ...args) =&gt; console.log(a, args);func(1, 2, 3, 4, 5); // 1, [2, 3, 4, 5] 위 문법은 이터러블한 객체(Iterable Interface를 준수한 객체, (Typed )Array, String, (Weak)Map/Set)만 쓸 수 있는 문법이다.1console.log(Array.prototype); 반면에 Object는 이터러블한 객체가 아니다.1console.dir(Object.prototype); Symbol.iterator() 메소드를 눈 씻고 찾아볼 수가 없다.따라서 for of와 같은 문법을 쓸 수 없다.하지만 현재 object에도 spread operator와 destructuring assignment를 쓸 수 있게 한 제안이 Stage-3까지 올라가 있어서바벨의 transform-object-rest-spread나 Stage 3 preset을 쓰면 된다.그럼 이제 이터러블과 이터레이터가 뭔지 알아보자. Iterator 관련 Interface타입스크립트의 인터페이스 표기법을 사용하고 있으므로 타입스크립트에 익숙한 사람은이미지를 보자마자 무슨 의미인지 알 수 있을 것이다. Iterable Interface인터페이스이기 때문에 객체가 가져야하는 키와 그 키가 가져야하는 값을 명시하고 있다. 가져야하는 키: Symbol.iterator(well-known symbol 중 하나) 키(Symbol.iterator): 함수인데 반환 값은 Iterator 인터페이스를 준수한 객체가 오면 된다.123456// Iterable 인터페이스를 준수한 obj 객체const IterableObject = &#123; [Symbol.iterator]() &#123; return IteratorObject; &#125;&#125; Iterator Interface인터페이스이기 때문에 객체가 가져야하는 키와 그 키가 가져야하는 값을 명시하고 있다. 가져야하는 키: next라는 키를 가진다. 키(next)가 가져야할 값: 함수인데 반환 값은 IteratorResult 인터페이스를 준수한 객체이다. 123456// Iterator 인터페이스를 준수한 IteratorObject 객체.const IteratorObject = &#123; next() &#123; return IteratorResultObject; &#125;&#125; IteratorResult Interface인터페이스이기 때문에 객체가 가져야하는 키와 그 키가 가져야하는 값을 명시하고 있다. 가져야하는 키: value와 done이라는 키를 가진다. 키(value, done)가 가져야할 값: value에는 어떤 값이든 와도 상관 없고, done에는 boolean 값만 허용하고 있다. 12345// IteratorResult 인터페이스를 준수한 IteratorResultObject 객체const IteratorResultObject = &#123; value: console.log('뭐든 들어와도 상관 없어!'), done: 1 &lt;= 0&#125; 커스텀 이터레이터를 만들어보자.위의 따분한 이론은 집어치우고 이제 배열의 요소를 거꾸로 반환하는 커스텀 이터레이터를 만들어보자.Array.prototype.reverse()가 없다고 생각해보자.123456789101112131415161718192021222324252627// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorResultObject = function() &#123; return &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 value: this.pop(), // value 값이 반환됨. done: this.length === 0 &#125;;&#125;;// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorObject = function() &#123; return &#123; // Iterator 인터페이스를 준수한 객체를 반환 next: () =&gt; &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 return makeIteratorResultObject.call(this); &#125; &#125;&#125;;const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function() &#123; // Iterator 인터페이스를 준수한 객체를 반환 return makeIteratorObject.call(this)&#125;;for(const a of arr) console.log(a); // 0 undefined 3 2 까지만 찍히게 된다.for(const a of arr) console.log(a); // this.pop()으로 원본 배열을 손상시켜서 이터레이터가 1회성을 띈다. 그러면 이터레이터를 하나씩 분리해서 찍어보자.다시 말해 이터러블 객체는 반복 요소를 끊어서 실행할 수 있다.123456789101112131415161718192021222324252627282930313233343536373839404142// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorResultObject = function() &#123; console.log(this.length) return &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 value: this.pop(), // value 값이 반환됨. done: this.length === 0 &#125;;&#125;;// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorObject = function() &#123; return &#123; // Iterator 인터페이스를 준수한 객체를 반환 next: () =&gt; &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 return makeIteratorResultObject.call(this); &#125; &#125;&#125;;const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function() &#123; // Iterator 인터페이스를 준수한 객체를 반환 return makeIteratorObject.call(this)&#125;;const iter = arr[Symbol.iterator]();console.dir(iter); // Iterator 오브젝트를 반환함.// pop 하기 전 length: 5, pop 한 후 length 4console.log(iter.next()); // Object &#123;value: 0, done: false&#125;// pop 하기 전 length: 4, pop 한 후 length 3console.log(iter.next()); // Object &#123;value: undefined, done: false&#125;// pop 하기 전 length: 3, pop 한 후 length 2console.log(iter.next()); // Object &#123;value: 3, done: false&#125;// pop 하기 전 length: 2, pop 한 후 length 1console.log(iter.next()); // Object &#123;value: 2, done: false&#125;// pop 하기 전 length: 1, pop 한 후 length 0// 즉 value를 실행해서 pop을 먼저 실행하고 그 이후의 length인 0을 가지고 done이 평가되는 거임.// 그리고 그 done이 true이면 value를 반환하지 않게되니 1이 반환되지 않는 거였음.console.log(iter.next()); // Object &#123;value: 1, done: true&#125;console.log(iter.next()); // Object &#123;value: undefined, done: true&#125; 그럼 위에서 기술한 커스텀 이터레이터를 수정해보자.123456789101112131415161718192021222324252627282930313233343536373839// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorResultObject = function(idx) &#123; return &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 value: this.slice(-idx)[0], // value 값이 반환됨. done: --idx === this.length &#125;;&#125;;// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorObject = function() &#123; let idx = 0; return &#123; // Iterator 인터페이스를 준수한 객체를 반환 next: () =&gt; &#123; // 이 next 함수 안에 있는 내용은 매번 실행됨. // IteratorResult 인터페이스를 준수한 객체를 반환 return makeIteratorResultObject.call(this, ++idx); &#125; &#125;&#125;;const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function() &#123; // 요 함수에 있는 내용은 한 번만 실행됨. // Iterator 인터페이스를 준수한 객체를 반환 return makeIteratorObject.call(this);&#125;;const iter = arr[Symbol.iterator]();console.log(iter.next()); // Object &#123;value: 0, done: false&#125;console.log(iter.next()); // Object &#123;value: undefined, done: false&#125;console.log(iter.next()); // Object &#123;value: 3, done: false&#125;console.log(iter.next()); // Object &#123;value: 2, done: false&#125;console.log(iter.next()); // Object &#123;value: 1, done: false&#125;console.log(iter.next()); // Object &#123;value: undefined, done: true&#125;// 원본 배열을 손상시키지 않으므로 이터레이터를 무한정 쓸 수 있다.for(const num of arr) console.log(num);for(const num of arr) console.log(num); 객체 관련 이터레이터객체 관련해서도 커스텀 이터레이터를 만들 수 있지만, 커스텀 이터레이터를 쓰지 않고도 이터레이터를 쓸만한 방법이 있다.123456789101112131415161718192021222324const obj = &#123; name: '간장냥', age: 25, [Symbol('symbol')]: '오 마이 심볼!'&#125;;obj.__proto__.asdf = 'qwer';// 객체의 키 뽑아내기(name과 age, [Symbol('symbol')])// ES5(Symbol로 지정한 키는 못 뽑아냄)for(const key in obj) &#123; if(obj.hasOwnProperty(key)) console.log(key);&#125;// ES6(Symbol로 지정한 키가 없으면 그냥 Object.keys를 쓰면 된다.)for(const key of Reflect.ownKeys(obj)) console.log(key);// 객체의 값 뽑아내기(간장냥과 25, '오 마이 심볼!')// ES5(Symbol로 지정한 키는 못 뽑아냄)for(const key in obj) &#123; if(obj.hasOwnProperty(key)) console.log(obj[key]);&#125;// ES6(Symbol로 지정한 키가 없으면 그냥 Object.keys를 쓰면 된다.)for(const key of Reflect.ownKeys(obj)) console.log(obj[key]); 배열 순환 메소드를 개선시킨 break &amp; continue우리는 에서 (ES5) 배열의 순회 메소드에서 break 기능 구현하기배열에서 반복문에서 break, continue를 어떻게 구현할지 생각해보았다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var arr = [ 0, 1, 2, 3, 'q', 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수//ES3var isArrNum = function(arr) &#123; var isNum = false; // 프로그래머가 실수로 let i = 1;이라고 초기화한다면? // 실수로 i&lt;arr.length+1; 이라고 조건식을 잘못 입력한다면? // i+=2; 라고 증감식을 잘못 입력한다면? // arr[i+1]로 잘못 참조한다면? // 이렇게 일일이 초기화, 조건식 지정, 증감식 지정 등등을 일일이 해줘야하므로 귀찮다. for(var i=0; i&lt;arr.length; i++) &#123; console.log(arr[i]); if(!isNaN(arr[i])) &#123; // 숫자라면 // 아래 있는 코드는 실행할 필요 없이 다음 요소를 검사해야함. // 즉 다음 반복문을 실행. continue; &#125; // 숫자가 아니라면 isNum = false; break; &#125; return isNum;&#125;;// ES5var isArrNum2 = function(arr) &#123; // 과연 직관적이라고 말할 수 있는가? return !arr.some(v =&gt; &#123; console.log(v); return isNaN(v); &#125;);&#125;;// ES6const isArrNum3 = arr =&gt; &#123; // 실수할 요소가 확연히 줄어들고 ES5보다 훨씬 직관적으로 변하였다. let isNum = true; for(const v of arr) &#123; console.log(v); if(!Number.isNaN(+v)) continue; isNum = false; break; &#125; return isNum;&#125;// 0// 1// 2// 3// q// falseconsole.log(isArrNum(arr));console.log(isArrNum2(arr));console.log(isArrNum3(arr)); 참조 링크 [es6] GDG 2016 발표자료 [MDN] Iteration protocols ES6 Iterable and Iterator | programmist 21. Iterables and iterators","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"Interface","slug":"Interface","permalink":"http://perfectacle.github.io/tags/Interface/"},{"name":"Symbol","slug":"Symbol","permalink":"http://perfectacle.github.io/tags/Symbol/"},{"name":"Iterator","slug":"Iterator","permalink":"http://perfectacle.github.io/tags/Iterator/"}]},{"title":"(Webpack 2) 상대경로 헬파티에서 탈출하기","slug":"webpack2-escape-relative-path-hell","date":"2017-04-19T15:37:49.000Z","updated":"2017-07-31T12:40:20.000Z","comments":true,"path":"2017/04/20/webpack2-escape-relative-path-hell/","link":"","permalink":"http://perfectacle.github.io/2017/04/20/webpack2-escape-relative-path-hell/","excerpt":"","text":"상대경로 헬파티/app/src/lib/lib.js에는 아래와 같은 변수가 들어가있다.1export const num = 2; /app/src/lib/lib.scss에는 아래와 같은 변수가 들어가있다.1$var: 100px; 이제 이 변수를 사용하는 모듈이 /app/src/a/b/c/d/e/f 폴더 안에 있는 녀석들이다./app/src/a/b/c/d/e/f/a.js 파일의 내용은 아래와 같다.12import &#123;num&#125; from '../../../../../../lib/lib';export const num2 = num*num; /app/src/a/b/c/d/e/f/a.scss 파일의 내용은 아래와 같다.123456@import '../../../../../../lib/lib';div &#123; width: $var; height: $var; background-color: black;&#125; 자동 완성이 되는 IDE의 경우에는 다행이지만… 그렇지 않은 에디터를 사용하는 경우에는 헬파티가 열리게 된다.오늘은 이러한 문제점을 해결해보고자 한다! 프로젝트 세팅 일단 프로젝트로 쓸 디렉토리를 아무거나 만들고 터미널로 해당 디렉토리로 이동 후 다음 명령어를 쳐서 npm을 초기화 시키고 패키지들을 설치하자.12npm init --ynpm i -S webpack html-webpack-plugin style-loader css-loader node-sass sass-loader 웹팩 2에서는 바벨 없이도 import/export 문법을 쓸 수 있게 됐다! html-webpack-plugin빌드한 후에 소스 디렉토리에 있는 html 파일을 dist 디렉토리로 옮기기 위해 사용.script, css 파일 자동 삽입 및 템플릿 엔진 사용, html minify 등등 다양한 기능 제공. style-loader css-loadercss 파일을 모듈로써 사용하기 위해 사용. node-sass sass-loadersass, scss 파일을 모듈로써 사용하기 위해 사용. 프로젝트 디렉토리에 웹팩 설정 파일인 webpack.config.js 파일을 만들고 아래와 같이 적어주자.웹팩 1은 Configuration - Webpack 링크를 참조하자.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const ROOT = './app/src';const DIST = './app/dist';module.exports = &#123; entry: &#123; app: `$&#123;ROOT&#125;/index`, &#125;, output: &#123; filename: 'bundle.js', path: `$&#123;__dirname&#125;/$&#123;DIST&#125;` &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: `$&#123;ROOT&#125;/index.html` &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ], module: &#123; rules: [&#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', &#123; loader: 'sass-loader', // 사스에서 상대경로 헬파티를 구제해줄 속성 options: &#123; includePaths: [ROOT] &#125; &#125;] &#125;] &#125;, resolve: &#123; // es6 native module에서 상대경로 헬파티를 구제해줄 속성 modules: [ROOT, './node_modules'] &#125;&#125;;// DeprecationWarning: loaderUtils.parseQuery() received a non-string value which can be problematic, see https://github.com/webpack/loader-utils/issues/56// parseQuery() will be replaced with getOptions() in the next major version of loader-utils.// 위와 같이 로더 개발자를 위한 로그가 뜨는 게 보기 싫어서 추가.process.noDeprecation = true; /app/src/lib/lib.js은 아래와 같이 만들어주자.1export const num = 2; /app/src/lib/lib.scss도 아래와 같이 만들어주자.1$var: 100px; 이제 /app/src/a/b/c/d/e/f/a.js를 아래와 같이 만들어주자.상대 경로의 헬파티로부터 벗어나게 된다.12import &#123;num&#125; from 'lib/lib';export const num2 = num*num; /app/src/a/b/c/d/e/f/a.scss도 아래와 같이 만들어주자.역시 상대 경로의 헬파티로부터 벗어나게 된다.123456@import 'lib/lib';div &#123; width: $var; height: $var; background-color: black;&#125; /app/src/index.js는 아래와 같이 만들어주자.1234import &#123;num2&#125; from './a/b/c/d/e/f/a';import './a/b/c/d/e/f/a.scss';console.log(num2); /app/src/index.html은 아래와 같이 만들어주자.번들 된 js 경로를 입력하지 않아도 html-webpack-plugin이 알아서 삽입해준다.12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; package.json에 빌드 스크립트를 넣어주자.scripts 부분에 넣어주면 된다.123\"scripts\": &#123; \"start\": \"$(npm bin)/webpack\"&#125; 그리고 다음과 같이 빌드를 해보자.1npm start 그리고 나서 /app/dist/index.html을 열어보면 다음과 같이 원하는 결과를 얻을 수 있다.100x100의 까만 div와 2*2=4의 결과를 콘솔창에서 볼 수 있다. 갓텔리제이 짱짱맨한 가지 아쉬운 점이라면 IDE는 웹팩에서 정해준 루트 경로를 이해하지 못한다.따라서 자동완성과 인덱싱(폴더가 존재하는 경로나 파일로 이동)을 지원하지 않는다.아마 Jet Brains의 IDE(Webstorm, PHPStorm 등등)에서는 다 지원될 것이다.최신 버전으로 업데이트 한 후에 /app/src 경로를 Resource Root로 지정해주자.Source Root로 지정하면 sass에서 모듈을 인덱싱하지 못한다.경로, 변수 자동 완성 및 인덱싱까지 너무 잘 돼서 개발자에게 뽀뽀 해주고 싶은 심정이다.다른 IDE는 어떤지 모르겠지만 역시 갓텔리제이라 할만하다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"http://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"http://perfectacle.github.io/tags/Webpack2/"}]},{"title":"(Webpack 2) 최적화하기","slug":"webpack2-optimize","date":"2017-04-17T17:56:26.000Z","updated":"2017-07-31T12:40:15.000Z","comments":true,"path":"2017/04/18/webpack2-optimize/","link":"","permalink":"http://perfectacle.github.io/2017/04/18/webpack2-optimize/","excerpt":"","text":"들어가기에 앞서이 포스트들에서 말하는 내용들은 전부 배포용 파일에 적합한 작업이다.이런 압축 작업을 개발용 버전에서 매번 빌드할 때마다 실행하면 빌드 시간이 매우 느려지기 때문이다. 우리는 (Webpack 2) 트리 쉐이킹을 해보자!에서 모듈 전체가 로딩 되는 CommonJS 방식에서모듈의 필요한 부분만 로딩하는 ES2015 Native Module 방식을 사용하는 법을 배웠다.(Tree Shaking)또한 (Webpack 2) 코드를 분할해보자!에서 공통된 라이브러리를 분리시켜 사용자가 재접속시 캐싱을 적극 활용하게 바꿨고,모든 페이지의 코드를 로딩하는 것이 아닌 페이지를 이동할 때마다 필요한 소스만 로딩하게 끔 청크 별로 코드를 분할하였다. (Code Splitting)그리고 Webpakc 2가 미완성이라 코드 스플리팅이 제대로 되지 않아 일일이 필요한 모듈 파일을 하나씩 명시해줬어야 했는데,이를 좀 더 똑똑하게 해주는 바벨 플러그인을 소개한 내용을 (Webpack 2) 트리 쉐이킹을 똑똑하게 해보자! 통해서 보았다.이번 포스트에서는 이와 더불어 조금이라도 더 소스 코드를 최적화하는 방법을 소개하도록 하겠다.별로 안 대단해보일 수 있지만, 필자는 상당히 흥미롭게 느낀 내용이다.혹시 위 3개 포스트를 보지 않은 사람은 따라하지는 않더라도 꼭 읽어보길 바란다. 예제는 아래 깃헙 저장소의 hot-3 브랜치를 기준으로 진행된다.https://github.com/perfectacle/react-router-4/tree/hot-3 너무나 많은 청크들위 저장소를 클론 받고 패키지를 전부 설치한 후에 번들링 해보자.12npm inpm run build 청크 별로 코드를 분할 시켜서 로딩시간을 단축시켰다고 생각할 수 있지만 그렇지 않을 수도 있다.실제 코드를 로딩받는 시간보다 http 요청을 수십, 수백 회 증가시키는 행위가 오히려 더 로딩시간을 늘리게 될 수가 있다.http 1.1 스펙에서 하나의 요청당 하나의 응답(js 파일 등등)만 받아올 수 있는데 그 하나의 요청을 위한 비용은 어찌보면코드 하나를 다운받는 것보다 더 비싼 비용을 지불하게 될 경우가 있다.우리의 코드가 그렇다. 코드의 용량이 그렇게 크지가 않다면 차라리 하나의 요청으로 일정 크기를 한 번에 받아버리는 게 나을 수 있다.그렇다, 청크의 최소 용량을 정해주는 것이다. 아래와 같이 웹팩 배포용 설정 파일일 webpack.config.js의 plugins에 아래 내용을 추가해주자.123new webpack.optimize.MinChunkSizePlugin(&#123; minChunkSize: 512000 // 50kb&#125;) 라우팅 된 컴포넌트의 코드 스플리팅이 안 된 것처럼 보이지만,앱이 점점 커지고 컴포넌트 수가 급격히 증가하고, 코드의 용량이 증가하다보면50kb짜리 코드 여러 개로 분할될 것이다. 자바스크립트 코드 압축의 3단계아래와 같은 코드를 짰다고 생각해보자.123const num1 = 123;const num2 = 456;console.log(num1 + num2); // 579 minify(압축)시키면 아래와 같이 변한다.1const num1=123;const num2=456;console.log(num1+num2) 여기서 한 단계 앞서 나가가서 보통 uglify(난독화)까지 하게 된다.1const a=123;const b=456;console.log(a+b) 하지만 여기서 한 단계 더 압축할 수 있다는 사실이 존재한다.바로 gzip(GNU zip) 알고리즘을 써서 압축하는 것이다.아래 글을 통해 주의 사항들을 확인해보자.Gzip에 관하여주로 유닉스 기반의 운영 체제인 유닉스, 리눅스, 맥 등등에서 많이 쓰인다.이러한 알고리즘을 써서 js 파일을 gz 파일로 압축하고, 브라우저에서 이 gz 파일을 열게되는 것이다.브라우저 지원 현황은 아래와 같은데 IE4부터 지원한다니 말 다 했다.Which browsers can handle Content-Encoding: gzip ?이를 위해선 서버가 필요한데 섭알못(서버를 알지 못함)이고 자바스크립트가 익숙하기 때문에 노드 js 기반의 서버를 기준으로 설명하겠다. 우선 노드 js에서 gzip 파일을 불러오는 모듈과 웹팩에서 gz으로 압축해주는 플러그인을 설치하자.1npm i -S compression compression-webpack-plugin 그리고 server.js를 아래와 같이 수정해주자.1234567891011121314151617181920const express = require('express');const compression = require('compression');const app = express();const PORT = 3000;const DIST = `$&#123;__dirname&#125;/app/dist/`;// load *.gz// app.use('/', express.static(DIST)); 보다 위에 존재해야함.app.use(compression());// server-openapp.use('/', express.static(DIST));app.listen(PORT, () =&gt; &#123; console.log('Express listening on port', PORT);&#125;);// client routerapp.get('*', (req, res) =&gt; &#123; res.sendFile(DIST);&#125;); 그리고 웹팩 배포용 설정 파일인 webpack.config.js를 다음과 같이 수정하자.12345678910const CompressionPlugin = require(\"compression-webpack-plugin\");// ...// plugins에 아래 플러그인 추가new CompressionPlugin(&#123; asset: \"[path].gz[query]\", algorithm: \"gzip\", test: /\\.(js|html)$/, threshold: 10240, // 10kb minRatio: 0.8&#125;) 그럼 위와 같이 gz으로 압축된 vendor 파일을 볼 수 있다.파일 크기가 너무 작으면 압축을 해제하는데 더 큰 시간을 소모하므로 threshold를 잘 지정해주자. 실제 페이지를 보면 위와 같이 vendor.js의 파일 용량(받은 용량)이 179kb가 아닌 50kb임을 알 수 있다. 이 외에도 chunk의 최대 갯수(코드 스플리팅하는)를 제한하는 LimitChunkCountPlugin 등등이 있으니 궁금한 사람은 더 찾아보길 바란다. 참조 링크 SPA 초기 로딩 속도 개선하기 SPA 스크립트 용량 어디까지 줄일 수 있을까 Two Quick Ways To Reduce React App’s Size In Production 프로덕션 우수 사례: 성능 및 신뢰성 Gzip에 관하여 Webpack 2 - Plugins","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"http://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"http://perfectacle.github.io/tags/Webpack2/"},{"name":"Optimize","slug":"Optimize","permalink":"http://perfectacle.github.io/tags/Optimize/"},{"name":"gzip","slug":"gzip","permalink":"http://perfectacle.github.io/tags/gzip/"}]},{"title":"(ES6) Symbol","slug":"ES6-Symbol","date":"2017-04-16T06:15:31.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2017/04/16/ES6-Symbol/","link":"","permalink":"http://perfectacle.github.io/2017/04/16/ES6-Symbol/","excerpt":"","text":"목차 들어가기에 앞서 원시값(Primitive Value) 객체(Object) Symbol의 특성 Symbol의 탄생 배경 Symbol의 사용 사례 Symbol 파헤치기 프로퍼티의 은닉화? 들어가기에 앞서Symbol은 새로 생긴 7번 째 자료형이며 원시값(Primitive Value)이다.Symbol에 들어가기 전에 몸풀기로 ES5의 자료형부터 알아보고 가자.ES5에는 6가지 자료형이 있다. Boolean Number String Null Undefined Object 원시값(Primitive Value)Object를 제외한 값들은 원시값이다.값이 유한하며, 그리고 값으로서 비교한다.(고 생각했지만 심볼을 보면 틀린 말 같다.심볼을 생각하면 원시값은 프로퍼티를 추가할 수 있느냐 없느냐와 불변값이냐로 나뉘는 것 같다.)다음 값은 모두 참이다.12345console.log(false === false);console.log('asdf' === 'asdf');console.log(null === null);console.log(undefined === undefined);console.log(1 === 1); 하지만 다음과 같은 예외(버그)가 존재한다.123console.log(0 === -0); // trueconsole.log(NaN === NaN); // falseconsole.log(typeof null); // object typeof null을 제외하고 나머지 문제는 아래와 같이 해결할 수 있다.1234console.log(Object.is(0, -0)); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(isNaN(NaN)); // trueconsole.log(Number.isNaN(NaN)); // true isNaN은 NaN인지 아닌지 구하기 위한 함수이며, ES6 들어서 Number.isNaN()과 Object.is() 메소드가 생겼다.isNaN과 Number.isNaN의 차이는 후자는 타입 검사(number인지 아닌지)까지 한다는 것이다.아래 링크를 통해 예제로 확인해보자.Number.prototype.isNaN() 하지만 typeof null을 개선하면 레거시 코드들이 문제가 있는지 아직도 고쳐지지 않았다.아래 링크를 참조해서 누가 번역을 해주면 고마울 것 같다.The history of “typeof null” 또한 원시값은 불변값(Immutable Value)이다.아래의 결과가 당연하다고 생각하는 사람은 객체에서는 어떻게 결과가 나타나는지 객체 파트를 보길 바란다.12345var a = 'strin';var b = a;a += 'g';console.log(a); // 'string'console.log(b); // 'strin' 객체(Object)객체는 Boolean, Number, String, Null, Undefined를 제외한 자료형이다.123456console.log(typeof function()&#123;&#125;); // functionconsole.log(typeof []); // objectconsole.log(typeof /\\d/); // objectconsole.log(typeof new Data()); // objectconsole.log(typeof &#123;&#125;); // object// ES6에서는 (Weak)Map/Set과 TypedArray까지 객체로 추가되었다. 어… Function은 타입이 function인데 Array나 RegExp, Date는 왜 object인지 아는 사람이 있으면 알려주길 바란다.일단 저 위에 있는 놈들은 객체이기 때문에 프로퍼티를 할당할 수 있다.콘솔 창에서 각각 a란 프로퍼티가 붙었는지 보자.123456789101112131415var func = function()&#123;&#125;;var arr = [];var regExp = /\\d/;var date = new Date();var obj = &#123;&#125;;func.a = 1;arr.a = 1;regExp.a = 1;date.a = 1;obj.a = 1;console.dir(func);console.dir(arr);console.dir(regExp);console.dir(date);console.dir(obj); 또한 객체는 참조 타입인 것 같다.가지고 있는 값으로서 비교하는 게 아니라 저장된 메모리 주소를 참조하여 같은지 비교하는 것 같다.또한 갯수도 무한하다.다음은 모두 거짓을 반환한다.12345console.log(function()&#123;&#125; === function()&#123;&#125;);console.log([] === []);console.log(/\\d/ === /\\d/);console.log(new Date() === new Date());console.log(&#123;&#125; === &#123;&#125;); 또한 객체는 참조 타입이기 때문에 불변값이 아니다.123456var arr = [];var arr2 = arr;arr.push(1);// arr2에 넣지도 않은 1의 값이 들어가있다. // 이는 arr2가 arr의 값을 가져온 게 아니라 메모리 주소를 가져와 참조하고 있기 때문에 발생한다.console.log(arr2); // [1] 이런 객체 타입을 불변값으로 만드는 예제는 아래 링크를 참조하자.직접 구현해본 JS 객체, 배열의 깊은 복사하는 방법 Symbol의 특성여기서는 심볼에 대해 간략하게만 설명하겠다.백날 이론을 봐봤자 왜 써야하며 언제 써야하는지를 모르면 무의미하다고 여기기 때문이다.따라서 간단하게만 특성을 보고 탄생 배경과 사용 사례를 본 이후에 본격적인 설명을 하겠다.Symbol은 새로 생긴 7번 째 자료형이며 원시값(Primitive Value)이다.기존 원시값들은 위에서 보는 바와 같이 값으로서 비교를 했다.하지만 심볼은 원시값임에도 불구하고 객체와 같이 참조하는 메모리의 주소를 가지고 비교하는 것 같다.1console.log(Symbol('a') === Symbol('a')); // false 심볼은 생성할 때마다 독자적인 메모리 공간을 가져서 고유함을 유지한다.그럼에도 불구하고 원시값이란다.내가 아는 원시값은 값으로서 비교하는 것 같았는데 그럼 얘는 왜 원시값이라 부르는 걸까?그건 아마도 심볼이 불변값이며 프로퍼티를 추가(객체의 특성)할 수 없기 때문이 아닐까 싶다.123const a = Symbol('a');a.a = 1;console.dir(a); // a 프로퍼티가 안 찍혀서 나온다. Symbol의 탄생 배경이라고 하긴 뭐하고 어떤 문제점 때문에 심볼이란 놈이 생긴 건지 간단하게 다루어보았다.아래와 같은 코드를 보자.1234567// ES5에서 Array인지 아닌지 구분하는 표준화된 방법이 없다. // typeof 연산자를 써도 object를 반환하기 때문에 구분해낼 방법이 없다. // 따라서 아래와 같이 함수화시켜서 라이브러리로 제작 후에 많은 사람에게 배포했다고 가정해보자. // 예제기 때문에 Boolean 대신에 String을 반환하게 했다는 점은 감안해주길 바란다.Array.isArray = function(arg) &#123; return (Object.prototype.toString.call(arg) === '[object Array]') ? 'Array' : 'Not Array';&#125;; 이 라이브러리는 전 세계의 수백만 개발자들이 쓰게 되었고, 많은 사람들이 아래와 같이 코드를 짜기 시작했다.123var arr = [1, 2, 3];if(Array.isArray(arr) === 'Array') console.log('나는 배열이당!');else console.log('나는 배열이 아니당!'); 하지만 ES6 들어서 위에 우리가 사용한 Array.isArray 메소드가 표준 메소드로 지정되었다!그리고 그 메소드는 우리가 예측한 문자열들이 아닌 Boolean 값을 반환하는 메소드다!따라서 우리 라이브러리를 사용해서 개발한 사용자들의 코드가 의도한 대로 작동하지 않을 가능성이 있다!하지만 다행히도 위 메소드는 덮어쓰기가 가능하다.그래도 우리 라이브러리를 쓰는 개발자가 ES6의 표준 메소드 작동 방식으로 Array.isArray를 썼다간 낭패를 볼 것이다.1console.log(Object.getOwnPropertyDescriptor(Array, 'isArray').writable); // true 하지만 모든 프로퍼티가 덮어쓰기가 가능한 게 아니다.아래와 같이 상수(네이밍이 UPPER_SNAKE_CASE로 돼있다.) 프로퍼티도 존재하기 때문이다. 1console.log(Object.getOwnPropertyDescriptor(Number, 'MAX_SAFE_INTEGER').writable); // false Symbol의 사용 사례 표준 객체의 프로퍼티로 사용위에서 봤 듯이 표준 객체에 혹시 내가 쓴 프로퍼티가 표준 프로퍼티가 되는 불상사(?)가 생긴다면 코드가 의도치 않게 작동할 것이다.물론 매우 드문 일일 것이지만, 코드를 방어적으로 쓰는 습관은 항상 들여야하는 것 같다.위의 Array.isArray를 우리는 심볼을 사용해서 문제를 회피할 것이다. 12345678910const isArray = Symbol('isArray');Array[isArray] = arg =&gt; ( (Object.prototype.toString.call(arg) === '[object Array]') ? 'Array' : 'Not Array');// Array.isArray를 지원하는 모던 브라우저(크롬, 파폭의 최신 버전 등등)에서 아래 코드를 확인해보자.console.dir(Array);// 사용은 아래와 같이 하면 된다.const arr = &#123;&#125;;if(Array[isArray](arr) === 'Array') console.log('나는 배열이당!');else console.log('나는 배열이 아니당!'); 이런 식으로 심볼을 사용하게 되면 표준 메소드 때문에 벌벌 떨며 염려할 필요가 사라진다.하지만 위 사례에서도 하나 문제점이 존재한다.바로 전역 공간에 심볼을 노출해야한다는 점이다.우리의 라이브러리가 점점 규모가 커져서 아래와 같이 다양한 타입을 검출한다고 가정해보자. 12345678910111213141516const isArray = Symbol('isArray');const isRegExp = Symbol('isArray');const isDate = Symbol('isArray');const isObject = Symbol('isArray');Array[isArray] = arg =&gt; &#123; // 코드 작성&#125;;RegExp[isRegExp] = arg =&gt; &#123; // 코드 작성&#125;;Date[isDate] = arg =&gt; &#123; // 코드 작성&#125;;Object[isObject] = arg =&gt; &#123; // 코드 작성&#125;; 이렇게 전역 공간에 심볼을 일일이 노출시키는 게 마음이 들지 않으므로 네임 스페이스 패턴을 사용해서 모듈을 구현할 수 있다.전역에는 단 하나의 변수인 $SYMBOL만 노출되므로 좀 더 안전하게 코드를 작성할 수 있다.123456789101112131415161718const $SYMBOL = &#123; // 전역 공간에 노출되므로 그 어떤 이름과도 충돌이 나지 않게 지어야한다. isArray: Symbol('isArray'), isRegExp: Symbol('isArray'), isDate: Symbol('isArray'), isObject: Symbol('isArray')&#125;;Array[$SYMBOL.isArray] = arg =&gt; &#123; // 코드 작성&#125;;RegExp[$SYMBOL.isRegExp] = arg =&gt; &#123; // 코드 작성&#125;;Date[$SYMBOL.isDate] = arg =&gt; &#123; // 코드 작성&#125;;Object[$SYMBOL.isObject] = arg =&gt; &#123; // 코드 작성&#125;; 좀 더 우아하게 코드를 작성하고 싶은 사람은 ES6의 import/export(를 브라우저에서 미지원하므로 모듈 번들러인 Webpack 등등까지 사용)를 해보자.1234567891011121314151617181920// symbol.jsexport const isArray = Symbol('isArray');export const isRegExp = Symbol('isArray');export const isDate = Symbol('isArray');export const isObject = Symbol('isArray');// lib.jsimport &#123;isArray, isRegExp, isDate, isObject&#125; from './symbol';Array[isArray] = arg =&gt; &#123; // 코드 작성&#125;;RegExp[isRegExp] = arg =&gt; &#123; // 코드 작성&#125;;Date[isDate] = arg =&gt; &#123; // 코드 작성&#125;;Object[isObject] = arg =&gt; &#123; // 코드 작성&#125;; 표준 심볼(Well-known Symbol)로써 사용ES6가 등장하기 전에 사람들의 필요에 의해 생성하거나 개발한 함수들이 많을 것이다.그 중에 공통된 함수들은 기능과 네이밍이 비슷한 경우가 많을 것이다. (내부 로직은 다를지라도)이렇게 많은 사람들이 쓴 함수의 이름 등등을 표준 프로퍼티로 만들고 나면?내부 로직이 다 같지는 않으므로 그 수많은 코드가 깨질 수 있다. (우리 Array.isArray와 마찬가지로 말이다.)따라서 기존 개발자들이 개발한 코드들의 안전성을 보장하고자 표준 프로퍼티를 심볼로 만든 경우가 있다.그 목록은 아래와 같다. Symbol.iterator(추후 다룰 예정) Symbol.unscopables Symbol.match Symbol.species Symbol.toPrimitive 등등… Symbol 파헤치기이제 왜 쓰는지를 알았으니 본격적으로 심볼에 대해 파헤쳐보자.심볼은 생성할 때마다 독자적인 영역을 가지지만 공유도 가능하다. 123456789101112const a = Symbol('key');const b = Symbol.for('key2');console.log(a === Symbol('key')); // falseconsole.log(b === Symbol.for('key2')); // true// usageconst obj = &#123; [a]: 1, [b]: 2&#125;;console.log(obj[a]); // 1console.log(obj[b]); // 2 또한 심볼의 타입은 symbol이며 new 연산자를 써서 생성하면 오류가 뜬다.(당연한 소리처럼 들리겠지만 ES5의 function의 경우를 생각하면 이런 오류 하나하나가 참 감사하다.)123console.log(typeof Symbol('a')); // 'symbol'// 이제 new 연산자는 클래스에서만 쓰자, 이제 자바스크립트가 꽃길만 걷길 바란다.const a = new Symbol('a'); // Uncaught TypeError: Symbol is not a constructor 그럼 저 Symbol 안에 들어가는 문자열은 무엇에 쓰이는 물건인고?하면… 디버깅 용으로 쓰인다고 한다.개인적으로는 변수명만으로도 어떤 심볼인지 유추가 가능할 것 같은데 심볼의 문자열을 가지고 디버깅을 어떻게 하는지 모르겠지만…심볼의 문자열을 가지고 노는 방법은 아래와 같다.12345678const asdf = Symbol('asdf');const qwer = Symbol.for('qwer');console.log(asdf); // Symbol(asdf), 문자열이 아닌 Symbol 타입이다.console.log(String(asdf)); // 'Symbol(asdf)'console.log(asdf.toString()); // 'Symbol(asdf)'console.log('' + asdf); // Uncaught TypeError: Cannot convert a Symbol value to a stringconsole.log(asdf.toString().substr(7).slice(0, -1)); // 'asdf'console.log(Symbol.keyFor(qwer)); // 'qwer' 프로퍼티의 은닉화?심볼은 객체의 프로퍼티(메소드)에 쓸 때 우리는 그 값을 참조할 수 있을까?있다! 따라서 은닉화를 위해서 Symbol을 쓰는 건 올바른 방법이 아니다.1234567891011121314151617181920212223const symbol = Symbol('symbol');const symbol2 = Symbol('symbol2');const obj = &#123; key: 1, method: () =&gt; console.log(2), [symbol]: 3, [symbol2]: () =&gt; console.log(4)&#125;;// Symbol은 객체의 표준 메소드나 기존의 방법으로는 노출되지 않는다. for(const key in obj) console.log(key); // 'key' 'method'console.log(Object.keys(obj)); // ['key', 'method']console.log(Object.getOwnPropertyNames(obj)); // ['key', 'method']// 하지만 그렇다고 해서 프로퍼티가 은닉화된 것은 아니다.// 아래와 같이 접근이 가능하기 때문이다.console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(symbol), Symbol(symbol2)]// 프로퍼티(키와 심볼)를 모두 가져오려면 Reflect 객체를 사용해야한다.// 레인보우 리플렉션(무지개 반사)을 초등학교 때 많이 썼는데, Reflect는 '비추다'란 뜻이다.// 즉 해당 객체를 비추어 안에 내용물을 다 본다고 생각하면 될 것 같다.console.log(Reflect.ownKeys(obj)); // ['key', 'method', Symbol(symbol), Symbol(symbol2)] 이 이상 심볼에 대해 더 딥하게 다루기에는 실용성이 떨어질 것 같고 그 때 그 때 찾아보면 될 것 같다.사실 이터레이터 때문에 공부를 했지 실무에서 많이 쓸지는 잘 모르겠다.이 글을 읽고 난 독자는 다음 글을 읽기 바란다.(ES6) Iterator 참조 링크 Symbol - JavaScript | MDN ES6 In Depth: 심볼 (Symbol) ★ Mozilla 웹 기술 블로그 es6js/07 심볼 at master · js-jsm/es6js","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"Symbol","slug":"Symbol","permalink":"http://perfectacle.github.io/tags/Symbol/"}]},{"title":"(Webpack 2) 트리 쉐이킹을 똑똑하게 해보자!","slug":"webpack2-smart-tree-shaking","date":"2017-04-11T15:10:25.000Z","updated":"2017-07-31T12:40:10.000Z","comments":true,"path":"2017/04/12/webpack2-smart-tree-shaking/","link":"","permalink":"http://perfectacle.github.io/2017/04/12/webpack2-smart-tree-shaking/","excerpt":"","text":"들어가기에 앞서이 포스트는 (Webpack 2) 트리 쉐이킹을 해보자!의 후속작이다.따라서 해당 포스트를 읽고 예제를 진행한 후에 보는 걸 추천한다.또한 내가 리액트 말고 할 줄 아는 게 별로 없어서 예제를 리액트로만 진행하다보니혹시 헷갈리면 다른 라이브러리로 진행해보길 바란다. 복습우리는 지난 포스트에서 리액트 라우터를 트리 쉐이킹하였다.아래와 같이 기존에 쓰던 방식대로 진행하면 쓰지도 않는 모듈들이 전부 번들링되는 참사가 발생한다.1import &#123;Router, Route, hashHistory&#125; from 'react-router'; 티끌 모아 태산이라고 우리의 앱이 쓰지도 않는 모듈들로 눈덩이처럼 불어날지도 모른다.따라서 우리는 아래와 같이 해주었다.123import Router from 'react-router/es/Router';import Route from 'react-router/es/Route';import hashHistory from 'react-router/es/hashHistory'; 매우 귀찮아보이지 않는가?패키지가 늘어나고, 불러올 모듈들이 증가하면 한 줄 한줄 일일이 입력해줘야한다. 실습그럼 이제 이를 어떻게 해결할지 간단한 예제를 만들자.프로젝트 폴더를 만들고 package.json 파일을 만들자.그리고 다음과 같은 패키지들을 설치해준다. 12npm i -S react react-dom react-router@^3.xnpm i -D babel-core babel-preset-env babel-preset-react babel-loader babel-plugin-transform-imports babel-plugin-transform-imports 요 녀석이 바로 핵심이다. 프로젝트 폴더에 .babelrc(바벨 설정 파일)을 만들어주자.1234567891011121314151617181920&#123; \"presets\": [ [ \"env\", &#123; \"browsers\": [\"last 2 versions\", \"&gt; 10%\", \"ie 9\"], \"modules\": false, &#125; ], \"react\" ], \"plugins\": [ [\"transform-imports\", &#123; \"react-router\": &#123; \"transform\": \"react-router/es/$&#123;member&#125;\", \"preventFullImport\": true &#125; &#125;] ]&#125; 플러그인 부분에 내용에 주목하자.12345678910111213plugins: [ // 배열의 첫 번째 요소로 배열(transform-imports 플러그인 정보를 담은)이 옴. // 그 배열 안에는 transform-imports 플러그인 임을 알려주는 요소가 첫 번째로 들어와있고, // 두 번째 요소로 객체가 들어오는데 이는 react-router 모듈에 대한 객체이다. // transform 프로퍼티에서 어떤 폴더를 기점으로 모듈들을 일일이 불러올지 기술했다고 보면 될 것 같다. // preventFullImport, 쓰지도 않는 녀석은 불러오지 않는 걸(트리 쉐이킹) true로 지정했다. [\"transform-imports\", &#123; \"react-router\": &#123; \"transform\": \"react-router/es/$&#123;member&#125;\", \"preventFullImport\": true &#125; &#125;]] webpack.config.js(웹팩 설정 파일)도 만들어주자.12345678910111213141516171819202122232425262728293031323334353637383940const webpack = require('webpack');module.exports = &#123; entry: './index.js', output: &#123; filename: 'bundle.js', path: './', &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; // 사실 아래와 같이만 써도 트리 쉐이킹이 된다. // compress: true compress: &#123; // warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮다면 요 놈을 주석 제거를 하면 된다. unused: true // 요 놈이 핵심 &#125;, mangle: false, // DEMO ONLY: Don't change variable names.(난독화) beautify: true, // DEMO ONLY: Preserve whitespace (가독성 좋게 함) output: &#123; comments: true // DEMO ONLY: Helpful comments (주석 삭제 안 함) &#125; &#125;) ], module: &#123; // 웹팩 1에서는 loaders를 썼지만 2에선 rules rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, // 쿼리가 필요한 로더는 loader로 써줘야함. // 쿼리가 필요 없는 로더는 use로 써도 된다. // 웹팩 2에선 babel-loader와 같이 -loader 생략이 불가능해졌다. use: 'babel-loader' &#125; ] &#125;&#125;;// DeprecationWarning: loaderUtils.parseQuery() received a non-string value which can be problematic, see https://github.com/webpack/loader-utils/issues/56// parseQuery() will be replaced with getOptions() in the next major version of loader-utils.// 위와 같이 로더 개발자를 위한 로그가 뜨는데 보기 싫다면 주석을 제거하면 된다.// process.noDeprecation = true; index.html도 만들어주자.123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script src=\"./bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 엔트리(index.js) 파일도 만들어주자.123456789101112import React from 'react';import &#123;render&#125; from 'react-dom';import &#123;Router, Route, hashHistory&#125; from 'react-router';const Comp = () =&gt; &lt;h2&gt;하이&lt;/h2&gt;;render( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;Comp&#125; /&gt; &lt;/Router&gt;, document.getElementById('app')); 터미널을 키고 아래와 같이 타이핑해주자.1./node_modules/webpack/bin/webpack.js 그리고나서 bundle.js 파일을 뒤져봐도 browserHistory에 대한 내용을 찾을 수 없다.즉, 모듈 별로 일일이 불러오지 않고도 트리 쉐이킹을 할 수 있게 된 것이다!물론 요렇게 해도 안 되는 녀석들도 있는 것 같다.아마 웹팩 2가 나오기 전에 만들어진 모듈이거나모듈 간에 의존성이 너무 높아서 하나만 불러와도 다른 모듈들까지 불러오지 않는 이상사용이 불가능한 모듈인 경우에 그런 것 같다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"http://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"http://perfectacle.github.io/tags/Webpack2/"},{"name":"babel","slug":"babel","permalink":"http://perfectacle.github.io/tags/babel/"}]},{"title":"(ES6) Promise에 파라미터를 넘겨서 사용해보자","slug":"js-promise-param","date":"2017-04-04T12:09:43.000Z","updated":"2017-04-04T13:16:41.000Z","comments":true,"path":"2017/04/04/js-promise-param/","link":"","permalink":"http://perfectacle.github.io/2017/04/04/js-promise-param/","excerpt":"","text":"들어가기에 앞서어제 프라미스를 쓰면서 정리 해봤는데,또 파라미터를 넘겨서쓰거나 하려니 제대로 쓸 수가 없어서 정리해봤다.일단 reject 되는 경우는 생각하지 않고, 그냥 내가 짠 비동기 함수를 동기식으로 실행시키길 원했을 뿐이었다.지극히 사용 방법 위주로 적었으니 아래 링크들을 참조해서 이해하자.일단 구현이 먼저인 사람은 코드를 적극 참조하면 될 것 같다. Promise - JavaScript | MDN - Mozilla Developer Network 바보들을 위한 Promise 강의 - 도대체 Promise는 어떻게 쓰는거야? | 감성 프로그래밍 Promise 를 사용하는 두 가지 방법, new Promise, Promise.resolve() 파라미터 없는 일반 비동기 함수1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const f1 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(1); // 비동기 함수(setTimeout)의 콜백 함수 안에서 // resolve 시켜줘야 순서를 보장할 수 있음. // 이 res 부분부터 then 안에 구문이 실행된다고 보면 된다. res(); &#125;, 1000)));const f2 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(2); res(); &#125;, 1000)));const f3 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(3); res(); &#125;, 1000)));const f4 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(4); res(); &#125;, 1000)));const f5 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(5); res(); &#125;, 1000)));const f6 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(6); res(); &#125;, 1000)));const f7 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(7); res(); &#125;, 1000)));const f8 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(8); res(); &#125;, 1000)));const f9 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(9); res(); &#125;, 1000)));// 후속 함수에게 Promise를 리턴해주므로 thenable해서 계속 체이닝이 가능.f1() // 1.then(f2) // 2.then(f3) // 3.then(f4) // 4.then(f5) // 5.then(f6) // 6.then(f7) // 7.then(f8) // 8.then(f9); // 9 파라미터가 있는 비동기 함수1234567891011121314151617181920const f = (param) =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(param); // 비동기 함수(setTimeout)의 콜백 함수 안에서 // resolve 시켜줘야 순서를 보장할 수 있음. // 이 res 부분부터 then 안에 구문이 실행된다고 보면 된다. res(); &#125;, 1000)));// 후속 함수에게 new Promise를 리턴해주므로 thenable해서 계속 체이닝이 가능.f(1) // 1.then(() =&gt; f(2)) // 2.then(() =&gt; f(3)) // 3.then(() =&gt; f(4)) // 4.then(() =&gt; f(5)) // 5.then(() =&gt; f(6)) // 6.then(() =&gt; f(7)) // 7.then(() =&gt; f(8)) // 8.then(() =&gt; f(9)); // 9 현재 함수의 변수를 후속 함수에게 넘겨줘야하는 경우12345678910111213141516171819202122232425262728const f = (param) =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(param); // 비동기 함수(setTimeout)의 콜백 함수 안에서 // resolve 시켜줘야 순서를 보장할 수 있음. // 덤으로 후속 함수에게 파라미터(++param)을 넘기고 있음. // 이 res 부분부터 then 안에 구문이 실행된다고 보면 된다. res(++param); &#125;, 1000)));const f2 = (param) =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(param); res(); &#125;, 1000)));// 후속 함수에게 Promise를 리턴해주므로 thenable해서 계속 체이닝이 가능.f(1) // 1.then(param =&gt; f2(param)) // 2.then(() =&gt; f(3)) // 3.then(param =&gt; f2(param)) // 4.then(() =&gt; f(5)) // 5.then(param =&gt; f2(param)) // 6.then(() =&gt; f(7)) // 7.then(param =&gt; f2(param)) // 8.then(() =&gt; f(9)); // 9","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"promise","slug":"promise","permalink":"http://perfectacle.github.io/tags/promise/"},{"name":"callback","slug":"callback","permalink":"http://perfectacle.github.io/tags/callback/"}]},{"title":"(ES6+) 비동기 함수를 깔끔하게 처리해보자.","slug":"js-async-function","date":"2017-04-03T12:18:09.000Z","updated":"2017-04-04T13:20:31.000Z","comments":true,"path":"2017/04/03/js-async-function/","link":"","permalink":"http://perfectacle.github.io/2017/04/03/js-async-function/","excerpt":"","text":"전에 AJAX를 Promise와 Async/Await로 처리하는 방법을 알아봤는데,setTimeout과 같은 비동기 함수를 처리하려니 또 버퍼링이 걸려서 정리해봤다.너무 사용법 위주로 공부하다보니 나중에 또 정리를 하게 될 것 같다.AJAX를 비동기로 처리하고 싶은 사람은 아래 글을 참조하자.(ES6) ajax 위주의 promise 실습(ES6+) ajax를 위한 fetch와 async/await ~ES5(콜백 함수)순서가 보장되지만 피라미드 같이 생겼다.뎁스가 깊어질 수록 컨트롤하기가 어렵다.혹시 cb &amp;&amp; cb()의 동작 방식과 원리가 궁금한 사람은 아래 글을 참조하자.(ES) 똑똑한 논리 연산자1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const f1 = cb =&gt; setTimeout(() =&gt; &#123; console.log(1); // setTimeout의 콜백 함수 안에서 // 콜백함수(f1 함수의 매개변수인 cb) // 를 실행해야 실행 순서가 보장됨. // 매개변수로 넘어온 콜백함수(cb) // 가 없으면 실행하지 않음. cb &amp;&amp; cb();&#125;, 1000);const f2 = cb =&gt; setTimeout(() =&gt; &#123; console.log(2); cb &amp;&amp; cb();&#125;, 1000);const f3 = cb =&gt; setTimeout(() =&gt; &#123; console.log(3); cb &amp;&amp; cb();&#125;, 1000);const f4 = cb =&gt; setTimeout(() =&gt; &#123; console.log(4); cb &amp;&amp; cb();&#125;, 1000);const f5 = cb =&gt; setTimeout(() =&gt; &#123; console.log(5); cb &amp;&amp; cb();&#125;, 1000);const f6 = cb =&gt; setTimeout(() =&gt; &#123; console.log(6); cb &amp;&amp; cb();&#125;, 1000);const f7 = cb =&gt; setTimeout(() =&gt; &#123; console.log(7); cb &amp;&amp; cb();&#125;, 1000);const f8 = cb =&gt; setTimeout(() =&gt; &#123; console.log(8); cb &amp;&amp; cb();&#125;, 1000);const f9 = cb =&gt; setTimeout(() =&gt; &#123; console.log(9); cb &amp;&amp; cb();&#125;, 1000);f1( () =&gt; f2( () =&gt; f3( () =&gt; f4( () =&gt; f5( () =&gt; f6( () =&gt; f7( () =&gt; f8( () =&gt; f9() ) ) ) ) ) ) )); ES6(Promise)콜백 함수 패턴이 익숙해서 자주 쓰는데,뎁스가 깊어지니 뭔가 깔끔하게 정리해보고 싶었다.일단 나는 reject 되는 경우는 생각하지 않았다.그냥 내가 짠 비동기 함수를 동기식으로 실행시키길 원했을 뿐이니까...너무 사용 방법에만 치중하다보니 코드가 다소 복잡해보이기도 한다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const promise = cb =&gt; new Promise(res =&gt; &#123; // 콜백 함수 안에서 resolve 함수를 실행해야 순서가 보장됨. cb(res);&#125;);const f1 = cb =&gt; setTimeout(() =&gt; &#123; console.log(1); // setTimeout의 콜백 함수 안에서 // 콜백함수(f1 함수의 매개변수인 cb) // 를 실행해야 실행 순서가 보장됨. // 매개변수로 넘어온 콜백함수(cb) // 가 없으면 실행하지 않음. cb &amp;&amp; cb();&#125;, 1000);const f2 = cb =&gt; setTimeout(() =&gt; &#123; console.log(2); cb &amp;&amp; cb();&#125;, 1000);const f3 = cb =&gt; setTimeout(() =&gt; &#123; console.log(3); cb &amp;&amp; cb();&#125;, 1000);const f4 = cb =&gt; setTimeout(() =&gt; &#123; console.log(4); cb &amp;&amp; cb();&#125;, 1000);const f5 = cb =&gt; setTimeout(() =&gt; &#123; console.log(5); cb &amp;&amp; cb();&#125;, 1000);const f6 = cb =&gt; setTimeout(() =&gt; &#123; console.log(6); cb &amp;&amp; cb();&#125;, 1000);const f7 = cb =&gt; setTimeout(() =&gt; &#123; console.log(7); cb &amp;&amp; cb();&#125;, 1000);const f8 = cb =&gt; setTimeout(() =&gt; &#123; console.log(8); cb &amp;&amp; cb();&#125;, 1000);const f9 = cb =&gt; setTimeout(() =&gt; &#123; console.log(9); cb &amp;&amp; cb();&#125;, 1000);promise(f1).then(() =&gt; promise(f2)).then(() =&gt; promise(f3)).then(() =&gt; promise(f4)).then(() =&gt; promise(f5)).then(() =&gt; promise(f6)).then(() =&gt; promise(f7)).then(() =&gt; promise(f8)).then(() =&gt; promise(f9)); ES2017(Async/Await)크롬, 파폭, 사파리, 오페라 최신 버전에서는 지원하는 것 같은데 MS 진영은(엣지 포함) 암담하다.ECMAScript Next compatibility table MS나 하위 브라우저를 지원해야한다면Syntax async functions · Babel을 참고하자.Node.js LTS(v6.x)에서도 지원하지 않는 것 같으니 참고하자.Node.js ES2015/ES6, ES2016 and ES2017 support123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const promise = cb =&gt; new Promise(res =&gt; &#123; // 콜백 함수 안에서 resolve 함수를 실행해야 순서가 보장됨. cb(res);&#125;);const f1 = cb =&gt; setTimeout(() =&gt; &#123; console.log(1); // setTimeout의 콜백 함수 안에서 // 콜백함수(f1 함수의 매개변수인 cb) // 를 실행해야 실행 순서가 보장됨. // 매개변수로 넘어온 콜백함수(cb) // 가 없으면 실행하지 않음. cb &amp;&amp; cb();&#125;, 1000);const f2 = cb =&gt; setTimeout(() =&gt; &#123; console.log(2); cb &amp;&amp; cb();&#125;, 1000);const f3 = cb =&gt; setTimeout(() =&gt; &#123; console.log(3); cb &amp;&amp; cb();&#125;, 1000);const f4 = cb =&gt; setTimeout(() =&gt; &#123; console.log(4); cb &amp;&amp; cb();&#125;, 1000);const f5 = cb =&gt; setTimeout(() =&gt; &#123; console.log(5); cb &amp;&amp; cb();&#125;, 1000);const f6 = cb =&gt; setTimeout(() =&gt; &#123; console.log(6); cb &amp;&amp; cb();&#125;, 1000);const f7 = cb =&gt; setTimeout(() =&gt; &#123; console.log(7); cb &amp;&amp; cb();&#125;, 1000);const f8 = cb =&gt; setTimeout(() =&gt; &#123; console.log(8); cb &amp;&amp; cb();&#125;, 1000);const f9 = cb =&gt; setTimeout(() =&gt; &#123; console.log(9); cb &amp;&amp; cb();&#125;, 1000);// async 함수 안에서 비동기 코드 앞에 await를 붙여주면 된다.// 안타깝게도 async '함수'라서 호출을 위해 즉시 실행함수를 사용했다.(async () =&gt; &#123; await promise(f1); await promise(f2); await promise(f3); await promise(f4); await promise(f5); await promise(f6); await promise(f7); await promise(f8); await promise(f9);&#125;)(); 참조 링크 Promise - JavaScript | MDN - Mozilla Developer Network 바보들을 위한 Promise 강의 - 도대체 Promise는 어떻게 쓰는거야? | 감성 프로그래밍 Promise 를 사용하는 두 가지 방법, new Promise, Promise.resolve()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"promise","slug":"promise","permalink":"http://perfectacle.github.io/tags/promise/"},{"name":"ES6+","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"async","slug":"async","permalink":"http://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"http://perfectacle.github.io/tags/await/"},{"name":"callback","slug":"callback","permalink":"http://perfectacle.github.io/tags/callback/"}]},{"title":"(React Hot Loader) v3로 마이그레이션 해보자!","slug":"react-hot-loader-3","date":"2017-03-25T01:39:14.000Z","updated":"2017-04-03T23:23:07.000Z","comments":true,"path":"2017/03/25/react-hot-loader-3/","link":"","permalink":"http://perfectacle.github.io/2017/03/25/react-hot-loader-3/","excerpt":"","text":"들어가기에 앞서기본적으로 웹팩, 바벨, 리액트 라우터 등등은 안다는 전제 하에 글을 썼다.웹팩 2에 대한 모르는 부분은 아래 글을 조금씩 참조하면 도움이 될 것이다. (Webpack 2) 트리 쉐이킹을 해보자! (Webpack 2) 코드를 분할해보자! 또한 리액트 라우터 v4 예제로 진행할 것이므로 아래 포스트를 참고하고 소스 코드를 클론하자. (React Router) v4로 마이그레이션 해보자! 리액트 라우터 v4 소스 코드 리액트 핫 로더 v1지난 리액트 라우터 4 마이그레이션 포스트에서… 트리 쉐이킹 코드 스플리팅 HTML5 History API 까지 구현해보았다.이제 리액트의 컴포넌트를 Hot Module로 만들어서페이지 새로고침 없이도 수정 결과를 반영해주는 react-hot-loader를 사용해보자!리액트 핫 로더 v1 소스 코드에서 중간 중간 확인하면서 진행하도록 하자. 1npm i -D react-hot-loader 그리고 webpack.dev.config.js의 module 부분에서js 파일의 로더에 react-hot-loader를 추가하자.123456789&#123; module: &#123; rules: [&#123; test: /\\.js$/, use: ['react-hot-loader', 'babel-loader'], exclude: /node_modules/, &#125;] &#125;&#125; 또한 리액트 핫로더 v1은 트리 쉐이킹을 사용하면 번들링에 실패하므로.babelrc에서 다음과 같이 트리쉐이킹을 꺼주자.1234567891011121314&#123; \"presets\": [ [ \"env\", &#123; \"browsers\": [\"last 2 versions\", \"&gt; 10%\", \"ie 9\"] &#125; ], \"react\" ], \"plugins\": [ \"syntax-dynamic-import\" ]&#125; 그리고 테스트를 위해 About.js를 다음과 같이 함수형 컴포넌트에서 일반 클래스 컴포넌트로 바꿔주자.123456789101112import React, &#123;Component&#125; from 'react/lib/React';export default class About extends Component &#123; render() &#123; return( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125; npm start를 쳐서 webpack-dev-server를 띄우고http://localhost:3001/about/name으로 접속해보자.그 다음에 About.js를 수정해보면 페이지 새로고침 없이도 수정 내역이 잘 반영된다.그럼 이번에는 함수형 컴포넌트인 Name.js를 수정해보자.아마도 페이지가 새로고침 되면서 수정 내역이 반영될 것이다.이렇듯 리액트 라우터 4와 리액트 핫 로더 1에서는 다음과 같은 문제점이 존재한다. 출처: Server-side rendering, code-splitting, and hot reloading with React Router v4 No hot reloading for functional components Problems with high order components HOC(High Order Components)는 뭔지 잘 몰라서 테스트 해보지 못했다. v3으로 마이그레이션 해보자!여튼 함수형 컴포넌트가 제대로 핫 로드 되지 않고, 트리 쉐이킹 문제점을리액트 핫 로더 3에서는 해결했다고 하니 한번 믿고 설치해보자.또한 중간 중간 리액트 핫 로더 v3 소스 코드와 비교해보자.12npm un -D react-hot-loadernpm i -D react-hot-loader@next 마이그레이션 문서를 보고 하나하나 따라해보자. 바벨 설정 파일(.babelrc) 수정하기 1234567891011121314151617&#123; \"presets\": [ [ \"env\", &#123; \"browsers\": [\"last 2 versions\", \"&gt; 10%\", \"ie 9\"], // tree shaking \"modules\": false &#125; ], \"react\" ], \"plugins\": [ \"react-hot-loader/babel\", \"syntax-dynamic-import\" ]&#125; 플러그인에 react-hot-loader/babel을 추가하고, 트리 쉐이킹도 켰다.혹은 바벨을 사용하지 않거나 ES6 없이 바벨을 쓴다면 webpack.dev.config.js에서js의 로더 부분에 react-hot-loader/webpack을 추가해야한다.이번 포스트에서는 전자를 따르도록 하겠다.123456789&#123; module: &#123; rules: [&#123; test: /\\.js$/, use: ['react-hot-loader/webpack', 'babel-loader'], exclude: /node_modules/, &#125;] &#125;&#125; 웹팩 개발용 설정 파일(webpack.dev.config.js) 엔트리 수정하기react-hot-loader/patch를 엔트리 최상단에 넣어주자.혹시 바벨 폴리필을 쓴다면 그 이후에 넣어주면 된다. 1234567891011121314151617&#123; entry: [ 'react-hot-loader/patch', // activate HMR for React `webpack-dev-server/client?http://localhost:$&#123;port.dev&#125;`, // bundle the client for webpack-dev-server // and connect to the provided endpoint 'webpack/hot/only-dev-server', // bundle the client for hot reloading // only- means to only hot reload for successful updates resolve(ROOT, 'index-dev') // the entry point of our app ]&#125; 엔트리(index.js) 수정하기 ES2015의 Native Module을 사용하지 않은 경우바벨 설정 파일에서 따로 ES2015 프리셋의 modules 속성을 건드리지 않은 경우가 이에 속한다.아마 바벨은 CommonJS 규격을 따라 모듈화를 진행하는 것 같다. 12345678910111213141516171819if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === 'production' &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from 'react/lib/React';import &#123; render &#125; from 'react-dom';import App from './App';render(&lt;App /&gt;, document.getElementById('app'));if (module.hot) &#123; module.hot.accept('./App', () =&gt; &#123; const NextApp = require('./App').default; render(&lt;NextApp/&gt;, document.getElementById('app')); &#125;);&#125; ES2015의 Native Module을 사용한 경우(우리 소스 코드에 해당)웹팩 2부터는 ES2015의 Native Module을 지원하기 시작하였다.바벨 설정 파일에서 ES2015 프리셋의 modules 속성을 false로 준 경우가 이에 해당한다. 123456789101112131415161718if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === 'production' &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from 'react/lib/React';import &#123; render &#125; from 'react-dom';import App from './App';render(&lt;App /&gt;, document.getElementById('app'));if (module.hot) &#123; module.hot.accept('./App', () =&gt; &#123; render(&lt;App /&gt;, document.getElementById('app')); &#125;);&#125; AppContainer는 좀 이따 살펴보기로 하자. 리액트 라우터 4의 치명적인 단점은 코드 스플리팅과 리액트 핫 로더를 동시에 적용할 수 없다는 점이다. 정상적인 import 문으로 컴포넌트를 삽입하면 코드 스플리팅이 되지 않는다.따라서 const About2 = asyncComponent(() =&gt; import(&#39;./components/About&#39;).then(module =&gt; module.default));와 같이 써야한다.위와 같이 코드 스플리팅을 하면 왠지 모르겠으나 리액트 핫 로더가 먹히질 않는다.따라서 개발용 파일에서는 코드 스플리팅을 하지 않아야 정상적으로 리액트 핫 로더가 작동한다. 배포용 파일에서는 코드 스플리팅을 적용해 초기 로딩 시간을 단축시키고,개발할 용도가 아니기 때문에 리액트 핫 로더는 작동 안 해도 되니 붙이지 않으면 된다. app/src 폴더에 AppDev.js를 만들자.1234567891011121314151617181920212223242526272829303132333435363738import React from 'react/lib/React';// import &#123; BrowserRouter, HashRouter, Route, Redirect, Switch &#125; from 'react-router-dom';// 리액트 라우터를 코드 스플리팅 하려면 위 코드를 이렇게 하나씩 불러와야한다 귀찮 ㅠimport BrowserRouter from 'react-router-dom/es/BrowserRouter';import HashRouter from 'react-router-dom/es/HashRouter';import Route from 'react-router-dom/es/Route';import Redirect from 'react-router-dom/es/Redirect';import Switch from 'react-router-dom/es/Switch';// HTML5 History API 지원여부 파악const isBrowserHistory = history.pushState;const Router = isBrowserHistory ? BrowserRouter : HashRouter;import Menu from './components/Menu';import About from './components/About';import Home from './components/Home';import Name from './components/Name';import Portfolio from './components/Portfolio';const AppDev = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;Menu/&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/about/name\" component=&#123;Name&#125; /&gt; &lt;Switch&gt; &lt;Redirect to=\"/portfolio/0\" from=\"/about/redirect0\"/&gt; &lt;Redirect from=\"/about/redirect1\" to=\"/portfolio/1\"/&gt; &lt;/Switch&gt; &lt;Route exact path=\"/portfolio\" component=&#123;Portfolio&#125; /&gt; &lt;Route path=\"/portfolio/:id\" component=&#123;Portfolio&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;);export default AppDev; 개발용 엔트리를 app/src에 indexDev.js로 따로 파자.import 문은 모듈을 정적으로만 로딩 가능해서 부득이하게 엔트리를 하나 더 만들게 됐다.123456789101112131415161718if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === 'production' &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from 'react/lib/React';import &#123; render &#125; from 'react-dom';import AppDev from './AppDev';render(&lt;AppDev /&gt;, document.getElementById('app'));if (module.hot) &#123; module.hot.accept('./AppDev', () =&gt; &#123; render(&lt;AppDev /&gt;, document.getElementById('app')); &#125;);&#125; 배표용 엔트리(index.js)에서는 리액트 핫 로더를 떼버리자.123456789101112if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === 'production' &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from 'react/lib/React';import &#123; render &#125; from 'react-dom';import App from './App';render(&lt;App /&gt;, document.getElementById('app')); 웹팩 개발용 설정 파일(webpack.dev.config.js)에서 엔트리를 개발용 엔트리로 바꿔주자.12345678910111213141516&#123; entry: [ 'react-hot-loader/patch', `webpack-dev-server/client?http://localhost:$&#123;PORT&#125;`, // bundle the client for webpack-dev-server // and connect to the provided endpoint 'webpack/hot/only-dev-server', // bundle the client for hot reloading // only- means to only hot reload for successful updates resolve(ROOT, 'indexDev') // the entry point of our app ]&#125; 이제 모든 설정이 끝났다.npm start를 치면… 코드 스플리팅 X - 어차피 개발용이니 초기 로딩 속도는 크게 상관을 하지 않으면 됨. 리액트 핫 로더 O - 개발할 땐 이게 핵심이다. npm build를 치면… 코드 스플리팅 O - 실 사용자들에게 쾌적한 로딩 속도를 보장해줘야한다. 리액트 핫 로더 X - 배포용이기 때문에 내용을 수정하면서 확인할 일이 없다. AppConainer란?react-hot-loader v3은 redbox-react를 내장하고 있다.react-hot-loader v3에서 redbox-react를 사용하기 위해 AppContainer를 사용하는 것이다.소스맵을 붙이려면 express 프레임워크에 webpack-dev-server를 붙여야한다.안 그러면 위 스샷과 같이 소스맵이 붙질 않는다.또한 트랜스파일 이후의 코드를 가지고 소스맵을 붙이기 때문에 좀 헷갈리기도 한다.아직은 콘솔 창에 출력되게 끔 하는 게 더 나은 것 같지만…일단은 나와있으니 한 번 써보자.귀찮은 사람은 redbox-react 소스 코드를 클론 받자. indexDev.js에서 AppContainer를 갖다 붙이자.123456789101112131415161718192021222324252627if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === 'production' &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from 'react/lib/React';import &#123; render &#125; from 'react-dom';import AppContainer from 'react-hot-loader/lib/AppContainer';import App from './AppDev';render( &lt;AppContainer&gt; &lt;App /&gt; &lt;/AppContainer&gt;, document.getElementById('app'));if (module.hot) &#123; module.hot.accept('./AppDev', () =&gt; &#123; render( &lt;AppContainer&gt; &lt;App /&gt; &lt;/AppContainer&gt;, document.getElementById('app') ); &#125;);&#125; Home.js에서 일부러 오류를 내보자.1234567import React from 'react/lib/React';const Home = () =&gt; ( &lt;h2&gt;&#123;aa()&#125;Home&lt;/h2&gt;);export default Home; webpack.dev.config에서 devtool을 eval로 바꿔주자.다른 소스맵은 제대로 소스맵이 붙질 않는다. server.js 파일을 수정해서 express에 webpack-dev-server를 붙여보자.123456789101112131415161718192021222324252627282930const express = require('express');const app = express();const PORT = 3000;const DEV_PORT = 3001;const DIST = `$&#123;__dirname&#125;/app/dist/`;if(process.env.NODE_ENV === 'development') &#123; // dev-server config const Webpack = require('webpack'); const WebpackDevServer = require('webpack-dev-server'); const webpackConfig = require('./webpack.dev.config'); const compiler = Webpack(webpackConfig); const devServer = new WebpackDevServer(compiler, webpackConfig.devServer); // dev-server open devServer.listen(DEV_PORT, () =&gt; &#123; console.log('webpack-dev-server is listening on port', DEV_PORT); &#125;);&#125; else &#123; // server-open app.use('/', express.static(DIST)); app.listen(PORT, () =&gt; &#123; console.log('Express listening on port', PORT); &#125;);// client router app.get('*', (req, res) =&gt; &#123; res.sendFile(DIST); &#125;);&#125; process.env가 뭐하는 놈인지 처음 본 사람은 아래 링크를 참조하자.Node.js 에서 NODE_ENV 값으로 배포/개발 환경설정하기 이제 package.json의 start script 부분을 아래와 같이 수정해주자.1234567&#123; \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"NODE_ENV=development node server\", \"build\": \"rm -rf app/dist &amp;&amp; node_modules/webpack/bin/webpack.js &amp;&amp; node server\" &#125;&#125; 이제 다 끝났다.npm start 치고 http://localhost:3001/로 접속하면 아래와 같은 화면이 뜰 것이다. 참조 링크 React Hot Loader 3 Server-side rendering, code-splitting, and hot reloading with React Router v4 redbox-react Node.js 에서 NODE_ENV 값으로 배포/개발 환경설정하기","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"http://perfectacle.github.io/categories/Front-end/React/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"http://perfectacle.github.io/tags/Webpack2/"},{"name":"React","slug":"React","permalink":"http://perfectacle.github.io/tags/React/"},{"name":"Hot","slug":"Hot","permalink":"http://perfectacle.github.io/tags/Hot/"},{"name":"Loader","slug":"Loader","permalink":"http://perfectacle.github.io/tags/Loader/"}]},{"title":"(React Router) v4로 마이그레이션 해보자!","slug":"react-router-v4","date":"2017-03-24T16:39:14.000Z","updated":"2017-06-25T16:59:15.000Z","comments":true,"path":"2017/03/25/react-router-v4/","link":"","permalink":"http://perfectacle.github.io/2017/03/25/react-router-v4/","excerpt":"","text":"들어가기에 앞서React Router v4가 정식으로 나와서 3은 deprecated 된 거나 마찬가지라고 본다.~현재 React Router v3은 디프리케잇 되지 않고 React Router v4와 다른 노선을 탔을 뿐, 지원은 계속 해주는 것 같다.따라서 레거시 환경을 싫어하기도 해서 한 번 마이그레이션을 간단하게 해보았다.기본적으로 웹팩, 바벨, 리액트 라우터 등등은 안다는 전제 하에 글을 썼다.웹팩 2에 대한 모르는 부분은 아래 글을 조금씩 참조하면 도움이 될 것이다. (Webpack 2) 트리 쉐이킹을 해보자! (Webpack 2) 코드를 분할해보자! v3으로 만들어보기소스 코드는 정재남 님께서 제공해주신 소스를 이용했다.v3으로 만든 라이브 데모에서 직접 내용을 확인해보고 시작하자.혹시 만들기 귀찮거나 중간중간 확인할 사람은 소스 코드를 보도록 하자.서버는 없으니 새로고침을 하면 제대로 정보를 표시 못 하지만, 우리가 실제 진행할 때는Node.js의 express 프레임워크를 사용해서 새로고침을 해도 제대로 작동하게 만들 것이다. 전체적인 프로젝트 구조는 다음과 같다. 일단 packge.json 파일을 만들고 다음 패키지들을 설치하자.12npm i -D babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-env babel-preset-react webpack-dev-servernpm i -S express html-webpack-plugin react react-dom react-router@^3.x webpack babel-plugin-syntax-dynamic-import는 코드 스플리팅을 위해 추가한 플러그인이다..babelrc 파일을 만들고 아래와 같이 적어주자.12345678910111213141516&#123; \"presets\": [ [ \"env\", &#123; \"browsers\": [\"last 2 versions\", \"&gt; 10%\", \"ie 9\"], // tree shaking \"modules\": false &#125; ], \"react\" ], \"plugins\": [ \"syntax-dynamic-import\" ]&#125; presets 부분이 요상하게 적혀있는데 트리 쉐이킹을 위한 것이니 모르는 사람은(Webpack 2) 트리 쉐이킹을 해보자!을 참조하자. 이제 컴포넌트들을 하나 하나 작성해보자. 123456789101112// About.js// 프롭스 중에 children도 같이 렌더링한다.import React from 'react/lib/React';const About = (&#123;children&#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;div&gt;&#123;children&#125;&lt;/div&gt; &lt;/div&gt;);export default About; 1234567891011121314151617181920212223242526// Container.js// 상단에 메뉴(고정)들이 존재하고, 프롭스 중에 children 내용이 변경되면서 렌더링 된다.import React from 'react/lib/React';import Link from 'react-router/es/Link';const Container = (&#123;children&#125;) =&gt; ( &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about/name\"&gt;About - Name&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about/redirect0\"&gt;About - RedirectTo: Portfolio #0&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about/redirect1\"&gt;About - RedirectTo: Portfolio #1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/portfolio\"&gt;Portfolio - All&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/portfolio/0\"&gt;Portfoilo - #0&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/portfolio/1\"&gt;Portfoilo - #1&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;div&gt; &#123;children&#125; &lt;/div&gt; &lt;/div&gt;);export default Container; 123456// Home.jsimport React from 'react/lib/React';const Home = () =&gt; (&lt;h2&gt;Home&lt;/h2&gt;);export default Home; 123456// Name.jsimport React from 'react/lib/React';const Name = () =&gt; (&lt;h2&gt;Name&lt;/h2&gt;);export default Name; 12345678910111213141516171819202122// Portfolio.jsimport React from 'react/lib/React';const Portfolio = (&#123;routeParams: &#123;id&#125;&#125;) =&gt; &#123; const allList = [ &#123; id: 0, text: 'portfolio #0' &#125;, &#123; id: 1, text: 'portfolio #1' &#125; ]; const filterList = id ? allList.filter(v =&gt; v.id === +id) : allList; const renderList = filterList.map(v =&gt; ( &lt;li key=&#123;v.id&#125;&gt;&#123;v.text&#125;&lt;/li&gt; ) ); return ( &lt;div&gt; &lt;h2&gt;Portfolio&lt;/h2&gt; &lt;ul&gt;&#123;renderList&#125;&lt;/ul&gt; &lt;/div&gt; );&#125;;export default Portfolio; id는 추후에 우리가 정할 파라미터이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// App.jsimport React from 'react/lib/React';// import &#123; Router, Route, IndexRoute, Redirect, browserHistory, hashHistory &#125; from 'react-router';// 리액트 라우터를 코드 스플리팅 하려면 위 코드를 이렇게 하나씩 불러와야한다 귀찮 ㅠimport Router from 'react-router/es/Router';import Route from 'react-router/es/Route';import IndexRoute from 'react-router/es/IndexRoute';import Redirect from 'react-router/es/Redirect';import browserHistory from 'react-router/es/browserHistory';import hashHistory from 'react-router/es/hashHistory';// HTML5 History API 지원여부 파악const isBrowserHistory = history.pushState;// 리액트 라우터 3에서 코드 스플리팅 하기.const loadRoute = callback =&gt; module =&gt; callback(null, module.default);const App = () =&gt; ( &lt;Router history=&#123;isBrowserHistory ? browserHistory : hashHistory&#125;&gt; &lt;Route path=\"/\" getComponent=&#123; // component 대신에 getComponent를 써야 코드 스플리팅이 됨. (loaction, callback) =&gt; &#123; import('./components/Container').then(loadRoute(callback)) &#125;&#125;&gt; &lt;IndexRoute getComponent=&#123; // 요 아래 컴포넌트들은 전부 Container 라우트의 자식들이다. (loaction, callback) =&gt; &#123; import('./components/Home').then(loadRoute(callback)) &#125;&#125;/&gt; &lt;Route path=\"about\" getComponent=&#123; (loaction, callback) =&gt; &#123; import('./components/About').then(loadRoute(callback)) &#125;&#125;&gt; &lt;Route path=\"name\" getComponent=&#123; (loaction, callback) =&gt; &#123; import('./components/Name').then(loadRoute(callback)) &#125;&#125;/&gt; &lt;Route path=\"redirect0\" onEnter=&#123;(nextState, replace) =&gt; replace('/portfolio/0')&#125; /&gt; &lt;Redirect from=\"redirect1\" to=\"/portfolio/1\" /&gt; &lt;/Route&gt; &lt;Route path=\"portfolio(/:id)\" getComponent=&#123; // 파라미터 :id 때문에 위의 사진과 같이 파라미터가 id가 된 거다. // 괄호로 감쌌기 때문에 생략이 가능하다는 소리다. (loaction, callback) =&gt; &#123; import('./components/Portfolio').then(loadRoute(callback)) &#125;&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;);export default App; component 대신에 getComponent를 써서 코드 스플리팅을 하였다.또한 그 안에 import(component)와 같은 구문 때문에babel-plugin-syntax-dynamic-import를 쓰게 된 거다.혹시 코드 스플리팅에 대해 잘 모르는 사람은 (Webpack 2) 코드를 분할해보자!를 봐보자. 12345678910111213// index.jsif( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === 'production' &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from 'react/lib/React';import &#123; render &#125; from 'react-dom';import App from './App';render(&lt;App /&gt;, document.getElementById('app')); 마지막으로 index.html도 만들어주자.123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 이제 웹팩의 개발용 설정 파일을 작성하자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// webpack.dev.config.jsconst webpack = require('webpack');const &#123;resolve&#125; = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const PORT = 3001;const ROOT = './app/src';module.exports = &#123; devtool: 'inline-source-map', entry: [ `webpack-dev-server/client?http://localhost:$&#123;PORT&#125;`, // bundle the client for webpack-dev-server // and connect to the provided endpoint 'webpack/hot/only-dev-server', // bundle the client for hot reloading // only- means to only hot reload for successful updates resolve(ROOT, 'index') // the entry point of our app ], output: &#123; publicPath: '/', filename: 'bundle.js', &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), // enable HMR globally new webpack.NamedModulesPlugin(), // prints more readable module names in the browser console on HMR updates new HtmlWebpackPlugin(&#123; template: `$&#123;ROOT&#125;/index.html` &#125;) ], module: &#123; rules: [&#123; test: /\\.js$/, use: ['babel-loader'], exclude: /node_modules/, &#125;] &#125;, devServer: &#123; hot: true, inline: true, port: PORT, historyApiFallback: true, contentBase: ROOT &#125;&#125;;process.noDeprecation = true; 이제 배포용 웹팩 설정 파일을 작성하자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// webpack.config.js'use strict';const webpack = require('webpack');const &#123;resolve&#125; = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const ROOT = './app/src';const DIST = 'app/dist';module.exports = &#123; entry: &#123; app: ROOT + '/index.js', &#125;, output: &#123; filename: '[name].[chunkhash].js', path: resolve(__dirname, DIST), publicPath: '/' &#125;, plugins: [ new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 터미널 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', // 아래 부분이 핵심 minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.indexOf('node_modules') !== -1; &#125; &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), new HtmlWebpackPlugin(&#123; template: './app/src/index.html', minify: &#123; collapseWhitespace: true, conservativeCollapse: true, keepClosingSlash: true, removeComments: true, removeRedundantAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true &#125; &#125;) ], module: &#123; rules: [&#123; test: /\\.js$/, use: ['babel-loader'], exclude: /node_modules/, &#125;] &#125;&#125;;process.noDeprecation = true; chunkhash가 뭔지 모르는 사람도 역시 (Webpack 2) 코드를 분할해보자!를 봐보자. 이제 배포용 파일을 테스트 하기 위해 express 프레임워크를 써서 서버 설정 파일을 작성하자.12345678910111213141516// server.jsconst express = require('express');const app = express();const PORT = 3000;const DIST = `$&#123;__dirname&#125;/app/dist/`;// server-openapp.use('/', express.static(DIST));app.listen(PORT, () =&gt; &#123; console.log('Express listening on port', PORT);&#125;);// client routerapp.get('*', (req, res) =&gt; &#123; res.sendFile(DIST);&#125;); 작업을 편안하게 하기 위해 packge.json의 npm script를 수정해보자.1234567&#123; \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"./node_modules/webpack-dev-server/bin/webpack-dev-server.js -d --config webpack.dev.config.js\", \"build\": \"rm -rf app/dist &amp;&amp; node_modules/webpack/bin/webpack.js &amp;&amp; node server\" &#125;&#125; npm start라고 치고 http://localhost:3001/에 접속하면 개발용 버전으로 볼 수 있고(소스맵, 리액트 개발 도구) npm build라고 치고 http://localhost:3000/에 접속하면 배포용으로 볼 수 있다. (소스맵 X, 리액트 개발 도구 X) 윈도우 유저는 rm -rf에 해당하는 다른 명령어로 build 스크립트를 수정해야할 것이다. 리액트 라우터 v4로 마이그레이션 하기리액트 라우터 v3로 만드는 것도 좀 귀찮았는데 아직 마이그레이션은 시작도 하지 않았다.리액트 라우터 v4에서는 바뀐 게 참 많아서… 수정해야할 부분이 참 많다.혹시 따라하기 귀찮거나 중간 중간 확인하고 싶은 사람은 소스 코드를 확인하자. v3 때는 react-router 하나 밖에 못 봤던 것 같은데… 5개나 됐다.대표적으로 react-router, react-router-dom, react-router-native만 알아봤다. react-router = react-router-dom + react-router-native react-router-dom = Web 용 react-router react-router-native = App 용 react-router 나는 웹을 주로 사용하니 react-router-dom v4로 설치하자.12npm un -S react-routernpm i -S react-router-dom Container.js를 Menu.js로 이름을 바꾼 후 다음과 같이 수정하자.1234567891011121314151617181920212223// v4로 오면서 컨테이너로써의 기능을 상실하게 된다.// 즉 Route 컴포넌트는 자식을 가질 수 없게 됐다.import React from 'react/lib/React';import Link from 'react-router-dom/es/Link';const Menu = () =&gt; ( &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about/name\"&gt;About - Name&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about/redirect0\"&gt;About - RedirectTo: Portfolio #0&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about/redirect1\"&gt;About - RedirectTo: Portfolio #1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/portfolio\"&gt;Portfolio - All&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/portfolio/0\"&gt;Portfoilo - #0&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/portfolio/1\"&gt;Portfoilo - #1&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;/div&gt;);export default Menu; 123456789101112131415161718192021// Portfolio.jsimport React from 'react/lib/React';const Portfolio = (&#123; match: &#123;params: &#123;id&#125;&#125; &#125;) =&gt; &#123; const allList = [ &#123; id: 0, text: 'portfolio #0' &#125;, &#123; id: 1, text: 'portfolio #1' &#125; ]; const filterList = id ? allList.filter(v =&gt; v.id === +id) : allList; const renderList = filterList.map(v =&gt; &lt;li key=&#123;v.id&#125;&gt;&#123;v.text&#125;&lt;/li&gt; ); return ( &lt;div&gt; &lt;h2&gt;Portfolio&lt;/h2&gt; &lt;ul&gt;&#123;renderList&#125;&lt;/ul&gt; &lt;/div&gt; );&#125;;export default Portfolio; App.js가 가장 수정 사항이 많다…나도 원리 보다는 사용방법 위주로 익혔으니 자세한 내용은 공식 사이트를 참조하자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// App.jsimport React, &#123;Component&#125; from 'react/lib/React';// import &#123; BrowserRouter, HashRouter, Route, Redirect, Switch &#125; from 'react-router-dom';// 리액트 라우터를 코드 스플리팅 하려면 위 코드를 이렇게 하나씩 불러와야한다 귀찮 ㅠimport BrowserRouter from 'react-router-dom/es/BrowserRouter';import HashRouter from 'react-router-dom/es/HashRouter';import Route from 'react-router-dom/es/Route';import Redirect from 'react-router-dom/es/Redirect';import Switch from 'react-router-dom/es/Switch';import Menu from './components/Menu';// HTML5 History API 지원여부 파악const isBrowserHistory = history.pushState;const Router = isBrowserHistory ? BrowserRouter : HashRouter;// 리액트 라우터 4에서 코드 스플리팅 하기.// getComponent is a function that returns a promise for a component// It will not be called until the first mountconst asyncComponent = getComponent =&gt; ( class AsyncComponent extends Component &#123; constructor() &#123; super(); this.state = &#123;Component: AsyncComponent.Component&#125;; &#125; componentWillMount() &#123; if (!this.state.Component) &#123; getComponent().then(Component =&gt; &#123; AsyncComponent.Component = Component; this.setState(&#123;Component&#125;); &#125;); &#125; &#125; render() &#123; const &#123;Component&#125; = this.state; if(Component) &#123; return &lt;Component &#123;...this.props&#125; /&gt;; &#125; return null; &#125; &#125;);const About = asyncComponent(() =&gt; import('./components/About').then(module =&gt; module.default));const Home = asyncComponent(() =&gt; import('./components/Home').then(module =&gt; module.default));const Name = asyncComponent(() =&gt; import('./components/Name').then(module =&gt; module.default));const Portfolio = asyncComponent(() =&gt; import('./components/Portfolio').then(module =&gt; module.default));const App = () =&gt; ( // v3에는 Router 속성에 browserRouter or hashRouter가 들어갔는데, // v4에는 BrowserRouter or HashRouter가 Router까지 포함한다. // 또한 Router 안에는 하나의 컴포넌트만 들어가야한다. // 따라서 div 같은 컴포넌트로 그 안을 한 번 감싸줘야한다. // 또한 IndexRoute는 Route 컴포넌트의 exact라는 속성으로 대체되었다. // Redirect 컴포넌트는 Switch 컴포넌트로 감싸줘야 정상 작동한다. // 또한 파라미터는 괄호를 써서 생략 가능하던 것이 불가능해졌다. &lt;Router&gt; &lt;div&gt; &lt;Menu/&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/about/name\" component=&#123;Name&#125; /&gt; &lt;Switch&gt; &lt;Redirect to=\"/portfolio/0\" from=\"/about/redirect0\"/&gt; &lt;Redirect from=\"/about/redirect1\" to=\"/portfolio/1\"/&gt; &lt;/Switch&gt; &lt;Route exact path=\"/portfolio\" component=&#123;Portfolio&#125; /&gt; &lt;Route path=\"/portfolio/:id\" component=&#123;Portfolio&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;);export default App; 이렇게 하면 일단 내가 먼저 react-router v3으로 작성했던 내용들은 마이그레이션 됐다.npm start와 npm build를 통해 확인해보자.더 자세한 사용 방법들은 무조건 공식 사이트를 참조하자. 그리고 여기서 끝난 게 아니다.리액트 라우터 4는 리액트 핫 로더와도 문제가 있어서 리액트 핫 로더 3에서 해결했다고는 하지만…이 또한 어느 정도 문제가 존재해 추후에 해당 내용을 다뤄봐야겠다. 참조 링크 React Router: Declarative Routing for React.js Server-side rendering, code-splitting, and hot reloading with React Router v4 Quick and dirty code splitting with React Router v4 React-Router v4 Pre-Release 사용해보기","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"http://perfectacle.github.io/categories/Front-end/React/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"http://perfectacle.github.io/tags/Webpack2/"},{"name":"React","slug":"React","permalink":"http://perfectacle.github.io/tags/React/"},{"name":"Router","slug":"Router","permalink":"http://perfectacle.github.io/tags/Router/"}]},{"title":"(Webpack 2) 코드를 분할해보자!","slug":"webpack2-code-splitting","date":"2017-03-12T15:32:22.000Z","updated":"2017-07-31T12:40:25.000Z","comments":true,"path":"2017/03/13/webpack2-code-splitting/","link":"","permalink":"http://perfectacle.github.io/2017/03/13/webpack2-code-splitting/","excerpt":"","text":"들어가기에 앞서웹팩 2, 웹팩 1, 바벨, 리액트 등등에 대해서 기본적인 부분은 설명하지 않는다.또한 (Webpack 2) 트리 쉐이킹을 해보자!를 보고 나서 이 포스팅을 읽는 걸 추천한다. 코드를 왜 분할하지?SPA(Single Page Application)은 한 번에 모든 리소스를 로딩해서초기 로딩 이후에 페이지 이동이 매우 빠르다는 장점을 가지고 있다.하지만 앱의 규모가 커지면 모든 리소스를 한 번에 로딩하므로초기 로딩이 느려져 사용자 이탈을 유발하는 양날의 검을 가지고 있다. 1단계: 내 코드와 서드 파티(라이브러리/프레임워크) 코드를 분리해보자.HTTP 1.1 프로토콜은 2개의 http 요청을 병렬로 수행하게 돼있지만,모던 브라우저는 4개의 http 요청을 병렬로 수행한다.아래 링크를 참조하자.브라우저의 리소스 병렬 다운로드를 가로막는 자바스크립트 | 감성 프로그래밍따라서 내 코드와 서드 파티 코드를 동시에 다운로드 받으면 더 빠른 로딩이 가능하다.따라서 내 코드(app)와 서드 파티 코드(vendor)를 하나의 bundle.js에서 분리시키는 단계가 필요하다.리액트 대신에 다른 서드 파티로 진행해도 무방하다. 일단 프로젝트를 생성하자.123npm init --ynpm i -S react react-domnpm i -D babel-core babel-preset-env babel-preset-react babel-loader webapck 소스 코드는 src 폴더를 만들어 그 안에서 관리하도록 하겠다.엔트리의 진입점인 main.js를 만들자.1234567import React from 'react';import &#123;render&#125; from 'react-dom';render( &lt;h2&gt;히히헤헤&lt;/h2&gt;, document.getElementById('app')); webpack.config.js를 만들자.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const webpack = require('webpack');module.exports = &#123; entry: &#123; app: './src/main.js', // 아래와 같이 수동적으로 서드 파티들을 다 추가해줘야한다. // 장점으로는 자기가 빼고 싶은 서드 파티만 지정할 수 있다는 점이다. // 자신의 앱과 벤더의 크기를 균형있게 맞출 수가 있다. vendor: ['react', 'react-dom'] &#125;, output: &#123; // entry에 존재하는 app.js, vendor.js로 뽑혀 나온다. filename: '[name].js', path: './dist/', &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 터미널 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), // app.js에 들어갈만한 내용을 vendor로 빼주는 플러그인 new webpack.optimize.CommonsChunkPlugin(&#123; // 위에 vendor와 통일시켜줘야한다. name: 'vendor' &#125;), // 브라우저의 콘솔 창에 리액트를 프로덕션 모드로 빌드하라는 오류가 뜨는데 그걸 없애주는 플러그인 new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ], module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: &#123; presets: [ [ \"env\", &#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'], // tree shaking \"modules\": false &#125; ], \"react\" ] &#125; &#125; ] &#125;&#125;;// 로더 개발자를 위한 로그 제거process.noDeprecation = true; 위와 같이 해줘도 되는데 일일이 서드 파티를 적기 귀찮은 사람은 아래와 같이 하면 된다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const webpack = require('webpack');module.exports = &#123; entry: &#123; app: './src/main.js', &#125;, output: &#123; // entry에 존재하는 app.js, // new webpack.optimize.CommonsChunkPlugin의 name 값인 vendor.js로 뽑혀 나온다. filename: '[name].js', path: './dist/', &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 터미널 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), // app.js에 들어갈만한 내용을 vendor로 빼주는 플러그인 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', // 아래 부분이 핵심 minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.indexOf('node_modules') !== -1; &#125; &#125;), // 브라우저의 콘솔 창에 프로덕션 모드로 빌드하라는 오류가 뜨는데 그걸 없애주는 플러그인 new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ], module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: &#123; presets: [ [ \"env\", &#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'], // tree shaking \"modules\": false &#125; ], \"react\" ] &#125; &#125; ] &#125;&#125;;// 로더 개발자를 위한 로그 제거process.noDeprecation = true; 빌드를 할 때 마다 dist 폴더를 제거해야하므로 npm 스크립트를 이용하자.packge.json의 scripts 부분을 다음과 같이 수정하자.1234\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"rm -rf dist &amp;&amp; ./node_modules/webpack/bin/webpack.js\"&#125; rm -rf는 유닉스 기반 명령어이기 때문에 Mac OS, Linux, Unix 등등에서만 쓸 수 있다.윈도우에서는 아마 아래와 같이 하면 될 거다. (될런지는 모르겠다.)1234\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"rmdir dist /s &amp;&amp; ./node_modules/webpack/bin/webpack.js\"&#125; 그리고 터미널에 아래와 같이 치면 npm script를 쓸 수 있다.test, build, start만 아래와 같이 칠 수 있고 나머지는npm run scriptName과 같이 입력해야한다.1npm build 결과를 보면 벤더로 서드파티가 다 빠져서 파일 크기가 더 큰 걸 볼 수 있다.아마 우리가 작성한 앱은 아직 규모가 작기 때문일 것이다. 그리고 index.html을 만들어 테스트 해보자.vendor 보다 app이 더 먼저 삽입되면 오류가 난다.123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script src=\"./vendor.js\"&gt;&lt;/script&gt;&lt;script src=\"./app.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 라우터의 코드를 분할해보자!모든 사용자가 우리 앱의 모든 페이지를 돌아다니지 않는다.하지만 app.js에는 우리 앱의 모든 페이지 코드가 담겨있다.라우터를 통해 구분했던 페이지대로 코드를 분할시켜보자! hash vs chunkhash hash가 뭐지??기본적으로 브라우저에는 임시 파일, 캐시 데이터라고 불리는 임시 저장공간이 존재한다.이 임시 저장공간은 자신의 하드 공간의 일부에 해당한다.브라우저 속성에서 찾아보면 나올 것이다.만약 파일에 대한 요청이 있으면 처음에는 웹서버에서 다운 받고 임시 저장공간에 저장한다.하지만 동일한 요청이 또 오면 웹서버를 거치지 않고 하드에 있는 임시 저장공간에서 뒤져서해당 파일을 응답해줘서 더 빠른 응답을 하기 위한 기법이다.하지만 파일의 내용이 바뀌었는데도 임시 저장 공간에 있는 내용을 내려줘서변경된 파일이 보이지 않아 당황한 적이 많을 것이다.이렇게 파일이 변경 됐음에도 반영되지 않는 걸 방지하고자파일 이름에 hash라는 걸 붙이는 방법이다.hash는 복잡한데 그냥 암호화된 문자라고 대충 생각하면 될 것 같다.하지만 파일이 변경되지 않았을 때도 계속해서 다른 해쉬를 생성해서캐시 데이터의 장점을 전혀 이용할 수가 없다.이래서 나온 게 chunkhash다. chunkhash 짱짱맨!chunkhash는 해당 파일이 변경 됐을 때만 파일에 hash를 바꿔서 저장하는 것이다.즉 파일이 바뀌지 않았으면 똑같은 파일 이름에 대한 요청이므로 캐시 데이터를 쓰고,파일이 바뀌었으면 다른 해쉬가 파일 이름에 들어가 웹서버에 새로 요청해서수정된 내용을 즉각적으로 볼 수 있는 것이다.그렇담 chunk는??나도 잘 모르는데 그냥 페이지 별로 소스를 나눈 게 청크인 것으로 안다. hash의 사용법은 어렵지 않으므로 chunkhash만 설명하겠다.일단 chunkhash를 테스트하기 위해 리액트 라우터를 설치하자.또한 HTML5의 History API(리액트 라우터의 browserHistory)를 사용하기 위해node.js의 http 모듈을 사용해서 서버를 띄워보자.쌩으로 코딩하면 번거로우니까 express 모듈을 사용하도록 하자.react-router v4는 너무 변경사항이 많아서 일단은 3 버전을 토대로 설명한다.12npm i -S react-router@^3.xnpm i -D express 라우터를 테스트 하기 위해 두 개의 컴포넌트를 만들자.일단은 Comp.js12345678import React from 'react';import Link from 'react-router/es/Link';const Comp = () =&gt; ( &lt;div&gt; &lt;h2&gt;&lt;Link to=\"aa/bb/cc\"&gt;하이&lt;/Link&gt;&lt;/h2&gt; &lt;/div&gt;); Comp2.js도 만들자.12345678910import React from 'react';import Link from 'react-router/es/Link';const Comp2 = () =&gt; ( &lt;div&gt; &lt;h2&gt;&lt;Link to=\"/\"&gt;바이&lt;/Link&gt;&lt;/h2&gt; &lt;/div&gt;);export default Comp2; 엔트리의 진입점인 main.js도 수정하자.청크의 코드를 분할하는 방법에는 세 가지가 있다. System.importSystem.import is deprecateddeprecated 되었다. 쓰지 말자. import(module)Dynamic import귀찮다.바벨 플러그인(babel-plugin-syntax-dynamic-import)을 설치하고 설정해줘야 한다.청크의 이름을 지정할 수 없다.하지만 오류가 났을 때 catch()를 써서 처리 할 수 있다는데,뭐 그렇게 처리할만한 상황이 얼마나 있을까 싶다. require.ensure다른 거 설치 안 해도 되고, 청크의 이름을 지정할 수 있다.이 포스팅에서는 3번을 통해 청크 스플리팅을 해보겠다. 1234567891011121314151617181920212223242526import React from 'react';import &#123;render&#125; from 'react-dom';import Router from 'react-router/es/Router';import Route from 'react-router/es/Route';import browserHistory from 'react-router/es/browserHistory';render( // HTML5의 History API를 쓰기 위해 hashHistory 대신에 browserHistory를 사용하였다. &lt;Router history=&#123;browserHistory&#125;&gt; // component 대신에 getComponent를 사용하는 점을 주목하자. &lt;Route path=\"/\" getComponent=&#123;(location, callback) =&gt; &#123; // 아래 코드 부분이 핵심이다. // [] 부분 안에 디펜던시가 들어간다는데 언제 쓰게 되는지는 잘 모르겠다. require.ensure([], (require) =&gt; &#123; callback(null, require('./Comp').default); // 두 번째 인자로 청크의 이름이 들어간다. &#125;, 'Comp'); &#125;&#125; /&gt; &lt;Route path=\"/aa/bb/cc\" getComponent=&#123;(location, callback) =&gt; &#123; require.ensure([], (require) =&gt; &#123; callback(null, require('./Comp2').default); &#125;, 'Comp2'); &#125;&#125; /&gt; &lt;/Router&gt;, document.getElementById('app')); 이번엔 index.html를 수정하자.어떤 청크해쉬가 들어갈지 모르므로 script 태그를 빼버렸다.12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 이제 webpack.config.js를 수정해보자.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const webpack = require('webpack');module.exports = &#123; entry: &#123; app: './src/main.js', &#125;, output: &#123; // 요 놈은 저 위에 엔트리의 app에 대한 내용 filename: '[name].[chunkhash].js', // 요 놈은 페이지 별 청크에 대한 내용 chunkFilename: '[name].[chunkhash].js', path: `./dist`, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), // app.js에 들어갈만한 내용을 vendor로 빼주는 플러그인 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.indexOf('node_modules') !== -1; &#125;, // 요 놈은 vendor에 대한 내용 fileName: '[name].[chunkhash]' &#125;), // 브라우저의 콘솔 창에 프로덕션 모드로 빌드하라는 오류가 뜨는데 그걸 없애주는 플러그인 new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ], module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: &#123; presets: [ [ \"env\", &#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'], // tree shaking \"modules\": false &#125; ], \"react\" ] &#125; &#125; ] &#125;&#125;;// 로더 개발자를 위한 로그 제거process.noDeprecation = true; 이제 빌드를 해보자1npm build 빌드된 파일을 보면 두 가지 문제점이 존재한다. 뒤에 해쉬 값을 예측할 수가 없다. html 파일이 dist에 복사되지 않는다. 이럴 때 필요한 것은 html-webpack-plugin!설치하자.1npm i -D html-webpack-plugin webpack.config.js를 수정하자.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: &#123; app: './src/main.js', &#125;, output: &#123; // 요 놈은 저 위에 엔트리의 app에 대한 내용 filename: '[name].[chunkhash].js', // 요 놈은 페이지 별 청크에 대한 내용 chunkFilename: '[name].[chunkhash].js', path: './dist', // HTML5의 History API를 쓰다보면 라우터가 // http://localhost/aa/bb/cc 와 같이 뎁스가 깊어지는데 // 그럴 때 js 파일은 localhost를 기준으로 잡아야하므로 // 루트를 기준으로 잡아준 것이다. publicPath: '/' &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), // app.js에 들어갈만한 내용을 vendor로 빼주는 플러그인 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.indexOf('node_modules') !== -1; &#125;, // 요 놈은 vendor에 대한 내용 fileName: '[name].[chunkhash]' &#125;), // 브라우저의 콘솔 창에 프로덕션 모드로 빌드하라는 오류가 뜨는데 그걸 없애주는 플러그인 new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), // htmlWebpackPlugin을 쓰면 html 파일 복사 및 js, css inject를 할 수 있다. // 물론 minify도 가능하다. new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;) ], module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', options: &#123; presets: [ [ \"env\", &#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'], // tree shaking \"modules\": false &#125; ], \"react\" ] &#125; &#125; ] &#125;&#125;;// 로더 개발자를 위한 로그 제거process.noDeprecation = true; 이제 빌드를 해보자.1npm build dist 디렉토리를 보면 index.html이 생성되있고, 소스 코드를 봐보자.12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"/vendor.916f26b9c3a11d8f3204.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/app.f11205f23697a92f4153.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 해쉬가 정상적으로 붙어서 들어갔고, vendor가 먼저 들어갔고, 다른 페이지 청크는 들어가지 않았다.또한 루트 디렉토리를 뜻하는 /도 정상적으로 들어가있다.HTML5의 History API를 확인해보려면 실제 서버를 띄워야하므로 서버 코드를 작성해보자.server.js를 프로젝트의 최상위 디렉토리에 만들자.12345678910111213141516171819const express = require('express');const app = express();// 루트 디렉토리(/)로 오면 dist 디렉토리에 있는 index.html을 불러옴.// 서버 라우터일 거다. 아마도...app.use('/', express.static(__dirname + `/dist`));// 8080 포트로 서버 오픈app.listen(8080, () =&gt; &#123; console.log('Express listening on port', 8080);&#125;);// 클라이언트 라우터(일거다... 아마도...)인 react-router의 HTML5 History API를 사용하기 위함.// http 메소드 중에 get을 사용해서 모든 라우터(*)로 접근할 경우에(요청할 경우에)app.get('*', (req, res) =&gt; &#123; // 요청(request)에 대한 응답(response)으로 dist 디렉토리의 index.html을 돌려준다. // __dirname은 노드 js의 전역 변수인데 현재 디렉토리(풀 디렉토리, 절대 경로)를 반환하는 변수이다. res.sendFile(__dirname + '/dist/index.html');&#125;); 터미널에서 이제 노드 서버를 켜보자.1node server 브라우저에서 실제로 테스트 해보자.http://localhost:8080으로 접속한 결과다.크롬 개발자 도구의 네트워크 탭을 보면 Comp.[chunkhash]만 있고 Comp2는 로드하지 않았다.하이 라는 링크를 클릭하면 http://localhost:8080/aa/bb/cc로 이동한다.여기서 다시 네트워크 탭을 봐보자.페이지를 처음부터 로딩하는 게 아니라 새로운 부분인Comp2.[chunkhash] 부분만 로딩한 것을 볼 수 있다.여기서 새로고침을 해보자.역시 Comp2.[chunkhash]만 로드하고 Comp는 로드하지 않았다.바이 라는 링크를 클릭하면 http://localhost:8080/으로 이동한다.역시 페이지를 처음부터 로딩하는 게 아니라 새로운 부분인Comp.[chunkhash] 부분만 로딩한 것을 볼 수 있다. 조금이나마 최적화에 한 단계 다가간 것 같아 뿌듯하다.끝 !! 참조링크 웹팩2로 청크 관리 및 코드 스플리팅 하기 브라우저의 리소스 병렬 다운로드를 가로막는 자바스크립트 | 감성 프로그래밍 Code Splitting - Libraries A beginner’s step-by-step guide to Code Splitting with Webpack 2 and React Router등등…","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"http://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"http://perfectacle.github.io/tags/Webpack2/"},{"name":"babel","slug":"babel","permalink":"http://perfectacle.github.io/tags/babel/"}]},{"title":"(Webpack 2) 트리 쉐이킹을 해보자!","slug":"webpack2-tree-shaking","date":"2017-03-12T10:32:22.000Z","updated":"2017-07-31T12:40:05.000Z","comments":true,"path":"2017/03/12/webpack2-tree-shaking/","link":"","permalink":"http://perfectacle.github.io/2017/03/12/webpack2-tree-shaking/","excerpt":"","text":"들어가기에 앞서여기선 기본적으로 웹팩 1, 바벨, ES2015(ES6)을 알고 있다는 전제로 진행한다.리액트 대신에 다른 서드 파티(라이브러리/프레임워크) 가지고 테스트하면서 이 글을 봐도 된다.또한 이 글을 보고 나서 (Webpack 2) 코드를 분할해보자!도 보는 걸 추천한다. 트리 쉐이킹(Tree Shaking)??트리 쉐이킹이란 나무를 흔들어서 필요없는 걸 떨어트리는 행위를 말한다.여기서 우리에게 필요없는 것이란 쓰지 않는 코드를 뜻한다. 우리의 코드를 트리 쉐이킹 해보자기존 웹팩 1에서 번들링이 어떻게 이루어졌는지 보자. 우선 모듈을 하나 만들어보자. (module.js)12export const a = 123123123123;export const b = 45645646456; 그리고 이 모듈을 불러다 쓰는 우리의 앱을 만들자. (app.js)12import &#123;a&#125; from './module';console.log(a); 하지만 번들링을 해보면 아래와 같이 쓰지도 않은 b가 들어가있는 반쪽짜리 모듈화가 된 셈이다.아마 이게 ES2015의 Native Import가 아닌 CommonJS 스타일?인 것으로 알고 있다.12345678910111213141516171819202122232425/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; 'use strict'; var _moduleA = __webpack_require__(1); console.log(_moduleA.a);/***/ &#125;,/* 1 *//***/ function(module, exports) &#123; \"use strict\"; Object.defineProperty(exports, \"__esModule\", &#123; value: true &#125;); var a = exports.a = 123123123123; var b = exports.b = 45645646456;/***/ &#125;/******/ ]); 하지만 웹팩 2에서는 이런 ES2015 Native Import를 지원함으로써쓸 데 없는 녀석(const b)을 나무에서 떨어트리는 트리 쉐이킹이 가능해진 것이다.바로 알아보자! 일단 프로젝트를 하나 만들고 웹팩을 설치해보자.12npm init --ynpm i -D webpack 위에 적어놓은 app.js와 module.js를 똑같이 만들자.그리고 webpack.config.js를 만들어서 아래와 같이 만들어주자.바벨 없이 import/export를 쓸 수 있는 건 혁명이다!!1234567module.exports = &#123; entry: './app.js', output: &#123; filename: 'bundle.js', path: `./` &#125;&#125;; 그리고 터미널에서 아래와 같이 번들링을 해보자.1./node_modules/webpack/bin/webpack.js 하지만 번들링된 녀석을 보면 여전히 b가 남아있다.12345678910111213141516171819202122232425/************************************************************************//******/ ([/* 0 *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;\"use strict\";const a = 123123123123;/* harmony export (immutable) */ __webpack_exports__[\"a\"] = a;const b = 45645646456;/* unused harmony export b *//***/ &#125;),/* 1 *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;\"use strict\";Object.defineProperty(__webpack_exports__, \"__esModule\", &#123; value: true &#125;);/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__module__ = __webpack_require__(0);console.log(__WEBPACK_IMPORTED_MODULE_0__module__[\"a\"]);/***/ &#125;)/******/ ]); 트리 쉐이킹을 위해선 웹팩 2의 플러그인인 UglifyJS2를 이용하면 된다.이제 webpack.config.js를 수정해주자.123456789101112131415161718192021222324252627const webpack = require('webpack');module.exports = &#123; entry: './app.js', output: &#123; filename: 'bundle.js', path: `./`, &#125;, // 여기부터 추가된 내용 plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; // 사실 아래와 같이만 써도 트리 쉐이킹이 된다. // compress: true compress: &#123; // warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮다면 요 놈을 주석 제거하면 된다. unused: true // 요 놈이 핵심 &#125;, mangle: false, // DEMO ONLY: Don't change variable names.(난독화) beautify: true, // DEMO ONLY: Preserve whitespace (가독성 좋게 함) output: &#123; comments: true // DEMO ONLY: Helpful comments (주석 삭제 안 함) &#125; &#125;) ]&#125;; 그리고 다시 아래와 같이 터미널에서 번들링을 해주자.1./node_modules/webpack/bin/webpack.js 그럼 아래와 같은 로그가 터미널에 뜬다.123WARNING in bundle.js from UglifyJsCollapsing constant a [bundle.js:75,60]Dropping unused variable b [bundle.js:77,6] Dropping unused variable b [bundle.js:77,6]위 부분이 핵심이다.다시 번들링 된 코드를 보면 깔끔하게 b가 제거된 것을 볼 수 있다. 1234567/* 0 *//***/function(module, __webpack_exports__, __webpack_require__) &#123; \"use strict\"; /* harmony export (immutable) */ __webpack_exports__.a = 123123123123;&#125; 서드파티(라이브러리/프레임워크)를 트리 쉐이킹 해보자이 챕터는 다소 문제가 많다.서드파티마다 모듈화 한 방식이 제각각이라 트리 쉐이킹 하는 방법이 다양하고,나도 처음 접하다 보니 모든 서드 파티를 테스트 할 수가 없어서 대표적으로react-router(4는 너무 변경 사항이 많아서 3) 요 놈만 건드려보았다. react-router를 사용하기 위해 react를 설치해야 하고,react를 사용하려면 react-dom도 설치해야하고,또한 react를 쓰기 위해선 babel-preset-react를 설치해야하는데,babel-preset-react를 쓰기 위해선 babel-core도 설치해야하고,webpack에서 bable을 사용하기 위해선 bable-loader도 설치해야 하고,uglifyJS2가 ES2015를 완벽하게 지원하지 않아서babel-preset-2015(여기선 babel-preset-env)를 설치해야한다.위에 절차가 복잡하므로 이해하지 말고 그냥 설치해버리자.12npm i -S react react-dom react-router@^3.xnpm i -D babel-core babel-preset-env babel-preset-react babel-loader index.html 파일을 만들자.123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script src=\"./bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 라우팅 할 컴포넌트 Comp.js를 하나 만들자.12345import React from 'react';const Comp = () =&gt; &lt;h2&gt;하이&lt;/h2&gt;;export default Comp; 그리고 app.js를 다음과 같이 수정해보자.123456789101112import React from 'react/lib/React';import &#123;render&#125; from 'react-dom/lib/ReactDOM'; import &#123;Router, Route, hashHistory&#125; from 'react-router';import Comp from './Comp';render( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;Comp&#125; /&gt; &lt;/Router&gt;, document.getElementById('app')); webpack.config.json에 바벨 로더를 붙이자.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const webpack = require('webpack');module.exports = &#123; entry: './app.js', output: &#123; filename: 'bundle.js', path: `./`, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; // 사실 아래와 같이만 써도 트리 쉐이킹이 된다. // compress: true compress: &#123; // warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮다면 요 놈을 주석 제거를 하면 된다. unused: true // 요 놈이 핵심 &#125;, mangle: false, // DEMO ONLY: Don't change variable names.(난독화) beautify: true, // DEMO ONLY: Preserve whitespace (가독성 좋게 함) output: &#123; comments: true // DEMO ONLY: Helpful comments (주석 삭제 안 함) &#125; &#125;), // 여기서부터 추가된 내용. // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true, &#125;), ], module: &#123; // 웹팩 1에서는 loaders를 썼지만 2에선 rules rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, // 쿼리가 필요한 로더는 loader로 써줘야함. // 쿼리가 필요 없는 로더는 use로 써도 된다. // 웹팩 2에선 babel-loader와 같이 -loader 생략이 불가능해졌다. loader: 'babel-loader', // babel-loader?머시기와 같은 쿼리나 query: 옵션 대신에 // 웹팩 2에선 options: 로 바뀜. // .babelrc로 따로 빼줘도 상관 없다. options: &#123; presets: [ [ \"env\", &#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'], // babel-preset-2015에서는 Native Module을 쓰지 않는 것인지 // 아래 옵션을 주지 않으면 우리가 만든 코드(ES2015의 import/export Syntax)가 // 트리 쉐이킹 되질 않는다. \"modules\": false &#125; ], \"react\" ] &#125; &#125; ] &#125;&#125;;// DeprecationWarning: loaderUtils.parseQuery() received a non-string value which can be problematic, see https://github.com/webpack/loader-utils/issues/56// parseQuery() will be replaced with getOptions() in the next major version of loader-utils.// 위와 같이 로더 개발자를 위한 로그가 뜨는데 보기 싫다면 주석을 제거하면 된다.// process.noDeprecation = true; 이제 번들링 된 파일을 보면 우리가 import 시키지도 않은 browserHistory가 들어있다.12345678/* 211 *//***/function(module, __webpack_exports__, __webpack_require__) &#123; \"use strict\"; /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_history_lib_createBrowserHistory__ = __webpack_require__(129), __WEBPACK_IMPORTED_MODULE_0_history_lib_createBrowserHistory___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_history_lib_createBrowserHistory__), __WEBPACK_IMPORTED_MODULE_1__createRouterHistory__ = __webpack_require__(103); __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__createRouterHistory__.a)(__WEBPACK_IMPORTED_MODULE_0_history_lib_createBrowserHistory___default.a);&#125; 이렇듯 서드 파티들은 트리 쉐이킹이 제대로 되지 않는다.아마 서드파티 제작자들도 우리가 쓴 ES2015의 import/export 문법을 썼지만 배포할 때는babel-preset-2015의 Native가 아닌 모듈로 트랜스파일 된 놈이 배포되기 때문에 그런 게 아닐까 싶다.따라서 아래와 같이 별개의 모듈일 일일이 불러오는 번거로운 작업을 해줘야한다.1234567891011121314import React from 'react/lib/React';import &#123;render&#125; from 'react-dom/lib/ReactDOM';import Router from 'react-router/es/Router';import Route from 'react-router/es/Route';import hashHistory from 'react-router/es/hashHistory';import Comp from './Comp';render( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;Comp&#125; /&gt; &lt;/Router&gt;, document.getElementById('app')); 다른 서드 파티들은 바로 import 시켜도 트리 쉐이킹 되는 애들도 있을 것이지만,대부분의 서드 파티가 업데이트 되기 전까지는 저렇게 일일이 import 시켜줘야하는 번거로움이 있다. 참조 링크 웹팩2(Webpack) 설정하기 Webpack 2 Tree Shaking Configuration Webpack2 Guides UglifyJS2등등 너무 많아서 증발함… 혹시 틀린 내용이 있다면 무한 태클 환영입니다 ~","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"http://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"http://perfectacle.github.io/tags/Webpack2/"},{"name":"babel","slug":"babel","permalink":"http://perfectacle.github.io/tags/babel/"}]},{"title":"(자작) perf-chk (Node.js 애플리케이션)","slug":"perf-chk","date":"2017-03-01T07:24:02.000Z","updated":"2017-06-25T17:14:28.000Z","comments":true,"path":"2017/03/01/perf-chk/","link":"","permalink":"http://perfectacle.github.io/2017/03/01/perf-chk/","excerpt":"","text":"perf-chk (Performance Check)왜 perf-chk를 만들었나?나는 코드 실행 시간에 굉장히 관심이 많다.따라서 코드 실행 시간 측정을 위해 테스트를 종종 해보곤 한다.그럴 때 아래와 같은 코드를 사용하였다.1234567891011const iterations = 10000000;console.time(\"function A\");for(let i=0; i&lt;iterations; i++)&#123; // some code1&#125;console.timeEnd(\"function A\"); // 'Function A: xxx.xxx ms'console.time(\"function B\");for(let i=0; i&lt;iterations; i++)&#123; // some code2&#125;console.timeEnd(\"function B\"); // 'Function B: xxx.xxx ms' 하지만 위 코드를 엄청 자주 쓰지 않다보니 암기가 되질 않았다.따라서 매일 어디선가 복사 붙여넣기 해서 썼다.또한 함수명, 코드, 반복 횟수를 일일이 바꿔가는 것도 귀찮았다.이러한 귀찮음을 조금이라도 줄여보고자 perf-chk를 만들게 되었다. perf-chk는 무엇인가?Node.js에서 코드의 실행 시간을 측정해주는 CLI 도구이다.Node.js 어플리케이션이라고 하는 게 맞을라나…?여튼 내가 짠 코드 중에 어떤 코드가 더 빠른지 알아보고자 할 때 쓰면 된다. 시작하기perf-chk는 몇몇 ES6 문법들을 사용한다. (const, arrow function)따라서 Node.js v6.4.0 이상이 설치돼있어야만 한다. 설치 global로 설치하기 (권장) 1npm i -g perf-chk local로 설치하기 1npm i -D perf-chk 사용법1. 테스트 할 코드를 생성하자. (모듈)1234567891011121314// some code// blahblahmodule.exports = &#123; methodA: function() &#123; // ES5 function 문법 // blahblah &#125;, methodB() &#123; // ES6 Method 문법 // blahblah &#125;, methodC: () =&gt; &#123; // ES6 Arrow Function 문법 // blahblah &#125;&#125; 참고 module.exports = {} 는 node.js의 모듈 추출 문법이다.perf-chk는 node.js 어플리케이션이므로 이 문법을 준수해야만 정상 작동된다. 함수 문법은 입맛에 맞게 골라쓰면 된다. 2. 실행 시간을 체크하자. CLI 도구이므로 터미널을 열자. (윈도우에서는 cmd) 명령어를 아래와 같이 치자. 1perf-chk &#123;모듈_이름&#125; [반복_횟수] 만약 local로 설치했다면 아래와 같이 입력하자.1./node_modules/perf-chk &#123;모듈_이름&#125; [반복_횟수] note모듈_이름은 필수적이고, &lt;파일이름&gt;.js나 &lt;파일이름&gt;과 같이 치면 된다.반복_횟수는 선택사항이며 기본 값은 100,000,000이다.반복_횟수는 신뢰할 수 있는 정수(자연수)여야만 하며,범위는 1 ~ 9,007,199,254,740,991까지다.만약 코드들의 실행 시간이 모두 비슷하다면 큰 차이가 없는 것이다.그럼에도 불구하고 코드들 사이의 실행 시간 차이를 알아보고 싶다면반복 횟수를 늘려가며 실험해보면 된다. 주의사항 실행 시간은 매번 동일하지 않다.이는 컴퓨터 사양에 따라 결과가 달라진다. (CPU, RAM 등등)또한 동일한 컴퓨터 사양이라고 해서 결과가 모두 같은 건 아니다.왜냐하면 CPU 사용량과 RAM 사용량이 항상 같은 것은 아니기 때문이다.따라서 실행 시간은 단순 참고용 정도로만 사용하자. perf-chk는 Node.js 위에서 돌아간다.따라서 브라우저 내장 객체인 DOM(Document Object Model, 예를 들면 document.getElementById),BOM(Browser Object Model, 예를 들면 window.alert)와 같은 걸 지원하지 않는다.오직 ECMAScript만 테스트 할 수 있다.Node.js 버전에 따라 ECMAScript 지원율도 다르다.궁금한 사람은 아래 링크를 참조하자.Node.js ECMAScript compatibility tables","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"자작","slug":"기타/자작","permalink":"http://perfectacle.github.io/categories/기타/자작/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Performance","slug":"Performance","permalink":"http://perfectacle.github.io/tags/Performance/"},{"name":"CLI","slug":"CLI","permalink":"http://perfectacle.github.io/tags/CLI/"}]},{"title":"(ES) this","slug":"es-this","date":"2017-02-15T00:00:37.000Z","updated":"2017-02-15T02:05:48.000Z","comments":true,"path":"2017/02/15/es-this/","link":"","permalink":"http://perfectacle.github.io/2017/02/15/es-this/","excerpt":"","text":"자바스크립트에서 this는 상황에 따라 다른 값을 반환해서 아주 짜증나기 마련이다.이와 관련해서 하나하나 낱낱이 테스트해보자. ES5함수로서 호출할 때1234567'use strict';var a = function() &#123; // 함수로서 호출할 때 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this);&#125;;a(); 생성자 함수로서 호출할 때123456789'use strict';var b = function() &#123; // 생성자로서 호출할 때 this.a = '1'; this.b = function() &#123;&#125;; // this === &#123;a: 1, b: function() &#123;&#125;&#125; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 console.log(this);&#125;;new b(); 객체의 메소드로서 호출할 때123456789101112131415161718192021'use strict';var C = &#123; a: function() &#123; // 메소드로서 호출할 때 console.log(this); // C &#125;, b: function() &#123; // 메소드로서 호출할 때 var a = function() &#123; // 함수로서 호출해버리면 this를 재바인딩함. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125;, c: function() &#123; // 메소드로서 호출할 때 // 메소드를 호출 this.a(); // C &#125;&#125;;C.a();C.b();C.c(); ES6새로 나온 애로우 펑션은 this를 바인딩하지 않는다.call, apply, bind 메소드로도 강제 바인딩이 이루어지지 않는다.상위 스코프로부터 상속 받을 뿐이다. 일반 함수로서 호출할 때123456const a = function() &#123; // 함수로서 호출할 때 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this);&#125;;a(); 애로우 펑션으로서 호출할 때1234567891011121314const b = () =&gt; &#123; // 애로우 펑션은 strict mode 여부에 상관없이 Window // 전역에서 this가 Window이기 때문에 상속받는 것임. console.log(this); // Window&#125;;b();const _b = () =&gt; &#123; console.log(this);&#125;;// 전부 다 Window가 출력됨_b.call(&#123;a: 1&#125;);_b.apply(&#123;a: 1&#125;);_b.bind(&#123;a: 1&#125;)(); 클래스ES6 들어서 생성자 함수를 대체할 녀석으로 클래스가 등장하였다.이 클래스에서도 this를 낯낯이 파헤쳐보자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// 함수를 통해 객체의 인스턴스를 생성하던 것 대신에 클래스가 등장함.// 멤버: 변수와 메소드// 클래스 멤버: new 생성자 함수를 통해 생성된 인스턴스마다 동일한 값을 가짐.(공유함)// 클래스의 인스턴스가 생기기 전에도 클래스이름.멤버로 사용 가능.// static으로 생성된 메소드 및 prototype이 이에 해당.// 인스턴스 멤버: new 생성자 함수를 통해 생성된 인스턴스마다 다른 값을 가짐.(공유하지 않음)// 클래스의 인스턴스가 생기기 전에는 사용 불가능, 인스턴스이름.멤버로 사용 가능// 생성자 함수 내부에 작성된 애들이나 static 키워드를 쓰지 않고 생성한 메소드들이 해당됨.class C &#123; constructor() &#123; // 생성자 함수 외부에서 인스턴스 변수를 선언하지 못한다. this.a = 1; this.b = () =&gt; &#123;&#125;; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.log(this); &#125; // 클래스 메소드의 this는 // 클래스 멤버(변수, 메소드) 등등을 담고있는 생성자 함수이다. // 클래스 변수는 클래스 내에서 선언하지 못하고, // className.prototype.variable = value 와 같이 선언한다. static a() &#123; // function, 함수 또한 객체기 때문에 프로퍼티로 접근이 가능하다. console.log(typeof this); // new this(); 이렇게 생성자를 호출할 수도 있다. // __proto__는 상속받는 놈들이기 때문에 바로 this.머시기로 사용할 수 있었으나 // prototype은 상속해주는 놈들이기 때문에 this.prototype.머시기로 사용해야한다. // &#123; // a: function() &#123;&#125;, // b: function() &#123;&#125;, // c: function() &#123;&#125;, // prototype: &#123; // a: 1 // &#125; // &#125; console.dir(this); &#125; static b() &#123; const a = function() &#123; // 함수로서 호출하면 this를 재바인딩 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125; static c() &#123; const a = () =&gt; &#123; // 애로우 펑션은 this를 상속받음. // function, 함수 또한 객체기 때문에 프로퍼티로 접근이 가능하다. console.log(typeof this); // new this(); 이렇게 생성자를 호출할 수도 있다. // __proto__는 상속받는 놈들이기 때문에 바로 this.머시기로 사용할 수 있었으나 // prototype은 상속해주는 놈들이기 때문에 this.prototype.머시기로 사용해야한다. // &#123; // a: function() &#123;&#125;, // b: function() &#123;&#125;, // c: function() &#123;&#125;, // prototype: &#123; // a: 1 // &#125; // &#125; console.dir(this); &#125;; a(); &#125; // 인스턴스 메소드의 this는 생성자 내의 this와 일치한다. d() &#123; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.dir(this); &#125; e() &#123; const a = function() &#123; // 역시 ES5식 함수는 this를 덮어버린다. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125; f() &#123; const a = () =&gt; &#123; // 역시 애로우 펑션은 this를 상속 받음. // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.log(this); &#125;; a(); &#125; g() &#123; // 인스턴스의 this에 클래스 멤버는 없다. // 따라서 클래스 멤버를 사용할 수는 없다. // this.a(); // 클래스 메소드 사용 불가. this.f(); // 인스턴스 멤버(메소드, 변수)는 사용 가능하다. &#125;&#125;// 클래스 변수는 클래스 내에서 선언하지 못함.// 레거시 환경을 지원하기 위해// 프로토타입 방식의 상속을 포기하지 못했기 때문인 걸까??C.prototype.q = 1;const c = new C();C.a();C.b();C.c();c.d();c.e();c.f();c.g(); 객체의 메소드로서 호출할 때ES6에서 객체의 메소드를key: function() {} 대신에key() {}와 같이 줄여쓸 수 있게 됐는데 두 개는 동일하다고 봐도 된다.12345678910111213141516171819202122232425262728293031const d = &#123; a: function() &#123; // 메소드로서 호출할 때 console.log(this); // d &#125;, b: () =&gt; &#123; // 애로우 펑션은 바로 상위 스코프인 전역의 this를 상속받음. console.log(this); // Window &#125;, c() &#123; // a 메소드와 다를 바가 없다. console.log(this); // d &#125;, d() &#123; // 메소드로서 호출할 때 const a = function() &#123; // 역시 그냥 펑션은 this를 재바인딩함. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125;, e() &#123; // 메소드로서 호출할 때 const a = () =&gt; &#123; // 애로우 펑션은 상위 스코프에 있는 this를 상속 받음. console.log(this); // d &#125;; a(); &#125;&#125;;d.a();d.b();d.c();d.d();d.e(); this를 바인딩하는 콜백함수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// [1].forEach()의 this인 &#123;a: '11'&#125;에 가려진다.// 그 이유는 forEach와 같은 함수는 자동으로 this를 바인딩하려는 성질이 있다.[0].forEach(d.a, &#123;a: '11'&#125;); // &#123;a: '11'&#125;// 콜백 함수 내부에서 써야 외부의 this로부터 영향을 받지 않는다.[0].forEach(function() &#123; d.e(); // d&#125;, &#123;a: '11'&#125;);[0].forEach(() =&gt; d.e(), &#123;a: '11'&#125;); // d[0].forEach(function() &#123; // function() &#123;&#125;인데 this를 재바인딩하지 않고 &#123;a: '11'&#125;을 상속 받았다. // 이는 this를 바인딩 시키는 메소드로 this를 강제 바인딩 시킨 것으로 보인다. console.log(this); // &#123;a: '11'&#125;&#125;, &#123;a: '11'&#125;);[0].forEach(function() &#123; const a = function() &#123; // this를 재바인딩해버렸음. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a();&#125;, &#123;a: '11'&#125;);[0].forEach(function() &#123; const a = () =&gt; &#123; // this를 상속받는 애로우 펑션 console.log(this); // &#123;a: '11'&#125; &#125;; a();&#125;, &#123;a: '11'&#125;);[0].forEach(() =&gt; &#123; // 애로우 펑션이라 this 바인딩 함수가 먹히지 않는다. // 즉 두 번째 매개변수는 무시된다. // 전역의 this인 Window를 상속받는다. console.log(this); // Window&#125;, &#123;a: '11'&#125;);[0].forEach(() =&gt; &#123; const a = function() &#123; // this를 재바인딩해버렸음. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a();&#125;, &#123;a: '11'&#125;);[0].forEach(() =&gt; &#123; // 애로우 펑션이라 Function.prototype.bind가 먹히지 않는다. // 즉 두 번째 매개변수는 무시된다. // 전역의 this인 Window를 상속받는다. const a = () =&gt; &#123; // this를 상속받는 애로우 펑션 console.log(this); // Window &#125;; a();&#125;, &#123;a: '11'&#125;); 별도의 컨텍스트를 만드는 함수setTimeout, setInterval 함수는 함수 선언 시점과 함수 호출 시점에별개의 컨텍스트를 가지는 대표적인 함수이다.123456789101112131415161718192021222324252627282930const e = &#123; a() &#123; console.log(this); &#125;, b() &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, // 실행 시점의 this는 전역의 this(Window)가 된다. setTimeout(this.a, 1000); &#125;, c() &#123; setTimeout(function() &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, // 실행 시점의 this는 전역의 this(Window)가 된다. console.log(this); &#125;, 2000); &#125;, d() &#123; setTimeout(() =&gt; &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, // 실행 시점의 this는 전역의 this(Window)가 된다. // 하지만 애로우 펑션을 쓰면 클로저가 형성된다. // 실행 시점의 this(Window)와 선언 시점의 this(e 객체)가 달라서 // 그것을 동기화(?)시키기 위해서 클로저가 형성되는 게 아닐까...싶다. console.log(this); // e &#125;, 3000); &#125;&#125;; 함수 선언 시점의 this는 e object이다.하지만 함수 실행 시점의 this는 window가 된다.바로 setTimeout이 별도의 컨텍스트를 만들기 때문이다.함수로 래핑해봐도 마찬가지다.하지만 애로우 펑션으로 래핑하면 클로저를 형성해서 우리가 원하는 결과를 얻어낼 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"this","slug":"this","permalink":"http://perfectacle.github.io/tags/this/"}]},{"title":"(ES) ~(Tilde) 연산자","slug":"es-tilt-operator","date":"2017-02-13T13:01:37.000Z","updated":"2017-02-14T22:34:32.000Z","comments":true,"path":"2017/02/13/es-tilt-operator/","link":"","permalink":"http://perfectacle.github.io/2017/02/13/es-tilt-operator/","excerpt":"","text":"우리는 주로 ~라는 문자를 물결이라고 읽었다.하지만 영어권 국가에서는 Tilde(틸드)라고 읽는다.따라서 해당 연산자를 틸드 연산자라고 부른다.해당 연산자가 기본적으로 어떤 일을 하는지 보자. 뭐하는 놈이니?~ 연산자는 비트 단위의 연산자이다.즉, 10진수를 2진수로 바꿔버린 후 연산을 진행한다는 것이다.비트 단위의 연산자 중에 Not을 진행하는 연산자이다.Not 연산자이므로 단항 연산자이다.간단하게 어떻게 작동하는지 보자.1console.log(~1); // -2 일단 1을 2진수로 바꿔보자.00000001여기서 틸드 연산자를 쓰면~00000001Not 연산자 이므로 0을 1로, 1을 0으로 역전시킨다.11111110위에 2진수가 -2인지 확인해보자. -1의 비밀유독 자바스크립트의 메소드를 보면 -1을 반환하는 녀석들이 많다. String.prototype.indexOf() String.prototype.charAt() String.prototype.search() Array.prototype.indexOf() Array.prototype.findIndex() 뭐 이외에도 더 있는지 모르겠지만 내가 아는 범위 내에서는 이게 끝이다.주로 검색과 관련된 메소드 중에서인덱스(number)를 반환하는 메소드에서존재하면 해당 인덱스틀, 존재하지 않는다면 -1을 반환한다.단순히 인덱스가 0부터 정수로 쭉쭉 뻗어가니존재하지 않으면 0에서 가장 가까운 -1을 반환하는 게 타당해보인다.하지만 틸드 연산자와 생각해보면 이 -1이란 녀석을 이용해먹을 수 있다. 일단 -1을 2진수로 표현하면11111111인데 틸드 연산자를 써서 역전시켜버리면00000000정수 0이 돼버린다.0은 형변환 했을 때 false로 취급되는 falsy value이다.~-1 === 0이라는 점을 이용하면 조건식을 간결하게 만들 수 있다.123456789101112131415const str = '나는바보입니다';let search = '냐';if(str.indexOf(search) === -1) console.log('없다');// ~ 연산자를 쓰면 아래와 같이 줄일 수 있다.// ~-1 === 0 == false이기 때문에 논리 부정 연산자(!)를 썼다.if(!~str.indexOf(search)) console.log('없다');search = '바보';if(str.indexOf(search) !== -1) console.log('있다');// ~ 연산자를 쓰면 아래와 같이 줄일 수 있다.// str.indexOf(search) === 2// -1이 아닌 값에 틸드 연산자를 쓰면 0은 안 나옴.// ~str.indexOf(search) === 0은 무조건 안 나옴.// 0이 아닌 숫자는 무조건 true로 형변환 하게 돼있음.if(~str.indexOf(search)) console.log('있다'); 연산 속도를 한번 비교해보자.12345678910111213141516171819202122232425// 큰 차이는 없다.const iterations = 10000000;const str = '나는바보입니다';let search = '냐';console.time(\"===\");for(let i=0; i&lt;iterations; i++)&#123; if(str.indexOf(search) === -1); // ===: 610.604ms&#125;console.timeEnd(\"===\");console.time(\"!~\");for(let i=0; i&lt;iterations; i++)&#123; if(!~str.indexOf(search)); // !~: 578.663ms&#125;console.timeEnd(\"!~\");search = '바보';console.time(\"!==\");for(let i=0; i&lt;iterations; i++)&#123; if(str.indexOf(search) !== -1); // !==: 607.395ms&#125;console.timeEnd(\"!==\");console.time(\"~\");for(let i=0; i&lt;iterations; i++)&#123; if(~str.indexOf(search)); // ~: 619.903ms&#125;console.timeEnd(\"~\"); ~의 ~(~~)기본적으로 Tilde 연산자는 소수점 아래 비트를 버리는 성질을 가진다.12console.log(~1.1); // -2console.log(~1); // -2 Not 연산은 기본적으로 두 번 사용하면 원본값을 반환하는 성질을 가진다.12console.log(!true); // falseconsole.log(!!true); // true 논리 부정 연산인 !은 단순히 true를 false로, false를 true로 역전시킬 뿐이지만비트 논리 부정 연산자인 ~는 조금 다르다.위에서 보다 싶이 소수점 아래 비트를 아예 버려버리는 성질이 있기 때문에이 점을 이용하면 다음과 같은 효과를 낼 수 있다.123456789101112131415161718// ES6에서 추가된 Math.trunc를 바벨이나 Polyfill을 쓰지 않아도 된다.console.log(Math.trunc(45.6)); // 45console.log(~~45.6); // 45console.log(Math.trunc(-45.6)); // -45console.log(~~-45.6); // -45// 역시 비트 단위의 논리 연산자라서 메소드 호출보다 연산 속도가 훨씬 빠르다.const iterations = 10000000;console.time(\"Math.trunc()\");for(let i=0; i&lt;iterations; i++)&#123; Math.trunc(-45.6); // Math.trunc: 124.700ms&#125;console.timeEnd(\"Math.trunc()\");console.time(\"~~\");for(let i=0; i&lt;iterations; i++)&#123; ~~-45.6; // ~~: 21.944ms&#125;console.timeEnd(\"~~\");","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"Operator","slug":"Operator","permalink":"http://perfectacle.github.io/tags/Operator/"}]},{"title":"(Java) 자바의 정석 3판 010일차 - 생성자, this, 멤버 변수 초기화","slug":"Java-study-010day","date":"2017-02-13T04:53:36.000Z","updated":"2017-08-04T04:31:07.000Z","comments":true,"path":"2017/02/13/Java-study-010day/","link":"","permalink":"http://perfectacle.github.io/2017/02/13/Java-study-010day/","excerpt":"","text":"생성자(Constructor)인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드인스턴스 변수 초기화 작업에 주로 사용된다. 생성자는 인스턴스를 생성하지 못한다!나는 생성자로 인스턴스를 생성하고new 연산자가 C언어의 &amp;(주소값 반환) 역할을 하는 줄 알았는데new 연산자가 있어야 인스턴스를 생성하면서 그 주소값을 반환하게 하는 연산자인 것 같다.생성자는 인스턴스 변수 초기화이지 그 이상(인스턴스 생성)도 그 이하도 아닌 것 같다. 기본값 생성자1234567class a &#123; // 아무런 생성자가 없으므로 기본 생성자가 생성됨.&#125;class b &#123; // 생성자가 1개 이상 존재하면 기본 생성자는 만들어지지 않음. b(int x) &#123;&#125;&#125; 사용 예제1234567891011121314151617181920class Car &#123; String color; String gearType; int cntDoor; Car() &#123;&#125; Car(String color, String gearType, int cntDoor) &#123; this.color = color; this.gearType = gearType; this.cntDoor = cntDoor; &#125; public static void main(String[] args)&#123; Car c1 = new Car(); c1.color = \"black\"; c1.gearType = \"manual\"; c1.cntDoor = 4; // 위 코드보다 생성자를 이용하면 간결하게 작성이 가능하다. Car c2 = new Car(\"red\", \"auto\", 4); &#125;&#125; 123456789101112131415161718192021class Car &#123; String color; String gearType; int cntDoor; Car() &#123; // 생성자 내에서 다른 생성자 호출은 첫 줄에서만 가능함. this(\"white\", \"auto\", 4); // 아래와 같이도 가능하다. // color = \"white\"; // gearType = \"auto\"; // cntDoor = 4; &#125; Car(String color, String gearType, int cntDoor) &#123; this.color = color; this.gearType = gearType; this.cntDoor = cntDoor; &#125; public static void main(String[] args)&#123; Car c1 = new Car(); &#125;&#125; thisJS에서는 this가 호출하는 놈에 따라서 유동적으로 변해서 아주 골치가 아팠는데Java에서는 클래스의 인스턴스만 가리키므로 명확하다.이러한 이유로 static 메소드에서는 this를 쓸 수 없다.static 메소드 호출을 클래스의 인스턴스 생성 이전에도 가능하나this는 클래스의 인스턴스를 가리키므로 클래스의 인스턴스 생성 이후에만 사용 가능하기 때문이다.생성자를 포함한 모든 인스턴스 메소드에는 해당 클래스의 인스턴스를 가리키는this 지역변수가 숨겨진 채로 존재할 뿐이다.static 메소드는 인스턴스 멤버와 관련된 작업을 하지 않는 애들이기 때문에this 지역변수가 존재하지 않을 뿐이다.또한 this에는 인스턴스의 주소가 저장돼있다.즉 this는 참조 변수이고, this()는 생성자이다. 인스턴스의 복사클래스 인스턴스 간의 차이점을 보면static 멤버(변수 메소드)와 인스턴스 메소드는 모두 같다.인스턴스 변수만 서로 다른 값을 가지고 있을 뿐이다.즉, 인스턴스를 복사할 때는 인스턴스 변수만 복사하면 된다.12345678910111213141516171819202122class Car &#123; String color; String gearType; int cntDoor; Car(Car c) &#123; color = c.color; gearType = c.gearType; cntDoor = c.cntDoor; // 사실 위와 같이 하는 것 보다는 // 기존의 코드를 재활용하는 것이 유지보수 측면에서 좋다. // 미연의 실수도 방지하고... // this(c.color, c.gearType, c.cntDoor); // 위와 같이 써줘야하고 생성자의 제일 첫줄에 적어줘야한다. // 왜냐하면 여태까지 초기화한 내역 이후에 또 다시 생성자로 다시 인스턴스를 초기화할 필요는 없기 때문이다. // Car(c.colr, c.gearType, c.cntDoor); 라고 쓰면 오류가 난다. &#125; Car(String color, String gearType, int cntDoor) &#123; this.color = color; this.gearType = gearType; this.cntDoor = cntDoor; &#125;&#125; 변수의 초기화멤버 변수(클래스 변수, 인스턴스 변수)와 배열은 기본값으로 초기화가 이루어지지만,지역 변수(배열 빼고)는 기본값으로 초기화가 이루어지지 않는다.즉, 멤버 변수와 배열의 초기화는 선택적이지만(초기화를 권장한단다)지역 변수의 초기화는 필수적이다.또한 멤버 변수의 초기화에는 다음 세 가지 방법이 존재한다. 명시적 초기화가장 기본적이면서 간단한 방법이다. 12345class Car &#123; String color = \"black\"; String gearType = \"manual\"; int cntDoor = 4;&#125; 초기화 블럭예외 처리나 반복, 조건문 등등의 복잡한 작업을 통해 초기화 해야할 경우이러한 블럭{}을 사용해서 초기화를 진행하면 된다. 12345678910111213141516171819202122232425262728293031323334353637383940class Car &#123; static int cntCar; // 현재 자동차가 몇 대 생성되었는지 static &#123; // 클래스 초기화 블럭 // 프로그램이 실행되면 단 한 번만 실행된다. System.out.println(\"이렇게 함수 실행도 된다.\"); cntCar = 0; &#125; String color; String gearType; int cntDoor; &#123; // 인스턴스 초기화 블럭 // 인스턴스가 생성될 때마다 실행된다. if(true) &#123; System.out.println(\"조건문도 쓸 수 있네?\"); &#125; cntCar++; // 생성자마다 중복된 코드를 여기다가 빼면 된다. &#125; Car() &#123; // cntCar++; // 차가 생성됐으므로 1대 추가, 생성자마다 중복된 코드다. color = \"white\"; gearType = \"auto\"; cntDoor = 4; &#125; Car(String color, String gearType, int cntDoor) &#123; // cntCar++; // 차가 생성됐으므로 1대 추가, 생성자마다 중복된 코드다. this.color = color; this.gearType = gearType; this.cntDoor = cntDoor; &#125; public static void main(String[] args) &#123; // 이렇게 함수도 실행된다. // 조건문도 쓸 수 있네? Car c = new Car(); // 조건문도 쓸 수 있네? Car c2 = new Car(\"black\", \"manual\", 3); &#125;&#125; 생성자인스턴스 변수를 초기화하기 위해 쓴다고 위에 설명했으므로자세한 설명은 생략한다. 멤버 변수의 초기화 시기와 순서 클래스 변수의 초기화 시점클래스 변수가 처음 로딩될 때 단 한 번 초기화 된다. 인스턴스 변수의 초기화 시점인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다. 클래스 변수의 초기화 순서기본값 - 명시적 초기화 - 클래스 초기화 블럭 인스턴스 변수의 초기화 순서기본값 - 명시적 초기화 - 인스턴스 초기화 블럭 - 생성자 1234567891011121314151617class InitTest &#123; static int cv = 1; int iv = 1; static &#123; cv = 2; &#125; &#123; iv = 2; &#125; InitTest() &#123; iv = 3; &#125; public static void main(String[] args) &#123; InitTest i = new InitTest(); &#125;&#125; 클래스 초기화인스턴스 초기화기본값명시적 초기화클래스 초기화 블럭기본값명시적 초기화인스턴스 초기화 블럭생성자cv: 0cv: 1cv: 2cv: 2cv: 2cv: 2cv: 2iv: 0iv: 1iv: 2iv: 31234567","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"OOP","slug":"OOP","permalink":"http://perfectacle.github.io/tags/OOP/"}]},{"title":"(ES) 똑똑한 논리 연산자","slug":"es-logical-operator","date":"2017-02-12T15:01:37.000Z","updated":"2017-02-12T16:46:35.000Z","comments":true,"path":"2017/02/13/es-logical-operator/","link":"","permalink":"http://perfectacle.github.io/2017/02/13/es-logical-operator/","excerpt":"","text":"오늘은 기본값을 위해 많이 쓰던 논리 연산자인||와 &amp;&amp;을 집중 탐구해보았다.우선 위에 있는 녀석들은 어떨 때 쓰는지 알아보자. 사용 사례 네임 스페이스 패턴(~ES5)웹팩을 사용하면 js 파일을 모듈 단위로 사용할 수 있지만,그럴 환경이 안 되면 아래와 같은 우회 방법을 통해서 전역 스코프를 최대한 덜 더럽힐 수 있다.ES6에는 모듈 import, export 기능이 있어서 ~ES5라고 써놓긴 했지만…아직 지원하는 브라우저가 없는 걸로 안다. (17년 2월 기준) 1234567891011// 전역 스코프에는 namespace와 namespace2 모듈만이 존재한다.// func라는 충돌나기 쉬운 네이밍이 전역에 존재하지 않으므로 충돌이 일어나지 않는다.// 즉 네이밍을 고민할 염려가 조금은 줄어들게 된다. 뭐 그 외에 장점도 많지만...// script src 태그를 통해 미리 namespace 모듈을 불러온 경우에는 전역에는 변수 namespace가 존재한다.// || 연산자를 써서 전역에 namespace라는 변수(모듈)가 존재하면 그 모듈을 변수에 할당하고,// 존재하지 않는다면 빈 객체를 변수에 할당하는 패턴이다.const namespace = namespace || &#123;&#125;;namespace.func = function() &#123;&#125;;const namespace2 = namespace2 || &#123;&#125;;namespace2.func = function() &#123;&#125;; 함수의 매개변수 기본값 설정(~ES5)ES6를 통해서는 아래와 같은 게 가능하지만, 1const func = (param1 = 0, param2 = '') =&gt; &#123;&#125;; 바벨을 사용할 수 없고, IE 하위 브라우저까지 크로스 브라우징을 하는 환경에서는아래와 같이 처리해줘야한다.12345var func = function(param1, param2) &#123; // || 뒤에 오는 애가 기본 값이다. param1 = param1 || 0; param2 = param2 || '';&#125;; 함수의 인자로 기본값 설정위에서는 함수를 선언할 때 매개변수의 기본값을 설정한 경우지만이 경우는 함수를 호출할 때 인자의 기본값을 설정한 경우이다.둘의 차이는 뭐 없다고 봐도 무방하지 않을까…싶다. 12345const obj = &#123;name: ''&#125;;const func = age =&gt; console.log(age);// obj 객체에 age라는 키가 없으므로 undefined를 반환한다.// undefined는 형변환 했을 때 false로 간주되므로 기본값인 1이 넘어간다.func(obj.age || 1); // 1 함수의 기본 반환값 설정함수의 반환값이 매개 변수에 따라서 오류를 뿜는 경우가 존재한다.그런 오류를 방지하고자 기본값을 설정하곤 하는데 어떤 경우인지 보자. 123456const cntOccurrences = (regExp, str) =&gt; ( // 정규표현식과 매치되는 결과가 없어서 null을 반환할 경우 // null.length는 오류를 반환하므로 기본값으로 빈 배열을 넣어줘서 오류를 방지함. (str.match(regExp) || []).length);console.log(cntOccurrences(/\\d/g, 'asdf')); // 0, 기본값이 없었다면 오류가 난다. 거짓 기본값 설정하기말이 이상한데…만약 해당 변수가 거짓이라면 더 이상의 판별을 하지 않고자 할 때 쓰면 된다. 12345678910111213141516const arr = [1, 2, 'q', 4];// 배열이 숫자로만 이루어진 건지 아닌지 판별하는 함수const isNumArr = arr =&gt; &#123; let isNum = true; // 모든 값이 숫자인지 아닌지 판별하는 flag 변수 arr.forEach(v =&gt; &#123; // 만약에 한 번이라도 숫자가 아닌 값이 있었다면 // 그 아래에 있는 구문들을 실행할 필요가 없으므로 // return으로 함수를 조기 종료. if(!isNum) return; // 현재 값이 숫자인지 판단하여 변수에 저장. isNum = isNaN(v); &#125;); return isNum;&#125;console.log(isNumArr(arr)); // false 위와 같은 코드가 있을 때 &amp;&amp; 논리 연산자를 쓰면 코드를 줄일 수 있다.퍼포먼스 측면에서는 맞는지 잘 모르겠다…1234567891011121314const arr = [1, 2, 'q', 4];// 배열이 숫자로만 이루어진 건지 아닌지 판별하는 함수const isNumArr = arr =&gt; &#123; let isNum = true; // 모든 값이 숫자인지 아닌지 판별하는 flag 변수 // &amp;&amp; 연산은 false인 값을 반환하려는 성질이 있는데 // 둘 다 false이면 앞에 놈을 반환한다. // 만약 앞에 놈이 true이면 무조건 뒤에 놈을 반환한다. // 일단 false 값을 반환하는지 검사를 돌리다가 한 번이라도 false가 나오면 // 뒤에 놈이 true여도 한 번 false인 놈은 계속 false로 만들고 싶을 때 쓰면 된다. arr.forEach(v =&gt; isNum = isNum &amp;&amp; isNaN(v)); return isNum;&#125;console.log(isNumArr(arr)); // false 원리 파악x || y =&gt; x가 참이면 무조건 참.즉 x가 참이면 y는 평가(실행)하지도 않음.x &amp;&amp; y =&gt; x가 거짓이면 무조건 거짓.즉 x가 거짓이면 y는 평가(실행)하지도 않음.이렇게 좌변에 어떤 값을 넣는가에 따라서 연산 속도에 영향을 미침. 검증이 말이 사실인가 한 번 아래 예제를 실행해보자.123456789101112131415161718192021222324// 기본적으로 console.log()는 반환값이 없으므로 false로 취급한다.// true || false!console.log('a') || console.log('b'); // a// true || true!console.log('a') || !console.log('b'); // a// false || falseconsole.log('a') || console.log('b'); // a b// false || trueconsole.log('a') || !console.log('b'); // a b// false &amp;&amp; falseconsole.log('a') &amp;&amp; console.log('b'); // a// false &amp;&amp; trueconsole.log('a') &amp;&amp; !console.log('b'); // a// true &amp;&amp; false!console.log('a') &amp;&amp; console.log('b'); // a b// true &amp;&amp; true!console.log('a') &amp;&amp; !console.log('b'); // a b 논리 연산자는 좌변에 따라서 우변이 실행되느냐 마느냐가 달려있다.그럼 반환은 어떻게 하는지 살펴보자.12345678910111213141516let a = 1 || false; // true || falseconsole.log(a); // 1a = &#123;&#125; || []; // true || trueconsole.log(a); // &#123;&#125;a = null || undefined; // false || falseconsole.log(a); // undefineda = 0 || function()&#123;&#125;; // false || trueconsole.log(a); // function()&#123;&#125;a = NaN &amp;&amp; 0; // false &amp;&amp; falseconsole.log(a); // NaNa = '' &amp;&amp; new Map(); // false &amp;&amp; trueconsole.log(a); // ''a = new Map() &amp;&amp; null; // true &amp;&amp; falseconsole.log(a); // nulla = new Set() &amp;&amp; new Array(); // true &amp;&amp; trueconsole.log(a); // [] 왜 위와 같은 값을 반환하게 됐는지 한번 원리와 연관 지어서 생각해보자. x || y|| 연산자는 좌변이 true이면 우변을 평가, 실행하지 않는다고 했다.즉, 좌변이 true이면 우변은 없는 놈 취급하기 때문에 바로 x가 반환(평가, 실행)되는 것이다.하지만 좌변이 false이면 우변을 평가, 실행하게 된다.이렇게 되면 좌변은 아예 없는 놈 취급하게 된다.즉, 좌변이 false이면 우변의 값은 뭐든간에 상관 없이 항상 우변이 반환(평가와 실행은 말할 것도 없이)된다. x &amp;&amp; y&amp;&amp; 연산자는 좌변이 false이면 우변을 평가, 실행하지 않는다고 했다.즉, 좌변이 false이면 우변은 없는 놈 취급하기 때문에 바로 x가 반환(평가, 실행)되는 것이다.하지만 좌변이 true이면 우변을 평가, 실행하게 된다.이렇게 되면 좌변은 아예 없는 놈 취급하게 된다.즉, 좌변이 true이면 우변의 값은 뭐든간에 상관 없이 항상 우변이 반환(평가와 실행은 말할 것도 없이)된다. 쓸 데 없는 실험12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849for(let i=0; i&lt;10; i++) console.log(i);// 1차 줄임for(let i=0; i&lt;10;) console.log(i++);// 2차 줄임for(let i=0; i&lt;10; console.log(i++));// 3차 줄임 ver 1.// 좌변이 참일 동안 반복함.// 좌변이 참이면 우변은 무조건 실행함.// 우변을 실행한다는 것은 우변을 반환한다는 의미이므로// 우변은 무조건 true로 만들어줘야함.for(let i=0; (i&lt;10) &amp;&amp; !console.log(i++););// 3차 줄임 ver 2.// 우변이 참일 동안 반복함.// 좌변이 거짓이면 우변은 무조건 실행함.// 우변을 실행한다는 것은 우변을 반환한다는 의미이므로// 우변을 실행시키기 위해 좌변은 무조건 false로 만들어줘야함.for(let i=0; console.log(i++) || (i&lt;10););let i=0;while(i&lt;10) &#123; console.log(i); i++;&#125;// 1차 줄임i=0;while(i&lt;10) &#123; console.log(i++);&#125;// 2차 줄임 ver 1.i=0;// 좌변이 참일 동안 반복함.// 좌변이 참이면 우변은 무조건 실행함.// 우변을 실행한다는 것은 우변을 반환한다는 의미이므로// 우변은 무조건 true로 만들어줘야함.while((i&lt;10) &amp;&amp; !console.log(i++));// 2차 줄임 ver 2.i=0;// 우변이 참일 동안 반복함.// 좌변이 거짓이면 우변은 무조건 실행함.// 우변을 실행한다는 것은 우변을 반환한다는 의미이므로// 우변을 실행시키기 위해 좌변은 무조건 false로 만들어줘야함.while(console.log(i++) || (i&lt;10));","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"Operator","slug":"Operator","permalink":"http://perfectacle.github.io/tags/Operator/"}]},{"title":"(ES5) 배열의 순회 메소드에서 break 기능 구현하기","slug":"ES5-array-loop-method-break","date":"2017-02-12T13:51:05.000Z","updated":"2017-02-12T14:54:22.000Z","comments":true,"path":"2017/02/12/ES5-array-loop-method-break/","link":"","permalink":"http://perfectacle.github.io/2017/02/12/ES5-array-loop-method-break/","excerpt":"","text":"이 글은 Outsider 님의 블로그 포스트 중forEach에 break문 대신 some 사용하기를 보고 큰 감명을 받아내가 이해한 내용을 토대로 정리해 본 글이다. for loopfor 반복문을 써서 배열을 순회하는 것은 할당, 프로퍼티 참조, 조건 분기 등등의 잡다한 일을 해야한다.이러한 잡다한 일을 실수로 코딩을 잘못하면 원하지 않는 결과가 나오고, 귀찮음이 몰려오기 마련이다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const arr = [ 0, 1, 2, 3, 'q', 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum = arr =&gt; &#123; let isNum = true; // 프로그래머가 실수로 let i = 1;이라고 초기화한다면? // 실수로 i&lt;arr.length+1; 이라고 조건식을 잘못 입력한다면? // i+=2; 라고 증감식을 잘못 입력한다면? // arr[i+1]로 잘못 참조한다면? // 이렇게 일일이 초기화, 조건식 지정, 증감식 지정 등등을 일일이 해줘야하므로 귀찮다. for(let i=0; i&lt;arr.length; i++) &#123; console.log(arr[i]); if(!isNaN(arr[i])) &#123; // 숫자라면 // 아래 있는 코드는 실행할 필요 없이 다음 요소를 검사해야함. // 즉 다음 반복문을 실행. continue; &#125; // 숫자가 아니라면 isNum = false; // 바로 반복문을 종료해야함. break; &#125; return isNum;&#125;;// 0// 1// 2// 3// q// falseconsole.log(isArrNum(arr));// 사실은 아래와 같이 break와 continue를 쓸 필요도 없는 예제긴 하다.const isArrNum2 = arr =&gt; &#123; for(let i=0; i&lt;arr.length; i++) &#123; if(isNaN(arr[i])) &#123; // 숫자가 아니라면 // 반복문 탈출이고 나발이고 return으로 바로 함수를 조기 종료 시키면서 // false를 반환하게 하면됨. return false; &#125; &#125; // 반복문이 무사히 끝났으면 모든 게 숫자였다고 판단하여 true를 반환. return true;&#125;; continue 기능만 있는 배열 순회 메소드(ES5, IE9+)따라서 그런 점을 해소하고자 ES5(IE9+)에서는 배열의 순환 메소드인forEach, reduce, map, filter 등등이 추가됐다.하지만!이 메소드는 continue는 지원하지만 break는 지원하지 않는다.또한 continue 기능은 continue 대신에 함수를 종료 시키는return 키워드를 사용하며 반환하는 값은 중요치 않다.(continue 시키는 데에 있어서는)return 키워드로 함수를 조기 종료 시켜도, 현재 요소에 대한 콜백 함수(continue)를 종료 시킨 것이지모든 요소에 대한 콜백 함수(break)를 종료시켜버리는 것이 아니기 때문에 바로 다음 콜백함수의 실행이 일어난다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const arr = [ 0, 1, 2, 3, 'q', 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum3 = arr =&gt; &#123; let isNum = true; // forEach, map, reduce, filter 메소드가 // continue만 지원하고, break를 지원하지 않아 콘솔창을 보면 비효율적임을 보여준다. arr.forEach(v =&gt; &#123; // 배열 중에 숫자가 아닌 값이 있어도 배열의 요소 끝까지 콜백 함수가 돈다. console.log(v); // forEach, map, filter, reduce에서 return은 continue와 같다. // 반환값은 중요치 않고, break를 지원하지 않는다. // return으로 함수를 종료 해도 해당 인덱스의 콜백함수이기 때문에 // 다음 요소의 콜백 함수가 돈다. // 배열 요소 중 숫자가 아닌 값이 있었다면 그 아래 값들은 실행할 필요가 없어짐. if(!isNum) return; // 숫자가 아니라면 if(isNaN(v)) isNum = false; &#125;); return isNum;&#125;;// 0// 1// 2// 3// q// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// falseconsole.log(isArrNum3(arr));// 사실은 return으로 continue 시킬 것도 없는 예제이다.const isArrNum4 = arr =&gt; &#123; let isNum = true; arr.forEach(v =&gt; isNum = isNum &amp;&amp; !isNaN(v)); return isNum;&#125;; break 기능까지 있는 배열 순회 메소드(ES5, IE9+) falsy values: boolean으로 형변환 했을 때 false로 취급되는 값들 false, 0, ‘’, null, undefined, NaN truthy values: boolean으로 형변환 했을 때 true로 취급되는 값들 falsy value가 아닌 모든 값들. some콜백함수가 반환하는 값이 하나라도 true인지 파악하는 메소드하나라도 truthy value를 반환하는 순간 콜백함수를 멈춤. 12345678910111213141516171819202122232425262728293031const arr = [ 0, 1, 2, 3, 'q', 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum5 = arr =&gt; &#123; const isNum = arr.some(v =&gt; &#123; console.log(v); if(isNaN(v)) &#123; // 숫자가 아니라면 // some에서 truthy value를 반환하면 break와 동일함. return true; &#125; // some에서 falsy value를 반환하면 continue와 동일함. return false; &#125;); // 숫자가 아니라면 some은 true를 반환하므로 not 연산자(!)를 써서 반환해줘야함. return !isNum;&#125;;// 0// 1// 2// 3// q// falseconsole.log(isArrNum5(arr));// 사실 아래와 같이 줄여쓸 수 있는 예제이다.const isArrNum6 = arr =&gt; !arr.some(v =&gt; isNaN(v)); every콜백함수가 반환하는 값이 모두 true인지 파악하는 메소드하나라도 falsy value를 반환하는 순간 콜백함수를 멈춤. 123456789101112131415161718192021222324252627282930const arr = [ 0, 1, 2, 3, 'q', 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum7 = arr =&gt; &#123; const isNum = arr.every(v =&gt; &#123; console.log(v); if(isNaN(v)) &#123; // 숫자가 아니라면 // every에서 falsy value를 반환하면 break와 동일함. return false; &#125; // every에서 truthy value를 반환하면 continue와 동일함. return true; &#125;); return isNum;&#125;;// 0// 1// 2// 3// q// falseconsole.log(isArrNum7(arr));// 사실 아래와 같이 줄여쓸 수 있다.const isArrNum8 = arr =&gt; arr.every(v =&gt; !isNaN(v));","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"Array","slug":"Array","permalink":"http://perfectacle.github.io/tags/Array/"},{"name":"ES5","slug":"ES5","permalink":"http://perfectacle.github.io/tags/ES5/"}]},{"title":"양 보다는 꾸준히","slug":"blahblah01","date":"2017-02-11T06:19:18.000Z","updated":"2017-02-13T04:46:22.000Z","comments":true,"path":"2017/02/11/blahblah01/","link":"","permalink":"http://perfectacle.github.io/2017/02/11/blahblah01/","excerpt":"","text":"자바를 공부하면서 느낀 것이다. 초반엔 내가 아는 내용이니 하루에 한 챕터씩 나가야지… 하지만 내가 아는 게 다가 아니었다.다 안다고 생각했지만 그 속에는 모르는 내용들이 너무 많았다.하루 한 챕터를 정리해가면서 연습문제까지 풀어가기에는 정말 힘들었다.초반에는 재밌어서 그래도 거의 한 챕터씩 나갔다.하지만 가면 갈 수록 그 양에 질리고, 시간은 더욱 오래 걸렸다.공부를 하는 것도 매일 매일이 아니라 그냥 생각날 때, 시간 날 때만 했다.오늘 공부를 하다보니 이제는 지쳐서 2시간이 되자 책장을 넘기면서 이 챕터는 도대체 언제 끝나나…다음 챕터는 얼마나 될라나… 라면서 멘붕에 빠지게 되었다.초반에 자바 공부를 할 때는 하루에 5~6시간씩 몰입을 했었지만 지쳤다.가면 갈 수록 집중해지는 시간이 짧아지는 것을 느꼈다.하루에 한 공부에만 몰두할 게 아니라 체계적으로 나눠야할 것 같다.하루에 다 끝낸다는 생각보다는 꾸준히 해서 끝까지 마무리할 생각을 해야겠다.하루에 조금이라도 하는 습관을 길러야겠다.내가 지쳐서 못해먹겠다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"http://perfectacle.github.io/categories/기타/잡동사니/"}],"tags":[{"name":"잡동사니","slug":"잡동사니","permalink":"http://perfectacle.github.io/tags/잡동사니/"}]},{"title":"(Java) 자바의 정석 3판 009일차 - 재귀함수, 클래스 설계, 오버로딩, 가변 인자","slug":"Java-study-009day","date":"2017-02-11T04:07:43.000Z","updated":"2017-08-04T04:31:00.000Z","comments":true,"path":"2017/02/11/Java-study-009day/","link":"","permalink":"http://perfectacle.github.io/2017/02/11/Java-study-009day/","excerpt":"","text":"어제는 친구들이랑 노느라 공부를 조금 밖에 못 했다.그만큼 오늘은 좀 빡시게 달려야겠다. 재귀함수(recursive function)함수 내에서 자기 자신을 호출하는 것이다.배열의 요소를 모두 더하는 메소드는 아래와 같이 작성이 가능하다.1234567891011121314class test &#123; static int sumArr(int[] arr) &#123; int sum = 0; for(int num : arr) &#123; sum += num; &#125; return sum; &#125; public static void main(String[] args) &#123; int arr[] = &#123;1, 2, 4, 5 , 8, 9&#125;; int sum = sumArr(arr); System.out.println(sum); &#125;&#125; 이걸 재귀함수로 바꾸면 아래와 같다.1234567891011121314class test &#123; static int sumArr(int[] arr, int i) &#123; if(i &lt; arr.length) &#123; // 재귀함수를 호출하는 조건 return arr[i] + sumArr(arr, i+1); &#125; // 재귀함수를 탈출하는 조건 return 0; &#125; public static void main(String[] args) &#123; int arr[] = &#123;1, 2, 4, 5 , 8, 9&#125;; int sum = sumArr(arr, 0); System.out.println(sum); &#125;&#125; 위에서 보듯이 재귀 함수에서는 두 가지 조건이 중요하다. 호출 조건이게 없으면 재귀함수를 호출하지 않을 것이고, 재귀함수라 불릴 수가 없다. 탈출 조건이게 없으면 stack에 무한정 재귀함수가 쌓이게 될 것이다.이렇게 되면 가용 가능한 메모리 영역을 넘어설 것이다.이 때 stack overflow가 발생하는 것이다.아래와 같이 말이다. 123456class test &#123; public static void main(String[] args) &#123; // Exception in thread \"main\" java.lang.StackOverflowError main(null); &#125;&#125; for문에 비해 재귀함수는 stack의 많은 공간을 차지하게 된다.또한 매개 변수 복사 및 복귀할 주소 저장 등등의 추가적인 작업이 발생해서 더 느리다.그럼에도 불구하고 재귀함수가 존재하는 이유는 논리적인 간결함이 있기 때문이다.즉 가독성이 좋아져서 유지 보수 함에 있어서 한결 용이해진다는 소리이다.반복문을 썼을 때 코드가 복잡해져서 한 눈에 파악하기 어려운 경우,재귀함수를 한번 고려해보면 좋을 것 같다.하지만 재귀함수는 퍼포먼스가 안 좋아지고, 엄청난 반복을 통해 호출하는 경우에는stack overflow 등등 고려해야할 내용이 있다는 점은 유념해서 써야한다. 클래스 설계하기멤버 변수(클래스 변수 &amp; 인스턴스 변수) 설계하기 모든 인스턴스에 공통적으로 사용해야하는 변수에는 static 키워드를 붙여 클래스 변수로 만들어준다.인스턴스가 생성되기 전에 프로그램이 시작되면 자동적으로 메모리의 Method Area(Data) 영역에 적재된다.모든 인스턴스가 동일한 주소를 참조하므로 값을 공유하게 된다.공통적으로 사용하려면 값을 공유해야하므로 클래스 변수로 만들어줘야한다.프로그램이 종료될 때까지 메모리에 계속 적재돼있는다.클래스 이름.변수와 같이 사용한다. 인스턴스 마다 따로 사용해야하는 변수에는 static을 붙이지 않아 인스턴스 변수로 만들어준다.프로그램이 시작되어도 메모리에 자동적으로 적재되지 않는다.new 연산자와 생성자 호출로 인스턴스를 생성해야 비로소 메모리의 Heap 영역에 적재된다.각각의 인스턴스가 다른 주소를 참조하므로 개별적으로 값을 가지게 된다.참조 관계가 끊기는 순간 가비지 컬렉터가 메모리에서 자동적으로 회수해간다.(해제한다.)인스턴스 이름.변수와 같이 사용한다. 메소드(멤버 함수, 클래스 메소드 &amp; 인스턴스 메소드) 설계하기 인스턴스 변수를 사용하지 않는 메소드는 static 키워드를 붙여 클래스 메소드로 만드는 게 일반적이다.인스턴스가 생성되기 전에 프로그램이 시작되면 자동적으로 메모리의 Method Area(Data) 영역에 적재된다.하지만 인스턴스 변수가 메소드 내에 존재한다면,존재하지 않는 변수(메모리 공간 상에 할당되지 않은 변수)를참조해야하는 경우가 생기게 되므로 오류를 유발하게 된다.또한 static 키워드를 붙이지 않으면 실행 시 호출되어야할메소드를 찾는 과정이 추가적으로 필요해 퍼포먼스 적으로 안 좋다.프로그램이 종료될 때까지 메모리에 계속 적재돼있는다.클래스 이름.메소드()와 같이 사용한다. 인스턴스 변수를 사용하는 경우에는 static 키워드를 붙이지 않아 인스턴스 메소드로 만들어야한다.프로그램이 시작되어도 메모리에 자동적으로 적재되지 않는다.생성자 함수를 호출해서 인스턴스를 생성해야 비로소 메모리의 Heap 영역에 적재된다.인스턴스 변수는 인스턴스가 생성되어야지만 메모리에 적재되고, 비로소 사용할 수 있게 된다.이런 인스턴스 변수를 쓰려면 인스턴스가 생성된 이후이므로,메소드도 인스턴스 변수가 생성된 이후에 사용이 가능해지는 것이므로클래스 메소드(인스턴스 변수가 생성되기 이전에 생성됨)로 선언하면 안된다.참조 관계가 끊기는 순간 가비지 컬렉터가 메모리에서 자동적으로 회수해간다.(해제한다.)인스턴스 이름.메소드()와 같이 사용한다. 123456789101112131415161718192021222324class test &#123; // 멤버 변수 중 인스턴스 변수 int a=3, b=2; // 인스턴스 변수를 쓰므로 인스턴스 메소드로 만들어줌. int add() &#123; return a+b; // 인스턴스 변수 &#125; // 인스턴스 변수를 쓰지 않으므로 클래스 메소드로 만들어줌. static int add(int a, int b) &#123; // 매개 변수(Parameter) a, b return a + b; // 지역 변수 &#125; public static void main(String[] args) &#123; // 클래스 변수(변수, 메소드)는 프로그램이 실행되는 순간 자동적으로 메모리의 Method Area(Data)에 할당된다. // 같은 클래스 내에 존재하는 클래스 변수(변수, 메소드)는 클래스 이름 생략이 가능하다. System.out.println(add(1, 2)); // 3, 인자(Argument)로 1과 2를 넘겨준 클래스 메소드 // 인스턴스 변수(변수, 메소드)는 생성자를 통해 인스턴스를 생성하기 전까지 메모리의 Heap에 할당되지 않는다. test t = new test(); System.out.println(t.add()); // 5, 인스턴스 변수인 t.a와 t.b를 이용한 인스턴스 메소드 &#125;&#125; 1234567891011121314151617181920212223class test &#123; // 멤버 변수 중 인스턴스 변수 int a=3, b=2; // static int c = a; // 에러 // static 컨텍스트에서는 인스턴스 멤버를 사용하려면 먼저 인스턴스를 생성해줘야함. static int c = new test().a; int add() &#123; // 인스턴스 컨텍스트에서는 따로 처리해주지 않아도 됨. // 인스턴스 멤버가 존재한다는 것은 // 클래스 멤버도 존재한다는 가정이기 때문. return a+b+c; &#125; static int add2() &#123; // return c + a + b; // 에러 // static 컨텍스트에서는 인스턴스 멤버를 사용하려면 먼저 인스턴스를 생성해줘야함. // 클래스 멤버가 존재해도 인스턴스 멤버가 존재하지 않을 수도 있기 때문임. // 이럴 경우에는 클래스 메소드가 아닌 인스턴스 메소드를 권장하는 바임. test t = new test(); return t.a + t.b + c; &#125;&#125; 메소드 오버로딩(overloading)과 오버라이딩(overriding)두 개가 너무 헷갈려서 간단하게 정리한다. 오버 라이딩ride: 타다부모 클래스로 올라탄다라는 생각으로 외웠다.상속받은 부모 클래스의 메소드를 재정의하는 것. 오버 로딩다형성, 메소드 이름이 똑같아도매개 변수의 타입, 매개 변수의 갯수에 따라호출되는 메소드가 다른 것을 의미.매개 변수의 이름과 반환 타입은 중요치 않다.load: 적재하다원래는 하나의 메소드 이름에는 하나의 메소드만 적재해야하는데그걸 초과한 하나의 메소드 이름에 여러 메소드를 적재하기 때문에이런 이름이 붙은 게 아닐까 싶다.이는 동적 타입 언어인 JS에는 없는 기능이다. 가변 인자(variable arguments)정적 타입 언어인 Java에서는 매개 변수의 갯수가 고정적이었다.동적 타입 언어인 JS를 먼저 접한 나로선 매우 빡빡하다고 생각이 들었다.하지만 Java5부터는 동적으로 지정해줄 수 있게 됐다.1234567891011121314class test &#123; static String concatenate(String str, String str2) &#123; return str + str2; &#125; static String concatenate(String str, String str2, String str3) &#123; return str + str2 + str3; &#125; static String concatenate(String str, String str2, String str3, String str4) &#123; return str + str2 + str3 + str4; &#125; // 매개변수가 n개인 메소드를 계속 오버로딩할 것인가?&#125; 가변인자를 쓰면 아래와 같이 바꿀 수 있다.123456789class test &#123; static String concatenate(String ...str) &#123; String result = \"\"; for(String arg : str) &#123; result += arg; &#125; return result; &#125;&#125; 가변인자는 내부적으로 배열을 생성한다.이런 비효율이 존재하므로 꼭 필요한 경우에만 가변 인자를 사용해야한다. 123456789101112131415161718192021222324252627282930313233class test &#123; // 가변 인자는 제일 나중에 선언해야 한다. static String concatenate(String ...str, int num) &#123; // 에러 String result = \"\"; for(String arg : str) &#123; result += arg; &#125; return result; &#125; static String concatenate(String string, String... str) &#123; String result = \"\"; for(String arg : str) &#123; result += arg; &#125; return result; &#125; static String concatenate(String... str) &#123; String result = \"\"; for(String arg : str) &#123; result += arg; &#125; return result; &#125; public static void main(String[] args) &#123; // String concatenate(String string, String... str) // String concatenate(String... str) // 둘 중에 뭘 호출해야할지 모르므로 컴파일 에러 System.out.println(concatenate(\"2\", \"aass\")); &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"OOP","slug":"OOP","permalink":"http://perfectacle.github.io/tags/OOP/"}]},{"title":"(Java) 자바의 정석 3판 008일차 - JVM의 메모리 구조","slug":"Java-study-008day","date":"2017-02-10T01:20:35.000Z","updated":"2017-08-04T04:30:52.000Z","comments":true,"path":"2017/02/10/Java-study-008day/","link":"","permalink":"http://perfectacle.github.io/2017/02/10/Java-study-008day/","excerpt":"","text":"JVM의 메모리 구조이 글을 보기 전에 아래 글을 참조하면 더 이해가 잘 간다.(C/C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap) Method Area클래스 데이터가 들어간다.즉 클래스 변수(static 변수)가 들어간다.프로그램 실행되자마자 적재되고 끝날 때까지 사라지지 않는 놈이다.기본적인 메모리 영역의 Data 영역에 해당한다. Call Stack메소드가 호출되면 해당 메소드를 콜스택에 push한다.제어권이 이전에 실행 중이던 메소드에서 Stack의 top에 위치한 메소드로 이동하게 된다.이전에 실행 중이던 메소드는 대기 상태가 되고 호출한 메소드의 작업이 끝날 때까지 대기하게 된다.그러면서 해당 메소드 만의 스코프를 생성한다.별도의 스코프를 생성하므로 지역 변수가 이곳에 존재한다.해당 메소드 아래 있는 메소드가 해당 메소드를 호출한 메소드가 된다.JVM은 프로그램이 실행되면 일단 main 메소드를 찾아 콜 스택에 push하게 된다.그리고 메소드의 작업에 필요한 메모리 공간을 콜스택이 제공해주고,작업을 마치게 되면 할당 되었던 메모리 공간은 반한된다.기본적인 메모리 영역의 Stack에 해당한다. Heap클래스의 인스턴스가 생성되는 공간.인스턴스 변수들이 들어간다.new 연산자를 쓰므로 동적 할당이라고 할 수 있다.메모리 상에서 해제는 가비지 컬렉터가 자동으로 수행한다.기본적인 메모리 영역의 Heap에 해당한다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"JVM","slug":"JVM","permalink":"http://perfectacle.github.io/tags/JVM/"}]},{"title":"(C++) 참고용 정리 - 클래스의 두 가지 생성 방법","slug":"Cpp-ref-002","date":"2017-02-09T06:55:22.000Z","updated":"2017-08-03T18:12:53.000Z","comments":true,"path":"2017/02/09/Cpp-ref-002/","link":"","permalink":"http://perfectacle.github.io/2017/02/09/Cpp-ref-002/","excerpt":"","text":"학교에서 클래스를 할당하는 한 가지 방법 밖에 배우지 않았다.동적 할당에 대해서 배우지 않았기 때문인데…왜 학교에서는 이런 심도있는 내용들은 1도 가르쳐주지 않는 걸까?학교에서 이런 내용까지 알려준다면 좀 더 재미나게 수업에 임할 수 있을텐데…정말 안타깝다 ㅠㅠ이해를 돕기 위해 아래 포스트를 한 번 보는 걸 추천한다.(C/C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap) 학교에서 배운 방법(정적 할당)123456789101112131415161718#include &lt;iostream&gt;using namespace std; class test &#123;private: int num;public: void setNum(int n) &#123;num = n;&#125; int getNum() &#123;return num;&#125;&#125;; int main() &#123; test t; t.setNum(22); cout &lt;&lt; t.getNum() &lt;&lt; endl; cout &lt;&lt; t; // 에러, t가 가지고 있는 순수 값은 못 본다. 왜일까? ㅠㅠ return 0;&#125; test 클래스의 인스턴스인 t는 스택 영역에 올라가게 된다.사실 자바를 먼저 배우고 C++을 그 이후에 배워서…자바에서는 저렇게 선언하면 참조변수만 선언한 격이라클래스의 인스턴스가 생성되지 않아서 할 수 있는 게 1도 없었는데…자바에서는 클래스의 정적 할당이 없어서 그랬나 보다. 학교에서 배우지 않은 방법(동적 할당)1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class test &#123;private: int num;public: void setNum(int n) &#123;num = n;&#125; int getNum() &#123;return num;&#125;&#125;;int main() &#123; test *t; t = new test(); t -&gt; setNum(22); cout &lt;&lt; t -&gt; getNum() &lt;&lt; endl; // 22 cout &lt;&lt; t; // 주소값이 나옴. delete t; return 0;&#125; test 클래스의 인스턴스인 t는 힙 영역에 올라가게 된다.즉 메모리 동적 할당을 하게 된 것이고,delete 해주기 전까지 메모리에서 해제되지 않는다. 동적 메모리 할당의 과정위 코드는 포인터, 자바와도 관련이 있다.어떻게 메모리에 할당되는지 과정을 지켜보자.1.test *t;변수의 타입을 test로 지정했다.즉 내가 참조해서 쓸 변수의 타입은 test이다.하지만 test라는 변수 타입은 없으므로 참조 타입이라고 봐야할 것 같다.그 참조 타입은 클래스의 이름인 것 같다. 2.t = new test();를 두 가지 관점에서 나눠 보자. t = new test(); t = new test();즉 new는 &amp;와 같은 역할을 하는 녀석인 것 같다.기본형 변수 앞에는 &amp;가, 참조형 변수 앞에는 new가 붙는 것 같다.이는 포인터에 변수의 주소를 할당하는 과정과 매우 유사한 것 같다.메모리 공간에 포인터 변수와 실제 변수 두 공간이 필요하게 되고,클래스의 동적 할당에서도 마찬가지로 포인터 변수와 클래스의 인스턴스 두 공간이 필요하기 때문이다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"C/C++","slug":"Note/C-C","permalink":"http://perfectacle.github.io/categories/Note/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"http://perfectacle.github.io/tags/Variable/"},{"name":"Static","slug":"Static","permalink":"http://perfectacle.github.io/tags/Static/"}]},{"title":"(C/C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap)","slug":"C-ref-004","date":"2017-02-09T05:31:26.000Z","updated":"2017-08-03T18:12:53.000Z","comments":true,"path":"2017/02/09/C-ref-004/","link":"","permalink":"http://perfectacle.github.io/2017/02/09/C-ref-004/","excerpt":"","text":"프로그램을 실행하게 되면 OS는 메모리(RAM)에 공간을 할당해준다.할당해주는 메모리 공간은 4가지(Code, Data, Stack, Heap)으로 나눌 수 있다. 이미지 출처: C언어의 메모리 구조 Code우리가 작성한 소스 코드가 들어간다.또한 상수도 여기에 들어간다고 한다.물론 컴파일 된 기계어가 들어갈 것이다.프로그램이 끝날 때까지 메모리에 계속 적재돼있는 놈들이다. Data전역 변수, static 변수 등등이 저장된다.프로그램이 끝날 때까지 메모리에 계속 적재돼있는 놈들이다. Stack지역 변수, 매개 변수, 리턴 값 등등이 저장된다.함수 호출 시 생성되고, 함수가 종료되면 시스템에 반환된다.프로그램이 자동으로 사용하는 임시 메모리 영역이다.또한 이름에서 보듯이 Stack 자료구조를 이용해 구현한 것 같다.컴파일 시에 크기가 결정된다. Heap프로그래머가 할당/해제하는 메모리 공간이다.malloc() 또는 new 연산자를 통해 할당하고,free() 또는 delete 연산자를 통해서만 해제가 가능하다.Java에서는 가비지 컬렉터가 자동으로 해제하는 것 같기도 하다.이 공간에 메모리 할당하는 것을 동적 할당(Dynamic Memory Allocation)이라고도 부른다.런타임 시에 크기가 결정된다. Stack 영역이 크면 클 수록 Heap 영역이 작아지고, Heap 영역이 크면 클 수록 Stack 영역이 작아진다. 그럼 Heap 영역, 동적 할당은 왜 필요한 것일까? 메모리를 효율적으로 관리할 수 있기 때문이지 않을까?임베디드 시스템을 개발하다보면 하드웨어 크기가 매우 작은 경우가 많다.하드웨어 크기가 작다는 것은 메모리의 용량도 작음을 의미한다.뭐 메모리 용량이 클 수도 있지만, 가격이 매우 비싸질 것이다.여튼 그러한 작은 메모리 공간에 프로그래머가 메모리 관리의 달인이라면…컴파일러가 자동으로 할당해주는 것보다 더 효율적인 관리가 가능하지 않을까? 배열의 길이를 사용자가 직접 정하고 싶을 경우이는 매우 단적인 예이고, 실용성이 있는지는 잘 모르겠지만…Heap 영역의 존재 이유를 설명하는 좋은 예가 될 것 같아서 가져와봤다.소스 코드 출처: C언어의 메모리 구조 123456789101112131415#include &lt;stdio.h&gt;int main() &#123; // 정상적인 배열 선언 int arr[10]; // 비정상적인 배열 선언 int i = 0; scanf(\"%d\", &amp;i); int arr2[i]; printf(\"\\nsizeof(i): %d\", sizeof(i)); // 4 printf(\"sizeof(arr): %d\", sizeof(arr)); // 40 printf(\"\\nsizeof(arr2): %d\", sizeof(arr2)); // 뭐라 꼬집어 말할 수 있을까? return 0;&#125; main 함수 내부에 있는 변수 i와 arr, arr2는 스택 영역에 올라간다.함수 내부에서 쓰인 지역 변수이기 때문이다.이는 컴파일 시에 그 크기가 결정된다.i의 크기는 int이기 때문에 4byte,arr의 크기는 int형 변수 10개가 들어간 것이기 때문에sizeof(int) * 10 = 40byte.arr2의 크기는…?stack 영역에 올라가는 arr2의 크기가 사용자의 입력에 따라서 유동적으로 바뀌게 된다.이는 정상적인 메모리 할당이라고 볼 수 없다.컴파일 시에 메모리의 크기가 결정되는 stack 영역에 올라갔음에도 불구하고,런타임 시에 메모리의 크기가 결정되기 때문에 이는 힙 영역에 올리는 게 맞다고 본다.아직 동적 할당을 제대로 배우지 않았기 때문에 이 이상의 설명과 이해는 힘들 것 같다. 참고 링크 C언어의 메모리 구조 메모리 영역(code, data, stack, heap) 동적할당과 정적할당 [C/C++] 데이터, 스택(Stack), 힙(Heap) 영역 메모리 영역 (Code, Data, BSS, HEAP, Stack), Little Endian, Stack의 이해","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"C/C++","slug":"Note/C-C","permalink":"http://perfectacle.github.io/categories/Note/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"http://perfectacle.github.io/tags/Variable/"},{"name":"Static","slug":"Static","permalink":"http://perfectacle.github.io/tags/Static/"}]},{"title":"(Java) 자바의 정석 3판 007일차 - OOP(객체, 클래스, 인스턴스), new 연산자, 참조 타입, 클래스 변수","slug":"Java-study-007day","date":"2017-02-09T04:53:40.000Z","updated":"2017-08-04T04:30:47.000Z","comments":true,"path":"2017/02/09/Java-study-007day/","link":"","permalink":"http://perfectacle.github.io/2017/02/09/Java-study-007day/","excerpt":"","text":"드디어 오늘부터 객체지향 프로그래밍(OOP, Object Oriented Programming) 파트를 나가기 시작했다.이전까지는 다른 언어에도 대부분 있는 개념이었는데,이제부터는 자바의 특성을 배울 차례인 것 같다.객체 지향 언어는 C++/Javascript 등등이 있으므로 다른 언어를 배울 때도 유익할 것 같다. 객체? 클래스? 인스턴스?객체지향하면 사람들은 클래스를 먼저 떠오르기 마련인 것 같다.하지만 객체 != 클래스이다.객체지향 언어의 하나인 자바스크립트를 통해 보도록 하자.출처: JavaScript : 프로토타입(prototype) 이해 JavaScript는 클래스라는 개념이 없습니다.그래서 기존의 객체를 복사하여(cloning)새로운 객체를 생성하는 프로토타입 기반의 언어입니다.프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들어냅니다.이렇게 생성된 객체 역시 또 다른 객체의 원형이 될 수 있습니다.프로토타입은 객체를 확장하고 객체 지향적인 프로그래밍을 할 수 있게 해줍니다. 즉, 클래스는 객체를 구현하기 위한 하나의 수단이지 그 자체가 객체는 아니란 것이다.객체는 상태와 행위를 가지는 유형과 무형의 개념(?)이다.실세계에 존재하지 않는 것들이 프로그래밍 세계에서는 객체로서 존재하기도 한다.실세계의 객체로선 불가능한 것이 프로그래밍 세계의 객체로선 가능하기도 하다.하지만 사람들의 이해를 돕기 위해서 실세계와 비교하다보니 오해가 빚어지기도 하는 것 같다.또한 객체를 구현하기 위해 클래스가 월등히 많이 쓰이다 보니 중요하지 않은 것은 아니다. 이렇게 클래스를 통해 만들어진 놈을 인스턴스라고 부른다.TV(객체) -&gt; TV 설계도(클래스) -&gt; LCD TV(인스턴스)TV(객체) -&gt; TV 설계도(클래스) -&gt; LED TV(인스턴스)뭐 나는 이정도로 이해를 했는데 맞는지 모르것다… new 연산자이는 기본형(bool, char, byte, short, int, long, float, double)이 아닌 경우에 모두 해당하는 내용이다.기본형이 아닌 경우에 모두 참조 변수이기 때문에클래스의 인스턴스틑 new 연산자를 통해 생성된다.(고 생각할 수 있다. 그 오해를 아래에서 풀어봤다.)+ 170213 내용 추가 그 오해가 오해가 아니었다. 생성자로는 인스턴스 생성이 아닌 인스턴스 변수 초기화만 해준다. new 자체가 인스턴스 생성 + 주소값 반환까지 해주는 녀석이란다.예외로 String 클래스는String str = new String(“asdf”);String str = “asdf”;두 가지 모두 허용한다.또한 자바에서 모든 참조 변수는 클래스이다.심지어 문자’열’도 클래스, 즉 참조 변수라는 사실을 알아둬야한다.JS의 Object, Array, Function, RegExp도 해당하는 내용일지는 모르겠으나 아마 해당하지 않을까…싶다. 기본적으로 클래스를 만들어서 쓰는 과정은 아래와 같다.응집도와 결합도에 내한 내용은 아래 링크를 참조하자. 결합도(Coupling), 응집도(Cohesion) getter와 setter에 대한 이유는 아래 링크를 참조하자. 인스턴스 변수의 getter, setter 설정의 궁금증123456789101112131415161718192021// test 패키지 내에 TV 클래스// 디폴트 패키지의 클래스는 어떻게 import가 안 되는 것 같다.package test;public class TV &#123; // 외부(test 클래스와 같이)에서는 상태(power, channel 등)는 알 필요 없고, // 행위(메소드)와 행위 수행을 위한 입출력 값만 알면 되기 때문에 // 상태는 숨기고, 행위를 드러내야 // 결합도는 낮추게 되고, 응집도를 높이게 되므로 유지 보수가 좋은 프로그램이 된다고 알고 있다. // 하지만 상태를 알아내야 할 필요도 있기 때문에 getter 메소드를 만드는 것으로 알고 있다. // getter와 setter가 존재하는 이유가 // 나중에 확장성을 고려했기 때문이라는데 실제로 뭐 그렇게 쓰는지는 모르겠다... // 기본 생성자가 없기 때문에 기본값인 false와 0으로 초기화 된다. private boolean power; private int channel; public void powerOnOff() &#123; power = !power; &#125; public void channelUp() &#123; channel++; &#125; public void channelDown() &#123; channel--; &#125; public int getChannel() &#123;return channel; &#125;&#125; 1234567891011121314import test.TV;class test &#123; public static void main(String[] args) &#123; // TV t = new TV(); 와 같이 한 줄로 줄여쓰는 게 편하다. TV t; // 1번 t = new TV(); // 2번 t.channelUp(); t.channelUp(); t.channelUp(); t.channelUp(); System.out.println(t.getChannel()); // 4 &#125;&#125; C++의 클래스를 보고 나니 이 역시 메모리의 동적 할당(heap 영역에 할당)되는 것 같다.자세한 내용은 아래 두 포스트에 설명해놓았다. (C/C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap) (C++) 참고용 정리 - 클래스의 두 가지 생성 방법 new 연산자의 오해나 또한 이런 오해를 가지고 있었다.new 연산자를 통해 클래스의 인스턴스가 생성되는구나!완전히 틀렸다.new 없이도 클래스의 인스턴스의 생성은 가능하다.그 말 뜻을 한 번 파헤쳐보자.오해가 아니라 맞는 말이었다. TV t;변수의 타입을 TV로 지정했다.하지만 TV라는 변수 타입은 없으므로 참조 타입이라고 봐야할 것 같다.그 참조 변수의 타입은 클래스의 이름인 것 같다.참조 변수는 값을 가지는 게 아니라 참조할 메모리의 주소값을 가진다.하지만 아직 참조 변수 선언만 했으므로 안에는참조 변수의 기본 값인 null이 들어가있을 것이다. t = new TV();이 부분을 세 가지 관점에서 나눠서 보고자 한다. t = new TV();TV()라는 생성자(여기서는 기본 생성자)만 호출해도클래스의 인스턴스는 생성되게 된다.인스턴스 변수의 초기화(생성자 호출)만 이루어진다. t = new TV();new라는 키워드는 C언어의 &amp;와 비슷하다고 보면 될 것 같다.해당 변수가 할당된 메모리 상의 주소값을 얻어오는 연산자이다.즉 저 키워드를 씀으로써 rvalue에는 0x1234가 들어가게 된다.위와 더불어 인스턴스 생성까지 이루어진다. t = new TV();= 이라는 대입, 할당 연산자를 사용하여rvalue인 0x1234를 lvalue인 t에 할당, 대입하면서클래스의 인스턴스의 주소를 할당하게 되는 것이다. 즉, new 연산자를 통해 클래스의 인스턴스가 생성되는 게 아니라 맞다!!주소값만을 얻어내는 연산자이지, 실제로는생정자(TV())를 통해 만들어지게 되는 것이었다게 아니라 생성자로는 인스턴스 변수의 초기화만 이루어진다!! 데이터 저장 개념의 발전 과정 변수, 하나의 데이터만 저장 가능. 123456int a = 1;int b = 2;int c = 3;double d = 1.2;double e = 3.3;double f = 4.4; 배열, 동일한 데이터의 타입들을 저장 가능. 12int a[] = &#123;1, 2, 3&#125;;double b[] = &#123;1.2, 3.3, 4.4&#125;; 구조체(C언어에서 등장함), 동일하지 않은 데이터의 타입들도 저장 가능. 1234struct a &#123; int arr[]; double arr2[];&#125;; 클래스, 동일하지 않은 데이터 타입들 + 함수 1234567class a &#123; int a[] = &#123;1, 2, 3&#125;; double b[] = &#123;1.2, 3.3, 4.4&#125;; void println() &#123; System.out.println(\"얀냐셈!\"); &#125;;&#125; C언어와 같은 절차 지향 언어에서는 데이터는 데이터끼리, 함수는 함수끼리 따로 생각을 하였다.하지만 함수는 주로 데이터를 가지고 작업을 하기 때문에객체 지향 언어인 C++과 Java에서는 이 둘을 합친 Class가 등장하게 된 것이다.절차 지향 언어인 C언어에서는 문자열이 문자의 배열에 그치는데 반해객체 지향 언어인 Java에서는 문자열(데이터)과 문자열과 관련된 함수(메소드)를 같이 모아String 클래스로 따로 뺀 이유가 위와 같다. 사용자 정의 타입기본형(Primitive type) 외에 프로그래머가 서로 관련된 변수들을 묶어서하나의 타입으로 새로 추가하는 것을 사용자 정의 타입(User-defined type)이라고 한다.자바와 같은 객체 지향 언어에서는 클래스가 곧 사용자 정의 타입이다.이 사용자 정의 타입은 프로그래머에 의해 만들어지므로 갯수에 제한이 없다. 클래스 변수클래스의 변수는 멤버 변수(클래스 변수, 인스턴스 변수), 지역 변수로 나뉜다.123456789class tt &#123; // 우리 둘은 멤버 변수 int a; // 나는 멤버 변수 중에 인스턴스 변수 static int b; // 나는 멤버 변수 중에 클래스 변수 void test() &#123; int t; // 나는 지역 변수 &#125;&#125; 클래스 변수는 클래스가 메모리에 적재되는 순간(import건 class를 선언했건) 만들어진다.12345package test;public class TV &#123; public static int a;&#125; 123456class test &#123; public static void main(String[] args) &#123; TV.a = 4; System.out.println(TV.a); // 4 &#125;&#125; 12345678910class TV &#123; static int a;&#125;class test &#123; public static void main(String[] args) &#123; TV.a = 4; System.out.println(TV.a); // 4 &#125;&#125; 하지만 인스턴스 변수는 클래스의 인스턴스를 생성(TV())해야지만 만들어진다.또한 인스턴스 변수는 클래스의 인스턴스마다 고유한 값을 가지지만,클래스 변수는 같은 클래스의 인스턴스라면 모두 그 값을 공유하게 된다.클래스 변수(static 변수)는 같은 주소를 참조하기 때문이다.사용할 때 클래스의 변수는 TV.b와 같이 클래스 이름.변수와 같이 사용하지만인스턴스 변수는 t.a와 같이 인스턴스 이름.변수와 같이 사용한다.물론 클래스 변수도 인스턴스 이름.변수와 같이 사용할 수 있지만,인스턴스 변수와 헷갈리므로 추천하지 않는다. 궁금해서 예제를 만들어보았으니 C언어의 static 변수와 비교해보면 참 재밌다.12345678910111213141516171819202122232425262728293031class TV &#123; // Java에서는 클래스 외부에 변수를 선언할 수 없다. // static 변수는 마치 전역변수와 같다. // 왜냐면 다른 클래스에서도 사용이 가능하기 때문이다. static int a; int b = 22;&#125;class TV2 &#123; // static 변수는 어디서나 참조가 가능하다.(물론 접근 지정자에 따라 다르지만) // 난 그래서 이 static 변수가 진정한 의미의 전역 변수이고, // 인스턴스 변수는 인스턴스가 생성되어야만 사용할 수 있고, 값의 공유가 되지 않기 때문에 // 가짜 전역 변수라고 생각한다. int b = TV.a; int c = new TV().b;&#125;class test &#123; static int ii = 123; public static void main(String[] args) &#123; TV.a = 4; System.out.println(TV.a); // 4 TV2 t = new TV2(); // TV.a == 4 TV.a = 33; TV2 t2 = new TV2(); // TV.a == 33 System.out.println(t.b); // 4 System.out.println(t2.b); // 33 System.out.println(t2.c); // 22 System.out.println(ii); // 123, 같은 클래스 내의 static 변수는 클래스 이름 생략이 가능함. &#125;&#125; 우선 C언어의 static 변수는 스코프가 지역 변수의 성향을 띄는데 반해Java의 static 변수는 전역 변수의 성향을 띈다.어디서나 접근이 가능하다.하지만 사용하려면 클래스 이름.변수로 적어야해서 좀 불편시럽긴 하다. 또 하나 특징이 있다.12345678910111213141516171819class test2234 &#123; void a() &#123; int a; &#125; // static이 붙지 않은 메소드끼리 호출 가능. void c() &#123; a(); &#125; // static이 붙지 않은 메소드에서 static 메소드 호출 가능. void b() &#123; d(); &#125; // static이 붙은 메소드에서 static이 붙지 않은 메소드 호출 불가능. static void d() &#123; a(); // 에러당! &#125;&#125; 170211, 내용 추가위 코드에 대한 이유는 아래 링크에서 설명하고 있다.(Java) 자바의 정석 3판 009일차 정리 머리가 아프당…나머지 개념은 내일이나 나중에 정리해야겠다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"OOP","slug":"OOP","permalink":"http://perfectacle.github.io/tags/OOP/"}]},{"title":"(자작) 동적 테이블 생성기","slug":"dynamic-table-generator","date":"2017-01-30T23:59:04.000Z","updated":"2017-02-09T13:24:07.000Z","comments":true,"path":"2017/01/31/dynamic-table-generator/","link":"","permalink":"http://perfectacle.github.io/2017/01/31/dynamic-table-generator/","excerpt":"","text":"개발 배경예전부터 테이블 태그는 참 헷갈렸다.어떤 게 행이고 어떤 게 열인지…가끔은 행과 열 조차도 헷갈렸다. scope=”row”, scope=”col” rowspan, colspan row, col 그래서 그냥 내 맘대로 합치고 바꾸고 제목 설정하고 싶었다.한글이나 엑셀에서는 가능한 것 같지만 HTML에서는 불가능 한 것 같았다.그러한 불편함을 감수하고자 1년 전에 몇 시간동안 간단히 만든 적이 있다.동적 테이블 생성 초기 버전 하지만 그냥 써보기만 해도 문제가 참 많다는 걸 알 수 있다.그렇게 기억 속에 묻혀있었는데, 어느 한 분께서 친절하게 해당 사항에 대해 얘기를 꺼내셨고,설날에 잉여였던 나는 길어야 2일 걸릴 줄 알았는데, 4일 밤낮을 샌 것 같다…동적 테이블 생성기 v1.0 혹시 미천한 프로젝트가 궁금하시거나 개선하고 싶으신 분은 아래 링크로 들어가길 바란다.(스타도 박아주심 헤헤헤…)동적 테이블 깃헙 링크 사용 방법기본 사용 방법기본적인 사용 방법은 아래와 같다.제목행(th scope=”col”), 제목열(th scope=”row”)캡션, colspan, rowspan에 중점을 뒀다. 수정 모드초기 버전과는 다르게 수정모드도 붙여 보았다.엔터를 누르면 저장, ESC를 누르면 취소가 된다. JSON, 사용자 편의 고려표가 복잡하면 다시 새롭게 만들기 귀찮은데,이런 유저를 위해 제이슨 형태로 저장할 수 있게 제공하였다. 하지만 가독성이 구린 문제점이… 지못미…제이슨에서 다른 셀과 구분 짓기 위해 병합된 셀의 정보는 다음과 같이 나타난다.%데이터:rowspan,colspan%병합된 셀은 %collapsedCell%과 같이 나타냈다.가독성이 안 좋지만 딱히 방법이 떠오르지 않았다… ㅠㅠ여하튼 이렇게 가독성이 구린 데이터를 함부로 손 댔다가는 테이블 조차 만들 수도 없을 것이다. 셀 병합에 있어서 또 다른 문제점또한 제목 행은 &lt;thead&gt; 안에 있고, 나머지 행은 &lt;tbody&gt;에 있기 때문에제목 행과 다른 행을 합칠 순 없다. 백업은 필수테이블을 새로 생성하면 기존 데이터는 날아가기 때문에귀찮더라도 제이슨 데이터는 항상 백업해두자. 마치며…내가 이 짓을 할 시간에 리액트, 자바, ES6 등등을 공부했더라면엄청나게 많은 지식을 습득했을 것 같은데 그래도 후회는 없다. 일단 지금 공부하고 있는 자스민, 카르마를 연동해서 TDD를 해보았다.(+ESLint)TDD가 없었다면 이 많은 케이스를 테스트 할 엄두가 나지 않았을 것이다.물론 아직도 귀찮거나 미처 테스트하지 못한 케이스들이 존재할테지만…어느정도 예상 가는 부분드은 중간중간 앱을 먼저 개발하기도 했다.또한 처음엔 규모가 별로 크지 않을 줄 알고 script.js 파일 하나 안에 다 때려 박았다가도저히 감당이 안 돼서 객체 지향의 원리를 곱씹어봐서 쪼개긴 했는데…매우 허술하고 설계를 먼저 끝내고 코딩을 한 게 아니라생각나는 대로 쪼개고 귀찮으면 하나에 몰아넣기도 한 것 같다.또한 모듈로 쪼개다보니 어쩔 수 없이 웹팩을 쓰게 됐고 바벨까지 얹어서복습할 좋은 기회가 된 것 같다.또한 뷰나 리액트로 만들었으면 좋았을 것 같은데, 너무 산으로 가는 느낌과공부하려면 시간이 곱절로 들 것 같아서 일단 포기. 주절주절 많은 걸 쓰고 느낀 것 같다…이런 것도 포트폴리오로 쓸 수 있으려나??","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"자작","slug":"기타/자작","permalink":"http://perfectacle.github.io/categories/기타/자작/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"http://perfectacle.github.io/tags/Computer/"},{"name":"HTML","slug":"HTML","permalink":"http://perfectacle.github.io/tags/HTML/"},{"name":"Table","slug":"Table","permalink":"http://perfectacle.github.io/tags/Table/"}]},{"title":"(ES6+) ajax를 위한 fetch와 async/await","slug":"ES6-ajax-with-fetch","date":"2017-01-25T09:37:49.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2017/01/25/ES6-ajax-with-fetch/","link":"","permalink":"http://perfectacle.github.io/2017/01/25/ES6-ajax-with-fetch/","excerpt":"","text":"이 글을 읽기 전에 (ES6) ajax 위주의 promise 실습를 먼저 읽을 것을 권한다.ajax(XMLHttpRequest)와 promise에 대한 기본적인 이해가 있다면 상관없긴 하다.조현영 님의 제보에 의하면 ie에서 fetch가 안 되고,async/await 크롬과 오페라에서만 된다고 한다.아래 사이트에서 확인 가능하다.https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#Browser_compatibilityECMAScript Next compatibility table fetch다시 공부하다보니 XMLHttpRequest와 Fetch는 ECMAScript가 아니라고 한다.브라우저에서만 쓰이는 API이기 때문에 babel에서도 지원해주지 않기 때문에크로스 브라우징을 위해선 window.fetch polyfill을 쓰자.우선 기존에 우리가 ajax를 하기 위해서 어떻게 했는지 보자.12345678910111213141516171819202122const jsonURL = \"https://perfectacle.github.io/mock/test.json\";const getDataAjax = url =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(\"get\", url, true); xhr.responseType = \"json\"; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful for(let key in xhr.response) &#123; // 받아온 json 데이터의 키와 값의 쌍을 모두 출력. if(xhr.response.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;xhr.response[key]&#125;`); &#125; &#125; else &#123; // 통신 상에 오류가 있었다면 오류 코드를 출력. console.error(`http status code: $&#123;xhr.status&#125;`); &#125; &#125; &#125;; xhr.send();&#125;;getDataAjax(jsonURL); 이 복잡한 getDataAjax 부분을 줄여보자.123456789101112const jsonURL = \"https://perfectacle.github.io/mock/test.json\";const getDataAjaxFetch = url =&gt; ( fetch(url).then(res =&gt; res.json()));getDataAjaxFetch(jsonURL).then(data =&gt; &#123; for(let key in data) &#123; // 받아온 json 데이터의 키와 값의 쌍을 모두 출력. if(data.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;).catch(err =&gt; console.error(err)); fetch API는 XMLHttpRequest를 대신하기 위한 방안 중 하나이다.아직 표준안은 아니고, 크롬에서 당장 사용이 가능하다.자세한 설정은 fetch API을 확인하자. 그럼 대충 fetch를 뜯어보자.1console.dir(fetch(\"https://perfectacle.github.io/mock/test.json\")); Promise 인스턴스가 반환된다.Promise에서 실제로 쓰고 싶은 값은 [[PromiseValue]]에 들어있는데 이를 직접 접근하지 못한다.따라서 then() 메소드를 써야한다.12fetch(\"https://perfectacle.github.io/mock/test.json\").then(res =&gt; console.dir(res)); 반환된 결과를 보니 Response의 인스턴스가 반환됐다.처음 보는 놈이다.뭐 쓰고 싶은 값을 찾아낼 수가 없다.여기서 또 하나의 메소드를 쓰면 된다.12fetch(\"https://perfectacle.github.io/mock/test.json\").then(res =&gt; console.dir(res.json())); Response 인스턴스는 문자열이 아니다.따라서 toJSON() 대신에 json() 메소드를 쓰면 json 형태로 바꿀 수 있다.바꿨더니 또 promise 인스턴스다.[[PromiseValue]]를 한 번 더 벗겨야한다.123fetch(\"https://perfectacle.github.io/mock/test.json\").then(res =&gt; res.json()).then(data =&gt; console.dir(data)); 드디어 우리가 원하는 값을 얻어냈다.기존의 XMLHttpRequest와 Promise를 사용했을 때보다 then을 한 번 더 타야한다는 단점이 있다.근데 뭐 간단해지니 장점이 더 많은 것 같다. 그럼 기존 XMLHttpRequest와 Fetch를 비교해보자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const jsonURL = [ \"https://perfectacle.github.io/mock/test.json\", \"https://perfectacle.github.io/mock/test2.json\"];// promise에 파라미터를 넘겨주기 위해선 밖에서 함수로 한 번 래핑해줘야 함.const getDataAjaxPromise = url =&gt; ( // thenable하게 하기 위해 Promise 인스턴스를 리턴. new Promise((res, rej) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(\"get\", url, true); xhr.responseType = \"json\"; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful res(xhr.response); // 성공했을 시 실행할 콜백 함수. &#125; else &#123; rej(xhr.status); // 실패했을 시 실행할 콜백 함수. &#125; &#125; &#125;; xhr.send(); &#125;));// 성공 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: higetDataAjaxPromise(jsonURL[0]).then(data =&gt; &#123; res(data); // promise 인스턴스에 파라미터를 넘기기 위해선 다시 함수를 호출해야하고, // thenable 하게 만들어야하기 때문에 함수의 반환값(프라미스 인스턴스)을 리턴해줘야함. return getDataAjaxPromise(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;)// 더 이상 비동기로 처리할 내용이 없으므로 return문은 필요 없어짐..then(data =&gt; res(data)).catch(err =&gt; console.error(`http status code: $&#123;err&#125;`)); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const jsonURL = [ \"https://perfectacle.github.io/mock/test.json\", \"https://perfectacle.github.io/mock/test2.json\"];// 성공 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; if(data.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;const getDataFetch = url =&gt; ( fetch(url).then(res =&gt; res.json()));// 이 부분은 promise와 크게 차이나진 않는다.getDataFetch(jsonURL[0]).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[0]);&#125;).then(data =&gt; res(data)).catch(err =&gt; console.error(err)); async &amp; await (ES2017)여기서 끝내기 아쉬우니 한번 코드를 Promise의 단점을 보완해보자.요놈은 아직 표준 확정은 아니다. (ES2017이 나온 게 아니니…)그래도 뭐 크롬에서 돌아가니 한 번 알아보자. 12345678910111213141516171819202122232425262728293031323334353637const jsonURL = [ \"https://perfectacle.github.io/mock/test.json\", \"https://perfectacle.github.io/mock/test2.json\"];const getDataFetch = url =&gt; ( fetch(url).then(res =&gt; res.json()));// 성공 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; if(data.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;// async 함수 안에서 비동기 코드 앞에 await를 붙여주면 된다.// 안타깝게도 async '함수'라서 호출을 위해 즉시 실행함수를 사용했다.(async () =&gt; &#123; // try-catch 문으로도 완벽하게 오류를 잡아낸다. // 하지만 에러코드가 제대로 출력되지 않는다. try &#123; await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi &#125; catch(err) &#123; // 하나의 통신이라도 실패하면 뒤에 오는 통신은 씹어버린다. console.error(err); // 직접 URL을 틀리게 입력해서 오류를 뭐라고 뿜는지 보자. &#125;&#125;)(); 마치며Promise, Fetch, Async/Await 모두 수박 겉핥기 식으로 공부해서글에 부족한 부분이 매우 많을 것이니 무한 태클 환영합니다~제가 들은 말로 정리를 해보자면… 콜백 함수ㄴ&nbsp;&nbsp;ㄴ&nbsp;&nbsp;&nbsp;&nbsp;ㄴ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ㄴ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ㄴ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ㄴ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ㄴ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ㄴ Promise(Fetch 또한 Promise를 쓰는 것)ㄴ&nbsp;&nbsp;ㄴ&nbsp;&nbsp;ㄴ&nbsp;&nbsp;ㄴ&nbsp;&nbsp;ㄴ&nbsp;&nbsp;ㄴ&nbsp;&nbsp;ㄴ&nbsp;&nbsp;ㄴ&nbsp;&nbsp;ㄴ Async/Awaitㄴㄴㄴㄴㄴㄴㄴㄴㄴ","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ajax","slug":"ajax","permalink":"http://perfectacle.github.io/tags/ajax/"},{"name":"ES6+","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015+","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"}]},{"title":"(C/C++) 참고용 정리 - 전역 변수 vs 지역 변수 vs static 변수","slug":"C-ref-003","date":"2017-01-25T00:31:26.000Z","updated":"2017-08-03T18:12:53.000Z","comments":true,"path":"2017/01/25/C-ref-003/","link":"","permalink":"http://perfectacle.github.io/2017/01/25/C-ref-003/","excerpt":"","text":"전역 변수(Global Variable) 1234567891011121314#include &lt;stdio.h&gt;int var = 3; // 전역변수void add() &#123; var++; // 어디서나 접근 가능 printf(\"%d\\n\", var); // 4&#125;int main() &#123; add(); printf(\"%d\", var); // 4, 값의 유지 return 0;&#125; 값의 유지 어디에서든 접근 가능 main 함수 실행 전에, 프로그램이 실행되자 마자 메모리에 할당됨. 프로그램이 끝나는 순간 메모리에서 해제됨. 메모리의 Data 영역에 적재됨.&nbsp;2번의 이유로 인해서 변수의 스코프가 더럽혀진다.더럽혀진다는 의미는 변수 이름의 충돌 가능성이 존재하고,그로 인해 변수 이름 짓기에 큰 시간을 할애해야 하며,변수의 이름이 길어지거나 이상해지는 경우도 존재한다.어디서나 접근 가능하기 때문에 실수로 변수의 값이 바뀔 가능성이 존재한다.뭐 그렇다고 해서 꼭 안 좋은 것만은 아니기 때문에 적절히 활용하면 된다. 지역 변수(Local Variable) 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int var = 3; // 전역변수void add() &#123; int var = 4; var++; // 지역 변수의 우선순위가 전역 변수보다 높음. printf(\"%d\\n\", var); // 5&#125;int main() &#123; &#123; // block scope int asdf = 33; printf(\"%d\", asdf); &#125; // printf(\"%d\", asdf); // 스코프를 벗어나서 컴파일 오류가 남. add(); printf(\"%d\\n\", var); // 3, 값의 유지가 안 됨. int i = 0; // 지역 변수 i의 scope 시작 for(int i=0; i&lt;3; i++) &#123; printf(\"%d \", i); // 0 1 2 &#125; // 지역 변수 i의 scope 끝 printf(\"\\n%d\", i); // 0, 여기서 나온 건 전역 변수 i return 0;&#125; 매번 새로운 값 생성, 값의 유지가 안 됨. 지정된 블록 스코프(제어문, 함수 등등)에서만 접근 가능 함수가 실행되는 순간마다 메모리에 할당됨. 함수가 종료되는 순간마다 메모리에서 해제됨. 메모리의 Stack 영역에 적재됨.&nbsp;값이 유지되지 않기 때문에 함수를 실행할 때마다 매번 똑같은 값을 써야할 때 쓴다.스코프 내에서만 접근 가능하기 때문에 유지보수에 용이하다.가능하면 스코프의 범위는 좁은 게 유지보수하기 편하다고 들었다. static 변수 12345678910111213#include &lt;stdio.h&gt;void add() &#123; static int var = 4; var++; printf(\"%d\\n\", var); &#125;int main() &#123; add(); // 5 add(); // 6 return 0;&#125; 값의 유지 지정된 블록 스코프(제어문, 함수 등등)에서만 접근 가능 main 함수 실행 전에, 프로그램이 실행되자 마자 메모리에 할당됨. 프로그램이 끝나는 순간 메모리에서 해제됨. 메모리의 Data 영역에 적재됨.&nbsp;값이 유지돼야 하지만, 유지보수 등등 때문에 전역변수도, 지역변수도 마땅치 않을 때가 있다.이럴 때 쓰는 게 static 변수이다.값이 유지 된다는 전역 변수의 특징과 지정된 스코프에서만 접근 가능하다는 지역 변수가 짬뽕된 케이스이다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"C/C++","slug":"Note/C-C","permalink":"http://perfectacle.github.io/categories/Note/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"http://perfectacle.github.io/tags/Variable/"},{"name":"Static","slug":"Static","permalink":"http://perfectacle.github.io/tags/Static/"}]},{"title":"(Java) 자바의 정석 3판 006일차 - 배열","slug":"Java-study-006day","date":"2017-01-24T01:17:58.000Z","updated":"2017-08-04T04:30:47.000Z","comments":true,"path":"2017/01/24/Java-study-006day/","link":"","permalink":"http://perfectacle.github.io/2017/01/24/Java-study-006day/","excerpt":"","text":"배열Java에서는 길이가 0인 배열의 선언도 가능하다.또한 길이는 int 범위의 양의 정수이다.1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Arrays;public class test2 &#123; public static void main(String[] args) &#123; // 둘 다 가능하지만 후자가 C/C++에서 먹히는 스타일이라 이식성이 높다고 생각한다. int[] num = new int[5]; boolean flag[] = new boolean[5]; // 배열을 초기화하지 않으면 기본값으로 초기화 돼서 나온다. for(int i=0; i&lt;num.length; i++) System.out.println(num[i]); // 0 for(int i=0; i&lt;flag.length; i++) System.out.println(flag[i]); // false double num2[] = new double[]&#123;1.1, 4.5&#125;; // 선언과 동시에 초기화. double num3[] = new double[5]&#123;1.1, 4.5&#125;; // 길이를 지정해주면 오류가 난다. double num4[] = &#123;1.5, 3.14, 15&#125;; // 선언과 동시에 초기화 할 때는 new 연산자를 뺄 수 있다. // 선언과 초기화를 따로 할 때는 new 연산자를 써서 할당까지 해주어야 한다. double num5[]; num5 = new double[]&#123;33.123, 51.792&#125;; // 아래와 같은 경우를 불허한다. double num6[] = new double[123]; num6 = &#123;123.22, 33&#125;; // 수정할 때는 new 연산자를 써서 새로 만들어줘야한다. num2 = new double[]&#123;123, 456, 111.33&#125;; // 아래 세 문장은 배열의 길이가 0이다. int num7[] = new int[]&#123;&#125;; int num8[] = new int[0]; int num9[] = &#123;&#125;; // import java.util.Arrays; // java 패키지의 utill 패키지의 Arrays 클래스에 있는 toString이라는 메소드를 쓴다. System.out.println(Arrays.toString(num4)); // [1.5, 3.14, 15.0] // char 배열은 for 문이나 다른 메소드를 안 써도 된다. char ch[] = &#123;'h', 'e', 'l', 'l', 'o'&#125;; System.out.println(ch); // hello &#125;&#125; 배열을 복사하는 방법 하드코딩(비효율적) 12345678910111213141516171819202122import java.util.Arrays;public class test2 &#123; public static void main(String[] args) &#123; // 배열의 길이를 늘리고 싶다고 생각하면 아래와 같이 복사해야한다. int arrNum[] = &#123;1, 2, 3, 4, 5&#125;; int arrNumLen = arrNum.length; // 배열의 길이가 너무 길어지면 메모리에 부담이 되므로 x2 정도가 적당하다. int tmp[] = new int[arrNumLen*2]; // for 문을 돌리는 부분에서도 상당한 비용을 소모한다. for(int i=0; i&lt;arrNumLen; i++) &#123; tmp[i] = arrNum[i]; &#125; arrNum = tmp; // 원본 배열과의 참조 관계가 끊겼다는 걸 알 수 있다. // 즉 원본 배열 [1, 2, 3, 4, 5]는 가비지 컬렉팅 대상이 된다. System.out.println(arrNum.length); // 10 System.out.println(Arrays.toString(arrNum)); // [1, 2, 3, 4, 5, 0, 0, 0, 0, 0] &#125;&#125; 내장된 API 사용(효율적) 12345678910111213141516171819202122import java.util.Arrays;public class test2 &#123; public static void main(String[] args) &#123; // 배열의 길이를 늘리고 싶다고 생각하면 아래와 같이 복사해야한다. int arrNum[] = &#123;1, 2, 3, 4, 5&#125;; int arrNumLen = arrNum.length; // 배열의 길이가 너무 길어지면 메모리에 부담이 되므로 x2 정도가 적당하다. int tmp[] = new int[arrNumLen*2]; // for 문은 요소 하나하나마다 접근하지만 // 배열은 연속된 메모리 공간이라는 점을 활용하여 // arraycopy 메소드는 하나의 값으로 취급하여 접근한다고 한다. System.arraycopy(arrNum, 0, tmp, 0, arrNumLen); arrNum = tmp; // 원본 배열과의 참조 관계가 끊겼다는 걸 알 수 있다. // 즉 원본 배열 [1, 2, 3, 4, 5]는 가비지 컬렉팅 대상이 된다. System.out.println(arrNum.length); // 10 System.out.println(Arrays.toString(arrNum)); // [1, 2, 3, 4, 5, 0, 0, 0, 0, 0] &#125;&#125; String 클래스의 배열1234567891011public class test2 &#123; public static void main(String[] args) &#123; String str[] = new String[3]; // [null, null, null] // String은 기본형이 아니기 때문에 전자와 같이 써야하지만 후자와 같이 간편히 쓰는 걸 허용한다. // 그리고 기본형이 아닌 참조 변수이기 때문에 값이 아닌 주소가 아닌 객체의 주소가 담겨있다. // 객체의 주소는 그냥 임의대로 넣은 거니 크게 의미를 담지 말길 바란다. String str2[] = &#123;new String(\"asdf\"), new String(\"qwer\")&#125;; // [0x100, 0x200] String str3[] = &#123;\"asdf\", \"qwer\"&#125;; // [0x400, 0x500] &#125;&#125; String 클래스는 char 배열에 기능을 추가하여 확장한 것.객체 지향 이전의 절차 지향의 C언어의 경우에는데이터와 기능을 따로 다루었지만(그래서 char 배열로 문자열을 표현),객체 지향 개념인 Java에서는 데이터와 그와 관련된 기능을 하나의 클래스로 묶음.기능 = 함수 = 메소드라고 보면 된다. 하지만 char 배열과 달리 String 클래스는 내용의 변경이 불가능하다.변경 가능한 String 클래스는 StringBuffer라는 클래스가 따로 있다.1234567public class test2 &#123; public static void main(String[] args) &#123; String str = \"asd\"; str += \"8\"; // 변경되는 게 아니라 새로운 문자열이 생성된 것이다. System.out.println(str); // asd8 &#125;&#125; String 클래스와 char 배열의 변환은 아래와 같다.1234567public class test2 &#123; public static void main(String[] args) &#123; char ch[] = &#123;'h', 'i'&#125;; String str = new String(ch); char ch2[] = str.toCharArray(); &#125;&#125; 향상된 for문12345678910111213141516171819202122232425public class test2 &#123; public static void main(String[] args) &#123; int nums[] = &#123;4, 5, 6&#125;; for(int num : nums) &#123; num = 1; // 값이 변경 될까? &#125; for(int num : nums) &#123; System.out.print(num ); // 4 5 6 &#125; System.out.println(); int nums2[][] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;; // 이중 배열 안에 있는 놈도 배열이므로 // int num2[]와 같이 해줘야 함. for(int num2[] : nums2) &#123; for(int num : num2) &#123; System.out.print(num); &#125; System.out.println(); &#125; &#125;&#125; 다차원 배열12345678910111213141516171819public class test2 &#123; public static void main(String[] args) &#123; int nums[][] = new int[3][]; // 아래와 같은 형태의 배열이 됨. // 정사각형이 아닌 배열을 만들 수 있게 됨. // int int // int int int // int int int int nums[0] = new int[2]; nums[1] = new int[3]; nums[2] = new int[4]; // 아래와 같은 것도 가능하다. int nums2[][] = &#123; &#123;1, 2&#125;, &#123;1, 2, 3&#125;, &#123;1, 2, 3, 4&#125; &#125;; &#125;&#125; 가변 배열 문제만 보고 있다보니 드럽게 재미없다.좀 쉬다가 다른 공부나 해야지… + 내용 추가(170125) 연습문제 오답 정리 배열의 잘못된 선언 및 초기화b. int[] arr = {1,2,3,}; // 마지막의 쉼표는 있어도 상관없음.d. int[] arr = new int[5]{1,2,3,4,5}; // 두 번째 대괄호[]에 숫자 넣으면 안됨.e. int arr[5]; // 배열을 선언만 할 때는 배열의 크기를 지정할 수 없음.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"배열","slug":"배열","permalink":"http://perfectacle.github.io/tags/배열/"}]},{"title":"(ASM) 참고용 정리 - 리틀 엔디안, 빅 엔디안","slug":"ASM-ref-002","date":"2017-01-23T23:52:21.000Z","updated":"2017-02-13T04:46:22.000Z","comments":true,"path":"2017/01/24/ASM-ref-002/","link":"","permalink":"http://perfectacle.github.io/2017/01/24/ASM-ref-002/","excerpt":"","text":"엔디안은 시스템 프로그래밍에서 많이 쓰이는 용어이다.엔디안은 메모리의 저장 및 처리 방식을 말하는 것이다.이는 바이트 순서(Byte Order)와도 큰 관련이 있다. 빅 엔디안(Big Endian)메모리의 높은 번지 부터 저장하는 방식MSB(Most Significant Byte), 최상위 바이트부터 차례로 저장한다. 리틀 엔디안(Little Endian)메모리의 낮은 번지 부터 저장 하는 방식LSB(Least Significant Byte), 최하위 바이트부터 차례로 저장한다. 4바이트에 값이 저장되는 방식을 알아보자. 10진수 빅 엔디안 리틀 엔디안 0 0x00000000 0x00000000 1 0x00000001 0x01000000 2 0x00000002 0x02000000 3 0x00000003 0x03000000 4 0x00000004 0x04000000 5 0x00000005 0x05000000 6 0x00000006 0x06000000 7 0x00000007 0x07000000 8 0x00000008 0x08000000 9 0x00000009 0x09000000 10 0x0000000A 0x0A000000 11 0x0000000B 0x0B000000 12 0x0000000C 0x0C000000 13 0x0000000D 0x0D000000 14 0x0000000E 0x0E000000 15 0x0000000F 0x0F000000 빅 엔디안 방식이 우리가 자주 생각하는 저장 방식이다.빅 엔디안은 가독성이 뛰어나고 대소 비교도 편하고 등등의 장점이 많다.또한 네트워크 통신에서는 빅 엔디안 방식을 이용하자고 약속하였다.0x00000001을 A 컴퓨터는 빅 엔디안 방식으로 숫자 ‘1’을 보낸것인데리틀 엔디안 방식인 컴퓨터 B는 데이터를 받을 때 0x01000000으로 받는다.그럼 A는 숫자 ‘1’을 보냈는데 컴퓨터 B는 ‘268435456’을 받은 꼴이 돼버리기 때문이다. 그럼 리틀 엔디안은 왜 나왔을까…?가산기를 설계할 때 올림수를 계산하기 편하고, 빠르기 위함이란다.15 + 1 을 빅 엔디안 방식으로 계산하면0x0000000F + 0x00000001 = 0x00000010으로 계산 후 최하위 바이트로 이동해서 올림수가 발생한다.이번앤 리틀 엔디안 방식으로 계산해보자.0x0F000000 + 0x01000000 = 0x10000000올림수를 계산할 때 최상위 바이트에서 바로 올림수가 가능하기 때문이다.라고 이해했는데 뭐 케바케기도 할 것 같고 요즘엔 둘 사이에 차이가 거의 없다고 한다. 또한 이런 엔디안은 CPU에 의존적이다.주로 인텔 CPU가 리틀 엔디안 방식을 사용한다고 한다.비디오 게임기인 SFC, NDS 등등에서도 리틀 엔디안 방식을 사용하는 경우가 많으니 참고하자. 참조 링크 시스템 프로그래밍 리틀 엔디안(Little Endian), 빅 엔디안(Big Endian) 리틀 엔디안 VS 빅 엔디안","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ASM","slug":"Programming/ASM","permalink":"http://perfectacle.github.io/categories/Programming/ASM/"}],"tags":[{"name":"ASM","slug":"ASM","permalink":"http://perfectacle.github.io/tags/ASM/"},{"name":"Assembly","slug":"Assembly","permalink":"http://perfectacle.github.io/tags/Assembly/"},{"name":"Endian","slug":"Endian","permalink":"http://perfectacle.github.io/tags/Endian/"}]},{"title":"(상식) 무선 공유기 암호와 속도에 관한 진실","slug":"Wifi-password-fact","date":"2017-01-23T23:02:39.000Z","updated":"2017-08-03T08:31:35.000Z","comments":true,"path":"2017/01/24/Wifi-password-fact/","link":"","permalink":"http://perfectacle.github.io/2017/01/24/Wifi-password-fact/","excerpt":"","text":"공유기에 암호를 걸어놓는다는 것의 의미무선 공유기의 보안 때문에 AP에 암호를 걸어놓는 경우가 많다.여기서 무선 공유기에 암호를 건다는 것은… 무선 공유기에 타인이 접속하는 걸 방지하고자 암호를 건다.(WPA2PSK와 같은 방식으로…) 송수신하는 데이터(평문으로 된 개인정보 등등)을 암호화 하고자 데이터를 암호화 한다.(AES와 같은 알고리즘으로…) 하지만 암호를 걸어놓음으로써 인터넷 속도가 줄어든다는 사실을 알고 있는가?Why?우리가 보내는 데이터 -&gt; 암호화 -&gt; 전송과 같이‘암호화’의 단계가 포함되기 때문에 당연히 느려질 수 밖에 없다.그럼으로 인해서 아예 암호를 걸어놓지 않고 사용하는 사람들이 있다. 공유기에 암호 걸지 않고 사용하기이러한 방법은 매우 위험하다.타인이 나의 AP로 접근하여 동영상 등등의 기타 데이터를 마구 발생시키고 있다면자신이 쓸 수 있는 속도가 줄어든다.10MiB/s를 두 명이 나눠쓰면 5MiB/s로 줄어들거나동영상을 받고 있는 유저가 거의 10MiB/s 가까이 끌어다 쓰는 등등…혹은 한 AP에 접속된 기기가 많을 수록 혼선이 발생되는 등등 인터넷 접속이 불안정해지게 된다. 이를 해결하기 위한 여러가지 방안이 있지만 대표적인 몇 가지를 소개하고자 한다.물론 암호화를 진행하고 이 방안까지 쓴다면 보안에 금상첨화이다. MAC 주소 인증MAC 주소는 컴퓨터 부품 중 하나인 LAN 카드에 있는 ‘고유’한 정보로서,IP 주소와 달리 LAN 카드를 바꾸지 않는한 영구적이다.또한 MAC 주소는 전 세계적으로 유일한 번호이므로 어찌 보면 ‘개인 정보’ 영역에도 속해서액티브 X 등등을 쓰지 않는 한 보안상 수집을 할 수 없다.이러한 MAC 주소의 ‘유일성’을 통해서 ‘인증된 MAC 주소’만 접속을 허용하게끔 하는 것이다.물론 MAC 주소를 바꾸는 방법이 존재하긴 하지만,인증된 MAC 주소를 알아내는 건 그리 쉬운 일이 아니다.또한 새로운 기기를 추가할 때마다 MAC 주소를 추가해야된다는 번거로움이 존재한다. SSID 숨기기.이 방법은 SSID 이름을 맞춰야만 해당 AP로 접속할 수 있게 하는 방법이다.사람들이 쉽게 생각할 수 없는 문자(특수문자)들의 조합으로SSID를 지정하면 쉽게 찾아낼 수가 없을 것이다. 공유기에 암호를 걸지 않는 것의 의미우리가 흔히 쓰는 무선 공유기는 송수신 하는 패킷(메시지, 데이터를 자잘하게 쪼갠 단위)을 기본적으로 암호화하지 않는다.잘 만들어진 사이트는 사이트 자체적(https 프로토콜 등등)으로 패킷을 암호화 하는 방법을 통해 보안을 유지하고 있다.하지만 우리가 사용하는 사이트가 모두 그렇게 잘 만들어진 사이트인가?보안에 그만큼 신경 쓴 사이트라면 비용이 비쌀테니 개인이나 소규모 기업 같은 경우에는크게 신경을 쓰지 않는 경우도 많다.잘 만들어진 사이트인지 일일이 확인하고 쓰기도 번거로울 뿐더러 알아내기도 쉽지 않다.즉 그러한 사이트를 이용하면 우리의 개인정보가고스란히 평문으로써 보이지 않는 공간에 날아다니게 된다.이러한 패킷들을 가로채는 건 해커들에겐 식은 죽 먹기다.흔히 생각하는 ‘무선 공유기 암호’는 ‘AP의 접근 인증’ 외에도&#39;송수신 패킷(데이터) 암호화&#39;도 포함돼있다.공짜라고, 비밀번호가 걸려있지 않다고, 옆 집에 있는 와이파이를 훔쳐쓰다가친구한테 몰래 보낸 메일이나 사이트의 비밀번호 등등이 크래커에게 고스란히 노출될 수 있다.옆 집 사람이 크래커라서 의도적으로 공개를 해놓은 건지도 모른다.공개 AP를 쓸 때는 보안에 민감하지 않은 작업만 하자. 공유기 암호화에 대한 다른 비밀암호화 방법이 여러 개 있고, 암호화 방법에 따라서 인터넷 속도도 천차 만별이다.출처는 아래 링크와 같다.iptime 암호화 방법에 따라 속도 차이가 엄청나군요.복잡한 알고리즘, 안전한 알고리즘일 수록 느리지 않을까…뭐 꼭 그렇다는 것만은 아니지만… 하지만 여러 가지의 암호화 방법 중 ‘안전하지 않은’ 암호화 방식도 있다.이 말은 암호화를 걸었는데 이미 크래커들에게 뚫린 방식일 수도 있다는 뜻이다.802.11N 방식(100메가 광랜)에서는 WPA2PSK + AES 방식을 쓰는 게 가장 좋을 것 같다.WiFi 공유기 암호방식, 꼭 WPA2-AES를 써야하는 이유는?802.11AC 방식(기가 광랜)에서는 어떤 방식이 제일 좋은지는 모르겠다.TKIP 방식의 암호화 알고리즘은 802.11N 방식을 지원하지 않는다는 것 같다.공유기 암호화방법 변경으로 무선/WIFI 속도 제대로 활용하기! 비밀번호를 걸지 않고, 송수신 데이터만 암호화 하는 방법이 존재하는지 모르겠지만,어지간하면 비밀번호가 걸려있지 않은 공개 AP는 쓰지 않는 게 좋고,꼭 써야한다면 보안에 민감하지 않은 작업만 하자.또한 소 잃고 외양간 고치기 싫은 사람들은 무선 공유기를 WPA2PSK + AES 방식의 암호화 방법을 적용시키거나… 속도를 포기하기 싫으신 분은 귀찮으시더라도 유선랜을 쓰도록 하자… 참조 링크 iptime 암호화 방법에 따라 속도 차이가 엄청나군요. WiFi 공유기 암호방식, 꼭 WPA2-AES를 써야하는 이유는? 공유기 암호화방법 변경으로 무선/WIFI 속도 제대로 활용하기!","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"http://perfectacle.github.io/tags/Computer/"},{"name":"인터넷","slug":"인터넷","permalink":"http://perfectacle.github.io/tags/인터넷/"},{"name":"속도","slug":"속도","permalink":"http://perfectacle.github.io/tags/속도/"},{"name":"암호","slug":"암호","permalink":"http://perfectacle.github.io/tags/암호/"},{"name":"보안","slug":"보안","permalink":"http://perfectacle.github.io/tags/보안/"}]},{"title":"(상식) 인터넷 속도에 대한 진실","slug":"giga-internet-fact","date":"2017-01-23T09:55:53.000Z","updated":"2017-08-03T08:31:35.000Z","comments":true,"path":"2017/01/23/giga-internet-fact/","link":"","permalink":"http://perfectacle.github.io/2017/01/23/giga-internet-fact/","excerpt":"","text":"이제는 100메가 광랜을 넘어서 기가의 시대가 열렸다.100메가 광랜을 쓸 적에 100 메가의 속도를 느껴본 적이 있는가?이론상 저항 등등에 의해 불가능하지만 그에 준하는 속도라도 느껴본 적 있는가?그럼 현재 기가에 조금 못 미치더라도 그에 준하는 속도를 느끼고 있는가?오늘은 그 진실과 상술과 마주해보자.결론부터 쉽게 풀어서 말하자면100메가 광랜의 이론상 최대 속도(나올 수가 없음)은 11.9메가이고,1기가 광랜의 이론상 최대 속도(이 또한 나올 수가 없음)은 119메가이다. b와 B사람들이 컴퓨터의 용량을 표기할 때 대소문자를 크게 여기지 않는다.물론 킬로를 뜻하는 k를 K로 적어도 kilo의 의미가 그대로 담겨있다.하지만 바이트를 뜻하는 B를 b로 적으면 bit의 뜻이 된다.일반인들은 잘 모르지만 그게 표준인지는 모르지만 표준과 같이 쓰이고 있다.인터넷 업체들은 b(it)라고 적으면서 사람들은 B(yte)로 받아들이는 것이다.8bit = 1Byte, 8배의 속도 차이가 나게 되는 것이다.1Gb/s = 1Gbps = 10³Mbps = 1000Mbps = 1000/8(MBps) = 125MBps = 125MB/s즉 1Gb/s는 125MB/s로 환산되어 우리가 피부로 느끼는 속도가 된다. iB와 B여기서 한 번 더 의구심을 품어야한다.1Gb/s = 1Gbps = 2¹⁰Mbps = 1024Mbps가 아니다.즉!1GB(1024MB)의 파일을 1Gb/s(125MBps)로는 8초만에 받을 수 없다는 사실이다!이 또한 상술이다.생각해보면 참 나쁜 놈들이다.2중 상술을 썼다.위 용량 관련된 글을 아래 링크를 참조하자.(상식) 컴퓨터 용량 단위에 대한 진실 b 단위 = bit 단위 = 1kb = 1kilobit = 125byte = 1000bit B 단위(SI 단위) = Byte 단위(10진 배수) = 1kB = 1kiloByte = 1000Byte = 8000bit iB 단위(IEC 이진 접두어) = Byte 단위(2진 배수) = 1KiB = 1KibiByte = 1024Byte = 8192bit 우리는 파일 용량에 있어서 B 단위를 쓰면서 iB라고 생각하고 실제로도 iB 단위이다.컴퓨터의 저장 장치는 B 단위를 쓰고 우리는 iB라고 생각하지만 실제로는 B 단위이다.인터넷 전송 속도는 b 단위를 쓰고 우리는 iB라고 생각하지만 실제 단위는 b이다.이게 참 혼동이 온다.즉 인터넷 업자들은 B 단위 대신에 b 단위를 써서 우리를 한 번 속였고,iB 단위도 쓰지 않아서 우리를 두 번 속인 꼴이 된다.따라서 100메가 광랜은 100Mbps = 12.5MBps ≒ 11.9MiBps1기가 광랜은 1Gbps = 125MBps ≒ 119MiBps가 된다.하지만 위의 상황도 이론상 최대 속도이지손실 없이 온전하게 전달하는 방법은 초전도체 뿐이지 않을까 싶지만…초전도체를 상온(20±5°C)에서 쓰는 방법은 없는 것으로 알고 있고,비용도 매우 비쌀 것이므로 사람들은 대부분 어느 정도 손실을 감수하고 사용하고 있다. 119MiB/s 인터넷의 속도를 방해하는 요소들아래 두 환경이 받춰주지 않는다면 119MiB/s의 가짜 기가 광랜 사용을 하고 싶어도 할 수 없다. ISP(Internet Service Provider)에서 깔아주는 망(케이블, 선)ISP는 그냥 LG U+, KT Olleh, SK Broadband 요런 애들이라고 보면 된다.요즘 인터넷이 무선으로 와이파이 통신을 한다고들 하지만 사실 완전한 무선은 아니다.ISP로부터 우리 집/사무실까지 유선으로 쭉~오게 된다.외국과 통신을 한다고 해서 예외가 아니다.태평양 심해 어딘가에는 광 케이블이 깔려있다.우선 ISP에서 쓰는 케이블이 초전도체가 아니기 때문에 1차적으로 속도 손실이 일어나지 않을까 싶다.또한 여러 유저가 동시에 몰리다 보면 100% 속도를 내기는 힘들지 않을까… 싶다.또한 아파트나 자신이 사는 동네에 기가 망 구축이 돼있어야 한다.요즘 같은 경우에 11.9MiB/s 광랜은 대부분 구축이 돼있는데,기가 망은 비용과 케이블이 두껍다보니 미관상의 이유로 깔리기를 반대하는 사람들이 있다.대표적으로 우리 아파트는 집 값 떨어진다고 못 깔고 있다고 한다… 에휴 ㅠㅠISP나 경비실에 문의해서 확실히 알아보고 신청해야 할 사항이다. 다운로드 속도는 괜찮은데 업로드 속도는…?혹은 그 반대인 경우가 있는데 이 경우들을 비대칭이라고 한다.지금은 잘 모르겠는데 과거에 주택 같은 경우에는 대칭형이었으나아파트가 주로 비대칭형이었다.대부분의 사람들이 동영상이나 파일을 받는 다운로드 속도에는 집착하지만인터넷 방송을 하는 스트리머의 경우나 대용량 파일을 메일로 보내는 등등의 행위에서는업로드 속도가 중요하다.하지만 대부분은 업로드 속도는 신경쓰지 않다보니 이것 또한 상술인지기술적 or 환경 문제인지 제대로 제공해주지 않는 ISP들이 있는 것으로 알고 있다.아니면 추가 과금을 통해서 개선이 된다거나…잘은 모르겠으나 직접 가입할 때 확인해야할 사항인 것 같다. 이제부터 나오는 네 가지 사항은 본인의 장비에 문제가 있는 경우이다.일단은 다운로드와 유선에 한해서 설명한다. 우리 집에 있는 랜선의 종류는?랜선은 랜선이지 무슨 또 종류가 있담?랜선에 따라서도 지원되는 속도가 있고, 가격도 다르다.물론 내구성과 안정성에 따라서도 달라지겠지만…UTP &gt; FTP &gt; STP 순으로 비싸지지만, (내구성/안정성 측면)일반 가정과 사무실에서는 가격을 이유로 UTP 케이블을 쓴다.아래 링크를 참조하자.랜선의 종류와 각종 개념정리이번에는 속도 측면에서 보자.출처는 아래와 같다.랜선의 종류와 구분 (UTP/STP/FTP 차이점)대역폭은 길이 좁냐 넓냐인데 이 또한 속도와도 관련이 있다고만 보면 된다.자신의 집이 아마 UTP 쓸테고, 그럼 CAT 어느 규격의 랜선을 쓰고 있는지를 알아야랜선을 새로 사야할지, 기가 광랜을 설치할지 말지를 결정할 수 있다. 내 컴퓨터의 랜카드 종류는?아니 랜카드가 랜카드지 또 종류가 있다고?구글링을 통해 내 랜카드가 1Gbps를 지원하는지 확인해야 한다.윈 7이나 10이나 비슷할테니 아래 링크를 참조하고, 리눅스나 맥은 따로 확인하길 바란다.기가랜을 사용하려면 랜카드 확인하고 설치하세요.만약에 본인의 컴퓨터에 장착된 랜카드가 기가 광랜을 지원하지 않는다면PCI-Express 슬롯에 장착할 수 있는 기가 랜카드를 사서 장착 후 그 곳에 랜선을 꽂거나USB 3.0용 랜카드를 사야한다.USB 2.0의 스펙상 쓰기 속도가 119MiB/s가 되지 않기 때문에 USB 3.0 용으로 사야한다.USB 3.0 미지원 메인보드면 PCI-Express용을 사거나 메인보드를 USB 3.0 지원용으로 바꾸자. 내가 파일을 저장하는 공간의 쓰기 속도는?이게 뭔소린지 모를 수도 있다.간단하게 CrystalDiskMark라는 프로그램을 써서내가 파일 저장하려는 공간의 읽기/쓰기 속도를 체크할 수 있다.대충 seq를 기준으로 잡으면 되지 않을까 싶다.다운로드는 아래 페이지를 이용하자.CrystalDiskMark즉, 내가 SSD에 저장할 때는 기가 광랜의 속도를 충분히 활용할 수 있는데,SD 카드나 USB, 외장 하드에 파일을 저장할 때는 기가 광랜의 속도가 안 날 수도 있다는 거다.기가 광랜 빵빵하게 이용하고 싶으면 쓰기 속도가 119MiB/s(125MB/s)를 넘는SSD나 USB 3.0 용량 큰 거 하나 장만하자. 우리집 공유기의 종류는?대부분이 집에 PC 한 대 이상은 있을 거다.그래서 IP 공유기/인터넷 공유기 하나 쯤은 대부분 있을 거다.근데 이 공유기가 자세히 보면 기가 광랜을 지원하지 않는 경우가 있다.판매처나 제조업체 홈페이지/메뉴얼에서 스펙을 보도록 하자.그리고 제대로 지원하지 않으면 그냥 하나 사자. 이제부터 나오는 가지 사항은 무선과 다운로드/업로드에 해당하는 내용이다. 우리집 무선 랜카드의 종류는?대부분의 휴대 기기(노트북, 태블릿, 스마트폰)에는 무선 랜카드가 내장돼있다.노트북은 유선 랜카드도 내장된 경우가 많고, 데스크탑에는 대부분 유선 랜카드만 내장돼있다.따라서 본인이 와이파이를 이용하는 경우에는 무선 랜카드를 쓴다고 보면 된다.본인 무선 랜카드가 기가 광랜의 속도를 지원하는지,지원하지 않는다면 데스크탑의 경우에는 PCI-Express나 USB 3.0,랩탑의 경우에는 USB 3.0 무선 랜카드 밖에 방법이 없을 것이다.스마트폰이나 태블릿의 경우에는 오히려 번거롭거나 비싸거나 존재 자체가 없지 않을까 싶다… 공유기와 내 컴퓨터 사이의 거리는? 장애물의 종류와 갯수는?여기서 말하는 컴퓨터는 와이파이를 사용하는 모든 기기를 총칭한다.무선의 경우에는 거리가 멀어지면 멀어질 수록 안정성이 떨어짐과 동시에 속도가 느려진다.기본적으로 유선은 거리에 제약이 없지만 무선은 거리에 제약이 존재하기도 하고,속도나 안정성 측면(자주 끊긴다거나 보안)에서도 구리다.또한 공유기와 컴퓨터 직선거리 사이에 장애물(대표적인 게 벽)이 많고 두껍고,투과하기 힘든 그런 물체일 수록 더 속도와 안정성 측면에서 안 좋아진다.신호 증폭기를 사용하거나 공유기를 중간에 하나 더 설치하거나 공유기 위치를 옮겨보자.공유기는 한 쪽 방향으로 신호를 쏘는 게 아니라 자신을 중심으로사방 팔방으로 신호를 쏴대는 것으로 알고 있다.따라서 공유기의 위치는 집의 정중앙이 제일 이상적이다. (케바케긴 하지만…) 공유기와 랜카드의 신호 세기는?공유기와 컴퓨터 사이가 그리 멀지도 않거나 장애물도 없는데 속도가 느리면애초에 공유기나 무선 랜카드가 안 좋아서 신호가 약한 경우이다.한 쪽이 뛰어나도 한 쪽이 받춰주지 못하면 제대로 된 속도가 나오지 않을 것이다.대표적으로 안테나가 여러 개 달려있는 등의 제품이 신호 세기가 강하다.하지만 이런 무선 신호가 너무 세면 신체에 악영향을 끼칠지도 모른다는 글을 본 것 같다. 공유기의 지원 접속 모드와 설정된 값은?무선 통신의 전송 방식 표준에는 B/G/N/AC 모드가 있다.각각에 대한 확인은 아래 링크에서 하자.IEEE 802.11 - 전송 방식 표준과거에는 N모드가 짱짱맨이었는데 기가 광랜이 나오면서 AC 모드를 지원해야 짱짱맨인 것 같다.공유기 설정에서도 AC 모드가 아닌 다른 모드로 설정돼있는지 봐보자. 이제부터 나오는 내용은 다운로드/업로드와 관련된 내용이다. 다운로드와 업로드를 동시에 하면…?대부분이 토렌트를 써봤을 거다.자신이 다운로드하면서 업로더도 되기도 한다.하지만 만약에 10MiB/s가 본인의 인터넷 최대 속도라고 해보자.10MiB/s로 다운로드 하다가 다른 사람이 다운로드 요청을 해서5MiB/s의 속도로 업로드 하면 동시에 5MiB/s로 다운로드 속도도 줄어든다.안 그런 컴퓨터나 네트워크 환경도 있겠지만 대부분이 이렇다.이는 업로드를 하다가 동시에 다운로드를 해도 마찬가지이다. 여러가지 파일을 동시에 다운로드 하면…?만약에 10MiB/s가 본인의 인터넷 최대 속도라고 해보자.A란 파일을 10MiB/s의 속도로 다운받고 있었다.B란 파일을 받으면 A란 파일의 다운로드 속도가 5MiB/s로 떨어지고B란 파일의 속도도 5MiB/s의 속도로 다운받게 된다.안 그런 컴퓨터나 네트워크 환경도 있겠지만 대부분이 이렇다.이는 업로드를 하다가 동시에 다른 파일이나 다른 유저에게 업로드를 해도 마찬가지이다. 우리 가족이나 룸메 중에 누가 인터넷으로 동영상을 본다면?만약에 10MiB/s가 본인의 인터넷 최대 속도라고 해보자.혹은 대용량 메일을 보낸다면?둘이 다른 네트워크(공유기, 모바일 네트워크)에 접속돼있으면 상관 없지만대부분 공유기는 1대일 것이고 공유기가 달라도 메인으로 쏴주는 ISP 제공 장비(모뎀 같은 놈)같은 게 같다면 무용지물이다.대부분의 공유기는 더미 허브이다.(뭐 몰라도 된다.)인터넷 속도를 1/N한다.1명만 쓰고 있을 때는 10MiB/s의 속도를 보장 받지만2명이 같이 쓴다면 각자 5MiB/s의 속도를 보장 받게 될 것이다. 파일을 다운로더에게 직접 쏴주는 경우/BJ가 방송하는 경우이 경우에는 본인의 업로드 속도도 중요하지만 상대방의 다운로드 속도도 중요하다.다운로드 속도는 위에 말했다 싶이 아주 다양한 요인에 따라 달라진다.메일이나 클라우드 서버에 올리는 경우가 아니라 1대1로 쏘는 경우가 이에 속한다.또한 BJ가 방송을 송출할 때는 업로드 속도도 중요하지만,방송을 보는 시청자의 다운로드 속도 또한 버퍼링의 큰 요인이다. 참조 링크 랜선의 종류와 각종 개념정리 랜선의 종류와 구분 (UTP/STP/FTP 차이점) 기가랜을 사용하려면 랜카드 확인하고 설치하세요. 기가 인터넷 시대, 궁금증 해결하자 IEEE 802.11","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"http://perfectacle.github.io/tags/Computer/"},{"name":"용량","slug":"용량","permalink":"http://perfectacle.github.io/tags/용량/"},{"name":"상식","slug":"상식","permalink":"http://perfectacle.github.io/tags/상식/"},{"name":"인터넷","slug":"인터넷","permalink":"http://perfectacle.github.io/tags/인터넷/"},{"name":"속도","slug":"속도","permalink":"http://perfectacle.github.io/tags/속도/"}]},{"title":"(상식) 컴퓨터 용량 단위에 대한 진실","slug":"Computer-capacity-fact","date":"2017-01-23T08:57:03.000Z","updated":"2017-08-03T08:31:35.000Z","comments":true,"path":"2017/01/23/Computer-capacity-fact/","link":"","permalink":"http://perfectacle.github.io/2017/01/23/Computer-capacity-fact/","excerpt":"","text":"이제 사람들이 IT에 많은 관심이 생겨서1TB 짜리 저장장치를 사도 온전히 1TiB가 아님을 알 수 있다.내가 여기서 TB와 TiB를 사용했는데, 이에 대해 알아보자. SI 단위프랑스어로 Système international d’unités현 과학계에서 사용하는 표준단위.표준화의 대표적인 성공사례이자 현재의 국제 과학계가 있을 수 있게 해 준 일등공신.컴퓨터 용량과 관련된 단위들만 살펴보자. 단위 이름 배수(10진법) 배수(2진법) Y yotta 1024 ≒280 Z zetta 1021 ≒270 E exa 1018 ≒260 P peta 1015 ≒250 T tera 1012 ≒240 G giga 109 ≒230 M mega 106 ≒220 k kilo 103 ≒210 위와 같이 SI 단위의 접두어는 과학계에서 사용하는 표준 단위이다.참고로 k는 온도를 나타내는 K와 헷갈린다고 소문자로 표기하였다.저장장치 제조 회사는 이를 저장장치의 용량을 표기하는데 사용했다.저장장치 제조 회사가 말하는 1kB = 103Byte = 1000Byte하지만 전기회로는 전압이 불안정해서 컴퓨터에서도 전압을 두 가지로만 나누었다.이게 컴퓨터가 0과 1로만 이루어진 까닭이다.이러한 탓에 컴퓨터는 1kB = 210Byte = 1024Byte로 인식한다.우리가 생각하는 1024Byte에서 24Byte의 오차가 생긴다.1000Byte ≒ 1024Byte1kB니까 24Byte의 차이 밖에 안 나는데, 1TB라면…?240 - 1012 = 99511627776(Byte) = 92.6774253845214844(GB)의 오차가 난다.물론 저장 장치에 따라 달라지기도 한다.내가 보기엔 이거 분명 상술이다.애초에 십진 표기법을 사용하는 SI 단위를 이진 표기법을 사용하는 컴퓨터에 사용하는 것 자체가 맞지 않았다.이진 표기법의 표준이 정해지기 전에 컴퓨터가 나와서 어쩔 수 없었을지도 모르기도 하지만… IEC 표준 접두어(IEC 60027-2)국제 전기 기술위원회(International Electrotechnical Commission, IEC)에서 정의한 이진 표준 접두어이다. 단위 이름 배수(10진법) 배수(2진법) Yi yobi 280 ≒1024 Zi zebi 270 ≒1021 Ei exbi 260 ≒1018 Pi pebi 250 ≒1015 Ti tebi 240 ≒1012 Gi gibi 230 ≒109 Mi mebi 220 ≒106 Ki kibi 210 ≒103 1KiB = 210Byte = 1024Byte로 우리가 생각하는 단위가 맞다. 그나마 다행인 것은 하드 디스크나 플래시 메모리(USB, SD 카드, SSD 등등)과는 달리RAM이나 CD(거의 쓰지 않게 됐지만…)는 SI 단위를 쓰면서 IEC 표준 접두어와 같은 결과를 낸다고 한다.쉽게 말해 RAM이나 CD는 상술을 쓰지 않는다는 뜻이다.아마 RAM의 경우에는 메모리 주소와 관련이 있지도 않을까… 싶다. 하지만 이름이 뭔가 이상하고 어색해서 많이들 쓰지 않는다.이러면 이럴 수록 그들의 상술에 놀아나기 때문에 조금이라도 써야겠다. 또한 이러한 상술은 인터넷 업체에서도 쓰고 있다.아래 링크를 참조하자.(상식) 인터넷 속도에 대한 진실 참조 링크 SI 단위 이진 접두어","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"http://perfectacle.github.io/tags/Computer/"},{"name":"용량","slug":"용량","permalink":"http://perfectacle.github.io/tags/용량/"},{"name":"상식","slug":"상식","permalink":"http://perfectacle.github.io/tags/상식/"}]},{"title":"(C/C++) 참고용 정리 - 변수와 리터럴, 그리고 메모리","slug":"C-ref-002","date":"2017-01-23T05:17:09.000Z","updated":"2017-08-03T18:12:53.000Z","comments":true,"path":"2017/01/23/C-ref-002/","link":"","permalink":"http://perfectacle.github.io/2017/01/23/C-ref-002/","excerpt":"","text":"변수변수라 함은 자바에서 정리했 듯이 아래와 같다. 짧게 얘기하면 변하는 수길게 얘기하면 단 하나의 값을 저장할 수 있는 메모리 상의 공간. 리터럴리터럴이라 함은 자바에서 정리했 듯이 아래와 같다. 짧게 얘기하면 변하지 않는 값 길게 얘기하면 우리는 변하지 않는 값을 일상생활에서는 상수라고 불렀다. 하지만 상수는 프로그래밍 세계에서는 좀 다른 뜻으로 불리기 때문에 그와 차별성을 부여하기 위해 리터럴이라고 붙였다. “ch”, ‘c’, 123, 123.55 등등 모두 리터럴이다. 내가 위에서 정의한 말들이 맞을까?좀 부족한 부분이 있는 것 같다.아래의 경우를 보자.1234567#include &lt;stdio.h&gt;int main() &#123; int num = 1 + 2; printf(\"%p\", &amp;num); num의 주소값이 나온다. return 0;&#125; num은 변수기 때문에 메모리를 4byte 잡아먹고 그 안에00000000 00000000 00000000 00000011이런 값이 들어있다.그럼 리터럴인 1과 2는 메모리 상에 적재되지 않는 걸까…?CPU에서 연산을 하기 위해서는 메모리 상에 있는 데이터들을 끌고 와야한다.메모리 상에 없는 데이터는 CPU에서 끌고 올 수가 없으니 연산 및 처리가 불가능하다.따라서 리터럴인 1과 2도 메모리 상에 올라가야한다는 것이다.이 1과 2도 메모리 상의 어딘가에 적재가 된다.그 어디가 어딘지는 아무도 모른다.(메인)메모리(RAM, Random Access Memory)의 특성상비어있는 공간 랜덤한 부분에 적재되지 않을까 싶다.정수 리터럴의 기본 크기는 모르지만 아마 4byte이지 않을까… 싶다.즉 1을 저장할 4byte 공간, 2를 저장할 4byte 공간이 따로 필요하게 된다.그리고 이러한 연산이 끝난 이후에는 가비지 컬렉팅 대상이 되어 소멸되게 되는 것이다.즉 리터럴도 메모리 상에 할당이 되고, 변수도 메모리 상에 할당이 된다.그럼 그 차이점을 아래의 표로 나타내보았다. 변수 리터럴 할당 형태 정적 할당 동적 할당 메모리 주소&nbsp;&nbsp;&nbsp;&nbsp; 알 수 있음(재호출 가능) 알 수 없음(재호출 불가) 가비지 컬렉팅 자세히 모르겠음 연산 되자마자 캐싱 메모리 주소에만 접근하면 되므로 캐싱을 함 매번 새로운 메모리 공간을 만들어야 하므로 캐싱하지 않음","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"C/C++","slug":"Note/C-C","permalink":"http://perfectacle.github.io/categories/Note/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"http://perfectacle.github.io/tags/Variable/"},{"name":"Literal","slug":"Literal","permalink":"http://perfectacle.github.io/tags/Literal/"},{"name":"Memory","slug":"Memory","permalink":"http://perfectacle.github.io/tags/Memory/"}]},{"title":"(C/C++) 참고용 정리 - 포인터와 배열","slug":"C-ref-001","date":"2017-01-23T02:00:21.000Z","updated":"2017-08-03T18:12:53.000Z","comments":true,"path":"2017/01/23/C-ref-001/","link":"","permalink":"http://perfectacle.github.io/2017/01/23/C-ref-001/","excerpt":"","text":"윤성우 님의 열혈 C 프로그래밍 동영상 강좌를 열심히 보고 있다.자바는 메모리 관리를 안 해도 된다지만 공부하면 할 수록 메모리에 자꾸만 관심이 갔다.그러한 갈증에 대한 해소를 C언어에서 할 수 있었다. 포인터메모리 주소의 값을 가지고 있는 변수이다.주된 용도는 특정 변수의 메모리 주소의 값을 가지고 있는 변수이지만,아래와 같은 것도 가능하다.123456789101112#include &lt;stdio.h&gt;int main() &#123; // 0x00000013이 어떤 영역인지 모른다. // 만약 OS영역이라면 치명적인 오류가 나고, 시스템이 뻗을 수도 있다. // 하지만 요즘 OS들은 다들 방어적으로들 행동한다고 한다. // 혹시 모르니 아래 코드는 권장하지 않는다. long* ptr = 0x00000013; // 에러를 뿜는 컴파일러도 있으니 권장하지 않음. *ptr = 13; return 0;&#125; 위와 같은 코드는 OS 영역을 건들지도 모르므로 매우 위험하다.따라서 아래와 같이 써야한다. 12345678910111213#include &lt;stdio.h&gt;int main() &#123; long num = 123; long* ptr = &amp;num; *ptr = 13; // %p의 크기는 운영체제의 bit에 따라, 값은 실행할 때마다 달라질 수 있다. // 핵심은 ptr에 저장된 값과 num의 메모리 번지수가 동일하다는 것이다. // 0x7fff588a2ad8 0x7fff588a2ad8 printf(\"%p %p\", &amp;num, ptr); return 0;&#125; 크기위에서 보듯이 포인터는 실수가 아닌 정수이다.하지만 그 크기가 1byte인지 2byte인지 어떻게 알 수 있을까?그 크기는 OS에 의존적이다.OS를 깔 때 32bit 버전, 64bit 버전의 컴퓨터를 본 적이 있다.32bit는 OS에서 한 번에 처리할 수 있는 데이터의 양은 32bit, 즉 4byte이다.왜냐하면 CPU가 처리하는 데이터의 최소 단위인 Register의 크기가 몇 bit인지에서 나오기 때문이다.또한 한 번에 이동시킬 수 있는 데이터의 양 또한 32bit라고 한다.데이터 버스를 이용하는 건지 뭔지는 잘 모르겠다.이는 메인 메모리(RAM, Random Access Memory)의 인식과도 관련이 있다.참고로 메인 메모리의 주소 체계는 1byte 단위이다.232Byte = 222Kilobyte = 212Megabyte = 22Gigabyte = 4GB 잠시 다른 이야기, 왜 32비트 컴퓨터를 x86이라고 부를까?통칭 x86계열의 CPU가 32비트까지 나와있고, 여기서 64비트를 지원하도록 확장된게 x86-64죠. 그래서 x86-64를 줄여서 간단히 x64…8080 - 8086 - 80186 - 80286 - 80386 - 80486 - 80586 등으로 나가는 인텔의 CPU를 통칭해서 x86이라고 부름 그렇다면 64bit의 경우에는 어떨까?64bit를 지원하는 CPU에 64bit의 OS가 깔린 경우라는 가정하에…CPU의 Register의 크기가 64bit라서 한 번에 연산(처리)할 수 있는 데이터의 양은 64bit, 즉 8byte.한 번에 이동시킬 수 있는 데이터의 양 또한 64bit.이론 상으로 인식할 수 있는 메인 메모리의 크기는264Byte = 254Kilobyte = 244Megabyte = 234Gigabyte = 224Terabyte= 214Petabyte = 24Exabyte = 16EB 참고로 말하자면 int의 크기 또한 OS의 bit에 의존적이지 않다!!같은 64bit지만 컴파일러에 따라서 int의 크기가 달라지기도 하는 것 같다.하지만 표준이나 요새 상황은 잘 모르겠다. 엄밀하게는 컴파일러에 따라 int 크기가 다르다…가 답일거 같군요. http://stackoverflow.com/questions/10197242/what-should-be-the-sizeofint-on-a-64-bit-machine Sang-Kyu Ahn님 C99 표준에 따르면 sizeof(char)=1이란 것만 정해져 있고, char는 최소 8비트 라는 것이 정해져 있습니다(limits.h를 통해). 그 다음부터는 상대적인 크기로만 되어 있죠. 보통은 그래서 char가 8비트이지만, 16비트 char를 쓴다고 해서 표준 위반은 아니죠. short는 마찬가지 방식으로 16비트 이상이면 되고, int는 기계가 다루는 가장 자연스러운(?) 크기(보통은 CPU레지스터나 데이터 버스 크기에 따르겠죠)면서 최소 16비트, long은 int보다 크거나 같은 크기이면서 32비트, long long은 long보다 크거나 같으면서 최소 64비트… 따라서 64비트 머신이라면 64비트 char, short, int, long, long long 도 표준 위반이 아닙니다. Hyunsok Oh님 이미지와 소스 코드의 출처는 32bit와 64bit의 C 자료형(Data Type) 크기 차이이다.1234567891011121314151617181920#include&lt;stdio.h&gt;int main() &#123; printf (\"\\n-- General Data Type Size --\\n\"); printf (\"char size : %d byte\\n\", (int)sizeof(char)); printf (\"short size : %d byte\\n\", (int)sizeof(short)); printf (\"int size : %d byte\\n\", (int)sizeof(int)); printf (\"long size : %d byte\\n\", (int)sizeof(long)); printf (\"double size : %d byte\\n\", (int)sizeof(double)); printf (\"long double size : %d byte\\n\", (int)sizeof(long double)); printf (\"\\n-- Pointer Data Type Size -- \\n\"); printf (\"char* size : %d byte\\n\", (int)sizeof(char*)); printf (\"short* size : %d byte\\n\", (int)sizeof(short*)); printf (\"int* size : %d byte\\n\", (int)sizeof(int*)); printf (\"long* size : %d byte\\n\", (int)sizeof(long*)); printf (\"double* size : %d byte\\n\", (int)sizeof(double*)); printf (\"long double* size : %d byte\\n\", (int)sizeof(long double*)); return 0;&#125; 포인터 변수 타입에 대한 이해32bit에서는 포인터 변수의 크기가 4byte, 64bit에서는 포인터 변수의 크기가 8byte다.포인터의 크기는 OS에 의존적인데 그럼 그 변수의 타입도 OS에 의존적인 타입만 써야하지 않을까…? NO!!32bit OS에서 놓고 포인터 변수의 크기도 4byte, long의 크기도 4byte이다.64bit OS에서 놓고 포인터 변수의 크기도 8byte, long의 크기도 8byte이다.따라서 포인터 변수의 타입은 무조건 long이면 될 것 같다.그런데 왜 char, short, int, float, double* 요런 놈이 존재하는 걸까…?그건 포인터를 쓰는 근본적인 목적인 메모리 주소에 대한 접근 때문이다.1234567891011121314#include &lt;stdio.h&gt;int main() &#123; double num = 123.2; // 컴파일 되지않는 컴파일러도 있지만, 메모리 주소인 정수값을 long에 담는 것이니 상관이 없다고 여긴다. long ptr = &amp;num; // 해당 주소로 접근해서 그 주소에 있는 값을 바꾸려고 한다. // 하지만 ptr이란 놈은 num의 주소만 알고있을 뿐이지 어떤 타입인지 알지 못한다. // 메모리에는 0과 1의 값만 잔뜩 들어가있는데 그러한 정보를 알 수 없다. // 따라서 에러가 나거나 원하는 결과가 나오지 않을 것이다. *ptr = 13.4; return 0;&#125; 위의 예제에서 알 수 있듯이 메모리 주소만으로는 해당 메모리 주소가 가리키는 공간이 어떠한 타입인지즉 몇 byte를 조작해야 내가 원하는 결과가 나올지, 문자일지 숫자일지 등등을 판단하기 힘들다.즉 포인터의 타입은 포인터가 가리키는 곳의 타입을 알고 있는 것이지,포인터의 크기를 알고 있는 아이가 아니다.포인터의 크기는 신경쓸 필요도 없고 컴파일러가 알아서 처리하는 것 같다.포인터 변수의 데이터 타입이 달라도 컴파일이 되는 경우도 있지만 추천하지 않는다.12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; // int형 1은 // 00000000 00000000 00000000 00000001 int num = 1; // int*이 아니지만 컴파일 되는 컴파일러도 있다. // short*이라고 선언했기 때문에 2byte라고 인식한다. short* ptr = &amp;num; // short형 2는 // 00000000 00000010 *ptr = 2; // 따라서 num은 아래와 같이 바뀌어있다. // 00000000 00000010 00000000 00000001 // 정수로 131073 // 컴파일이 되는 경우도 있지만 올바른 값이 나오지 않으므로 권장하지 않는다. return 0;&#125; 배열배열은 연속된 메모리 공간에 할당하는 것을 뜻한다.연속해서 메모리 공간에 할당하는 이유는 두가지가 아닐까 싶다. 중간 중간 이빨이 나가지 않아 메모리 단편화가 안 일어나지 않을까? 반복문 측면에서 주소값+배열 타입만 하면 되기 때문이지 않을까?또한 변수를 하나만 선언해도 된다는 장점이 존재한다. 그리고 배열의 이름도 포인터이다.하지만 포인터와의 차이점이라면 포인터 상수라는 점이다.12345678910111213141516#include &lt;stdio.h&gt;int main() &#123; int num[] = &#123;1, 2, 3&#125;; // 0x7fff58f16acc 0x7fff58f16acc // &amp;연산자를 붙이지도 않았는데 변수의 이름이 주소값을 가리킨다. // 즉 배열의 이름은 배열의 첫번째 요소의 주소값(포인터)와 같다. printf(\"%p %p\", num, &amp;num[0]); // 포인터이기 때문에 메모리 주소로 접근이 가능하다. *num = 3; printf(\"%d %d %d\", *num, *&amp;num[0], num[0]); // 하지만 포인터 상수이기 때문에 컴파일 에러가 난다. num = &amp;num[2]; return 0;&#125; C언어에서 배열의 이름은 포인터 상수라고 했기 때문에 아래와 같은 게 불가능하다.123456789101112#include &lt;stdio.h&gt;int main() &#123; int num[2]; // 배열의 이름은 포인터 상수라서 컴파일 에러. num = &#123;1, 3&#125;; // 따라서 아래와 같이 해줘야하는데 매우 귀찮아지므로 선언과 동시에 초기화해주는 것이 좋다. num[0] = 1; num[1] = 3; return 0;&#125; 포인터의 덧셈, 뺄셈, 증감 연산자(+, -, ++, –)포인터에서 포인터 ± n은 다음과 같은 의미를 가진다.주소값 ± n * sizeof(포인터 변수 타입)123456789101112131415161718#include &lt;stdio.h&gt;int main() &#123; int num = 123; int* ptr = &amp;num; // 0x7fff5fb37adc printf(\"%p\\n\", ptr); // 0x7fff5fb37adc + sizeof(int) // 0x7fff5fb37adc + 4 // 즉, 0x7fff5fb37ae0 ptr += 1; printf(\"%p\\n\", ptr); // 0x7fff5fb37ae0 + 4 // 즉, 0x7fff5fb37ae4 printf(\"%p\\n\", ++ptr); return 0;&#125; 배열의 이름 또한 상수이지만 일단은 포인터이기 때문에 덧셈, 뺄셈 연산자를 사용할 수 있다.12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main() &#123; int num[] = &#123;1, 3, 5&#125;; // c언어에서는 배열의 length를 구하는 api가 없다. int length = sizeof(num) / sizeof(int); // 배열의 이름이 포인터이기 때문에 &amp;를 안 붙여도 됨. int* ptr = num; for(int i=0; i&lt;length;) printf(\"%d \", num[i++]); // 1 3 5 printf(\"\\n\"); // 배열의 이름은 포인터이기 때문에 *를 붙여줘야 함. // 또한 덧셈 연산자나 증감 연산자 보다 * 연산자의 우선순위가 더 높아서 괄호로 우선순위를 명시해줘야 함. for(int i=0; i&lt;length;) printf(\"%d \", *(num + (i++))); // 1 3 5 printf(\"\\n\"); for(int i=0; i&lt;length;) printf(\"%d \", *(ptr + (i++))); // 1 3 5 printf(\"\\n\"); // 배열의 이름은 포인터 상수이기 때문에 아래와 같은 것이 불가능하다. for(int i=0; i++&lt;length;) printf(\"%d \", *(num++)); // ptr은 포인터 변수이기 때문에 아래와 같은 것이 가능하다. for(int i=0; i++&lt;length;) printf(\"%d \", *(ptr++)); // 1 3 5 printf(\"\\n\"); num[0] = 5; *(num+1) = 3; // num[1]과 동일함, 괄호 빼면 안 된다. *(--ptr) = 1; // ptr++를 3번 해줘서 ptr+3이 되었으므로 배열의 범위를 벗어났으니 한 번 빼줘야 함. for(int i=0; i&lt;length;) printf(\"%d \", *(num + (i++))); // 5 3 1 return 0;&#125; 참조 링크 Windows 환경에서 32 bit 와 64 bit 왜 32비트 환경을 x86이라고 하는걸까요? 32bit와 64bit의 C 자료형(Data Type) 크기 차이 32bit 자료형 / 64bit 자료형의 크기 정리 64bit 머신에서 int형이 64bit가 아닌가요? long과 int는 크기가 같은데 왜 존재하나요?","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"C/C++","slug":"Note/C-C","permalink":"http://perfectacle.github.io/categories/Note/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"Pointer","slug":"Pointer","permalink":"http://perfectacle.github.io/tags/Pointer/"},{"name":"Address","slug":"Address","permalink":"http://perfectacle.github.io/tags/Address/"},{"name":"Array","slug":"Array","permalink":"http://perfectacle.github.io/tags/Array/"}]},{"title":"(ES6) ajax 위주의 promise 실습","slug":"ES6-Promise-with-ajax","date":"2017-01-20T16:09:50.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2017/01/21/ES6-Promise-with-ajax/","link":"","permalink":"http://perfectacle.github.io/2017/01/21/ES6-Promise-with-ajax/","excerpt":"","text":"들어가기에 앞서집중력을 위해 짧은 글을 지향하여 Promise 문법을 설명하지는 않았다.간단히 jQuery를 사용해본 사람이라면 쉽게 이해할 수 있을 것이다.내가 찾아본 대부분의 Promise 관련 예제가 setTimeout 위주여서ajax 위주의 예제를 한 번 정리해보았다. 비동기 코드를 동기식으로 작성하면?123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const jsonURL = [ \"https://perfectacle.github.io/mock/test.json\", \"https://perfectacle.github.io/mock/test2.json\"];const getDataAjax = url =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(\"get\", url, true); xhr.responseType = \"json\"; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful for(let key in xhr.response) &#123; // 받아온 json 데이터의 키와 값의 쌍을 모두 출력. if(xhr.response.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;xhr.response[key]&#125;`); &#125; &#125; else &#123; // 통신 상에 오류가 있었다면 오류 코드를 출력. console.error(`http status code: $&#123;xhr.status&#125;`); &#125; &#125; &#125;; xhr.send();&#125;;// 콘솔창을 키고 새로고침을 10번 정도 해보자.// 콘솔창에 계속해서 동일한 결과가 출력되는가??// 비동기 작업이기 때문에 순서를 보장하기 힘들다.// 원래는 아래와 같이 나와야한다.// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: higetDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]); 비동기 코드를 비동기식(콜백 함수)으로 작성하면? (ES5)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const jsonURL = [ \"https://perfectacle.github.io/mock/test.json\", \"https://perfectacle.github.io/mock/test2.json\"];// 따라서 아래와 같이 콜백 함수를 이용하여야 한다...const getDataAjaxCallback = (url, res, rej) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(\"get\", url, true); xhr.responseType = \"json\"; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful res(xhr.response); // 성공했을 시 실행할 콜백 함수. &#125; else &#123; rej(xhr.status); // 실패했을 시 실행할 콜백 함수. &#125; &#125; &#125;; xhr.send();&#125;;// 성공과 에러 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; if(data.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;const rej = err =&gt; console.error(`http status code: $&#123;err&#125;`);// 새로고침 10번을 해보고도 아래와 같은 순서로 나오는지 확인해보자.// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: hi// 함수 안에 매개변수로 콜백함수가 들어가있다.getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err))&#125;, err =&gt; rej(err)); 비동기식 코드의 순서를 아름답게 보장하려면…? (ES6)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const jsonURL = [ \"https://perfectacle.github.io/mock/test.json\", \"https://perfectacle.github.io/mock/test2.json\"];// 위 코드를 보면 가독성이 매우매우매우 안 좋다.// 이를 위해 등장한 것이 promise.// promise에 파라미터를 넘겨주기 위해선 밖에서 함수로 한 번 래핑해줘야 함.const getDataAjaxPromise = url =&gt; ( // thenable하게 하기 위해 Promise 인스턴스를 리턴. new Promise((res, rej) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(\"get\", url, true); xhr.responseType = \"json\"; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful res(xhr.response); // 성공했을 시 실행할 콜백 함수. &#125; else &#123; rej(xhr.status); // 실패했을 시 실행할 콜백 함수. &#125; &#125; &#125;; xhr.send(); &#125;));// 성공 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;// 코드가 한결 우아해지지 않았는가?// 새로고침 10번을 해보고도 아래와 같은 순서로 나오는지 확인해보자.// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: higetDataAjaxPromise(jsonURL[0]).then(data =&gt; &#123; res(data); // promise 인스턴스에 파라미터를 넘기기 위해선 다시 함수를 호출해야하고, // thenable 하게 만들어야하기 때문에 함수의 반환값(프라미스 인스턴스)을 리턴해줘야함. return getDataAjaxPromise(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;)// 더 이상 비동기로 처리할 내용이 없으므로 return문은 필요 없어짐..then(data =&gt; res(data)).catch(err =&gt; console.error(`http status code: $&#123;err&#125;`)); 마치며콜백 함수를 Promise로 바꾸긴 했지만 그래도 좀 번거로운 건 어쩔 수 없을까…?그에 대한 해답이라고 하긴 뭐하지만(ES6+) ajax를 위한 fetch와 async/await에서 해결방안을 보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"ajax","slug":"ajax","permalink":"http://perfectacle.github.io/tags/ajax/"},{"name":"promise","slug":"promise","permalink":"http://perfectacle.github.io/tags/promise/"}]},{"title":"(Java) 자바의 정석 3판 005일차 - 반복문(for, while, do-while), continue와 break","slug":"Java-study-005day","date":"2017-01-20T06:31:25.000Z","updated":"2017-08-04T04:30:47.000Z","comments":true,"path":"2017/01/20/Java-study-005day/","link":"","permalink":"http://perfectacle.github.io/2017/01/20/Java-study-005day/","excerpt":"","text":"반복문for문12345678910111213141516171819202122232425public class test2 &#123; public static void main(String[] args) &#123; System.out.println(\"i \\t i % 3 \\t i / 3\"); for(int i=0; i&lt;12;) System.out.printf(\"%d \\t %d \\t %d%n\", i, i%3, i++/3); /* i % n에서 % 연산자는 n개의 숫자가 연속적으로 순환하면서 나오고 i / n에서 / 연산자는 동일한 숫자가 n번 연속해서 나온다. 알고리즘 어딘가 쓰일지 모르니 기억해두자. i i % 3 i / 3 0 0 0 1 1 0 2 2 0 3 0 1 4 1 1 5 2 1 6 0 2 7 1 2 8 2 2 9 0 3 10 1 3 11 2 3 */ &#125;&#125; 향상된 for문배열이나 컬렉션을 순회할 때만 사용할 수 있다.es6의 for of와 유사하다.1234567const nums = [1, 2, 3];/* 1 2 3 */for(const num of nums) console.log(num); 1234567891011public class test2 &#123; public static void main(String[] args) &#123; int nums[] = &#123;4, 5, 6&#125;; /* 4 5 6 */ for(int num : nums) System.out.println(num); &#125;&#125; while문for문과 while문은 항상 변환이 가능하다.for는 반복할 횟수에 포커스를, while은 조건에 포커스를 뒀다. 연습문제 오답 char 범위 구하기자꾸만 아스키 코드의 함정에 갇혀있다.오답은 아닌데 어차피 int로 변환되므로 굳이 아스키코드로 대조하지 않아도숫자인지 영어인지 비교가 가능했다.ch &gt; 47 &amp;&amp; ch &lt; 58가 아니라&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;=&#39;9&#39;(ch &gt; 64 &amp;&amp; ch &lt; 91) || ( ch &gt; 96 &amp;&amp; ch &lt; 123)가 아니라(&#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;) || (&#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;) boolean형 변수 powerOn가 false일 때 true인 조건식한 가지 경우밖에 떠올리지 못했다. !powerOn powerOn == false powerOn != true 정수, 음수 교차 합산 문제또 한번 나의 머리를 강타한 문제다.내가 굉장히 편협한 사고 방식을 가지고 있는 게 아닐까 하는 생각이 들었다.정답을 살짝 보고 나와 다른 것 같아서 아무리 생각해봤지만…저자의 발끝만치도 따라오지 못했다.정말 반성해야겠다.&nbsp;1+(-2)+3+(-4)+… 과 같은 식으로 계속 더해나갔을 때, 몇까지 더해야 총합이 100이상이 되는지 구하시오.&nbsp;내가 생각한 답안 1234567891011public class test2 &#123; public static void main(String[] args) &#123; int i=1, sum=0; while(sum &lt; 100) &#123; sum += i; i = i&gt;0 ? -(++i) : -(--i); &#125; i = i&gt;0 ? i : -i; System.out.printf(\"sum: %d, i: %d\", sum, --i); &#125;&#125; 저자가 제시한 답안s라는 부호 변수를 놓고, 토글시키면서 쓸 줄은 전혀 몰랐다…12345678910public class test2 &#123; public static void main(String[] args) &#123; int i = 0, s = 1, sum = 0; while(sum &lt; 100) &#123; sum += ++i * s; s = -s; &#125; System.out.printf(\"sum: %d, i: %d\", sum, i); &#125;&#125; 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수필요없는 sum을 선언했었다.다른 곳에서 쓰지 않는 변수는 따로 캐싱을 하지 않아도 된다. 1234567public class test2 &#123; public static void main(String[] args) &#123; for(int i=0; ++i&lt;6;) for(int j=0; ++j&lt;6;) if(i+j == 6) System.out.printf(\"i: %d, j: %d%n\", i, j); &#125;&#125; 정수형 변수에 랜덤한 값 담기. 12// 형변환을 꼭 해줘야하고, + 이전까지가 실수이므로 랩핑은 거까지만 해주면 됨.int rnd = (int)(Math.random() * 6) + 1; 문자를 정수로 바꾸기.parseInt가 만능이 아니었다. 123char ch = '4';int num = Integer.parseInt(\"\" + ch);int num2 = ch - '0'; // - 연산에 의해 int로 둘 다 형변환 되서 연산이 진행됨. 정수의 각 자릿수 구하기.문자열이면 정수로 바꾸고 진행하는 게 맘 편하다. 12345678910public class test &#123; public static void main(String[] args)&#123; int num = 12345; while(num &gt; 0) &#123; // 이 놈의 조건이 참 유용하다. 괜히 for로 해서 변수 선언할 필요 없다. System.out.println(num % 10); num /= 10; // 결국 마지막엔 10 이하의 값을 나누게 되므로 0이 된다. &#125; &#125;&#125; continue와 break이중 반복문이 있을 때 반복문에 이름을 붙이고, continue와 break 뒤에 반복문의 이름을 붙이면 해당 반복문을 탈출한다.123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; /*00 01 10 11*/ outer: for(int i=0; i&lt;2; i++) &#123; for(int j=0; j&lt;4; j++) &#123; if(j == 2) &#123; continue outer; &#125; System.out.print(i); System.out.println(j); &#125; &#125; &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"반복문","slug":"반복문","permalink":"http://perfectacle.github.io/tags/반복문/"}]},{"title":"(ASM) 참고용 정리 - 기계어와 ASM, 고급 언어의 관계","slug":"ASM-ref-001","date":"2017-01-05T18:06:13.000Z","updated":"2017-02-13T04:46:22.000Z","comments":true,"path":"2017/01/06/ASM-ref-001/","link":"","permalink":"http://perfectacle.github.io/2017/01/06/ASM-ref-001/","excerpt":"","text":"가상 기계(Virtual Machine)기계를 추상화한 것.소프트웨어일 수도, 하드웨어일 수도 있다.각각의 가상 기계는 대응되는 언어들이 존재한다.아래의 표에서 레벨에 해당하는 것들이 가상 기계이다. Level Language High-Level Language Java, C, etc. Assembly Language x86 ASM, 65c816 ASM, etc. Instruction Set Architecture(ISA) Machine Code Digital Logic ??? 어셈블리어(Low-Level Language)기계어고급 언어로 만들던, 저급 언어(ASM)으로 만들던 어차피 기계어로 바뀌어 실행되게 된다.즉 프로그래머는 무엇을 만들던 간에 사실 위와 같이 코딩하는 것이다.컴퓨터는 0과 1로 이루어진 전자 계산기이기 때문에 사실 0과 1만으로 이루어진기계어만으로 코딩이 가능하다는 사실이다.단, 가독성이 매우 안 좋아서 시간이 엄청 걸린다는 단점이 존재한다.이러한 단점을 보완하고자 기계어와 1:1로 매칭되는 어셈블리어를 만들고,그 어셈블리어를 기계어로 해석해주는 가상 기계를 만들게 된 것이다.하지만 특정 프로세서에 의존적이기 때문에 이식성이 없다. 고급 언어(High-Level Language)컴퓨터의 성능이 비약적으로 발전함에 따라 단순한 어플리케이션이 아니라방대한 규모의 어플리케이션들을 개발하기 시작했다.하지만 기계어와 1:1로 매칭되는 어셈블리어로 개발하기에는시간과 유지보수 측면에서 너무나 많은 제약이 존재하였다.이러한 단점을 보완하고자 어셈블리어를 좀 더 추상화 시킨 고급 언어가 등장하게 된다.고급 언어는 어셈블리어와 일대다 관계를 가지고,이는 기계어와도 일대다 관계를 가진다는 것을 뜻한다.아래 예시를 통해 무슨 말인지 이해하자.12int Y;int X = (Y + 4) * 3; 고급 언어로는 딱 2줄에 불과한 코드이다.이 코드가 기계어와 1대1로 매칭되는 어셈블리어로 변환시켜 보자.12345mov eax, Y ; move Y to the EAX registeradd eax, 4 ; add 4 to the EAX registermov ebx, 3 ; move 3 to the EBX registerimul ebx ; multiply EAX by EBXmov X, eax ; move EAX to X 위와 같이 단 2줄의 고급 언어 코드는 5줄의 어셈블리어와 매칭이 되는 걸 볼 수 있다. 어셈블리어는 왜 쓸까?누가 요새 저렇게 무식(?)한 문법으로 코딩을 하냐고 비아냥 할 수 있다.생산성이 무지 낮은 건 사실이다.하지만 고급 언어에서 불가능한 것이 있다.바로 하드웨어의 직접 접근을 제공하지 않는 경우가 많다.하드웨어, 장치 드라이버, 펌웨어 등등을 개발할 때하드웨어로 직접 접근하지 못한다는 것은 매우 치명적이다.또한 메모리를 매우 경제적으로 사용하기 때문에소량의 메모리를 가지고 있는 전화기, 냉장고 등등의임베디드 프로그램을 작성할 때 제격이다. 장치 드라이버일반적인 운영체제 명령어에 대응하는 구체적인 하드웨어 동작으로 변환하는 프로그램.똑같은 장치라 하더라도 운영체제에 따라서 다른 장치 드라이버를 개발해야한다. 저는 임베디드나 하드웨어 쪽 개발을 안 할건데요?어셈블리어를 배우면 하드웨어, 운영체제, 응용 프로그램 간의상호 작용을 전체적으로 이해하는데 큰 도움을 준다.지금 당장은 어렵고 지루하더라도 훗날에 큰 도움이 되리라 믿고 있다. 각 가상 기계별 언어 호환 방법?기계어의 상위 언어(저급, 고급 언어)들은 L1이라고 칭하겠다. 해독(Interpretation) - 인터프리터??L1 프로그램이 실행됨에 따라 L1의 각 명령어는기계어로 작성된 프로그램에 의해서 해독(decode)되기 때문에실행이 가능해진다.L1 프로그램은 즉시 실행되기 시작하지만각 명령어는 먼저 해동되어야 실행될 수 있다. 변환(Translation) - 컴파일??L1 프로그램 전체가 특별히 설계된 기계어 프로그램에 의해기계어 프로그램으로 변환된다.그 후 변환된 기계어 프로그램은 컴퓨터 하드웨어에서 직접 실행될 수 있다. 어셈블러, 링커, 디버거 어셈블러 (Assembler)어셈블리 언어로 작성된 소스 코드를 기계어로 변환하는 유틸리티 프로그램 링커 (Linker)어셈블러가 생성한 각각의 파일들을 하나의 실행 파일로 합치는 유틸리티 프로그램 디버거 (Debugger)프로그램이 실행되는 동안 프로그램을 단계적으로 실행하고,레지스터와 메모리를 살펴보는 유틸리티 프로그램 javap를 이용해서 자바 클래스를 역어셈블(Deassemble)해보자.Javap 란? (자바 역어셈블러)역어셈블은 바이트 코드로 변환된 class 파일을원본인 고급 언어(java)로 역컴파일(Decompile) 하는 게 아니라클래스 파일 내부의 기본 구조와 역어셈블 코드(JVM의 바이너리 코드)만 나오게 된다.클래스 내부의 상수와 함수들의 목록을 볼 때 유용하게 쓰인단다. 123456public class test2 &#123; public static void main(String[] args) &#123; int Y = 6; int X = (Y + 4) * 3; &#125;&#125; 12345678910javap -c test20: bipush 6 // 6을 push??2: istore_1 // 1번 레지스터에 저장3: iload_1 // 1번 레지스터를 로드4: iconst_4 // 상수 45: iadd // 로드한 값(1번 레지스터와 상수 4)을 덧셈한 값을 1번 레지스터에 저장.6: iconst_3 // 상수 37: imul // 로드한 값(1번 레지스터와 상수 3)을 곱한 값을 1번 레지스터에 저장.8: istore_2 // 로드한 값(1번 레지스터)를 2번 레지스터에 저장.9: return // 함수 종료 진수 변환하기이는 프로그래밍 언어마다 대체적으로 내장된 라이브러리들이 있다.하지만 진수를 손으로 변환하는 알고리즘을 그대로 옮긴다고 생각하고,즉 내장된 라이브러리를 직접 구현한다는 생각으로 코딩을 해보았다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class test &#123; // Integer.toParseInt(String int, int radix)를 구현(radix는 2로 고정) // 2진수 문자열을 10진수 정수로 반환. int binToDec(String bin) &#123; int decimal = 0; int bitIdx; for(int i=0; i&lt;bin.length(); i++) &#123; // 비트 별로 하나씩 뽑아서 문자를 정수로 변경. bitIdx = Integer.parseInt(bin.substring(i, i+1)); // 2^n-1-i * bitIdx; if(bitIdx != 0) decimal += Math.pow(2, bin.length()-1-i) * bitIdx; &#125; return decimal; &#125; // Integer.toParseInt(String hex, int radix)를 구현(radix는 16으로 고정) // 16진수 문자열을 10진수 정수로 반환. static int hexToDec(String hex) &#123; int decimal = 0; int bitIdx; for(int i=0; i&lt;hex.length(); i++) &#123; // 비트 별로 하나씩 뽑아서 문자를 정수로 변경. switch (hex.substring(i, i+1)) &#123; case \"A\": case \"a\": bitIdx = 10; break; case \"B\": case \"b\": bitIdx = 11; break; case \"C\": case \"c\": bitIdx = 12; break; case \"D\": case \"d\": bitIdx = 13; break; case \"E\": case \"e\": bitIdx = 14; break; case \"F\": case \"f\": bitIdx = 15; break; default: bitIdx = Integer.parseInt(hex.substring(i, i+1)); &#125; // 16^n-1-i * bitIdx; if(bitIdx != 0) decimal += Math.pow(16, hex.length()-1-i) * bitIdx; &#125; return decimal; &#125; // Integer.toBinaryString(int dec)를 구현. // 10진수 정수를 2진수 문자열로 반환. String decToBin(int dec) &#123; int quot = dec; String rest = \"\"; while(quot &gt; 1) &#123; rest = quot % 2 + rest; quot = quot / 2; &#125; return quot + rest; &#125; // Integer.toHexString(int dec)를 구현. // 10진수 정수를 16진수 문자열로 반환. String decToHex(int dec) &#123; int quot = dec; String rest = \"\"; while(quot &gt; 15) &#123; switch (quot % 16) &#123; case 10: rest = \"A\" + rest; break; case 11: rest = \"B\" + rest; break; case 12: rest = \"C\" + rest; break; case 13: rest = \"D\" + rest; break; case 14: rest = \"E\" + rest; break; case 15: rest = \"F\" + rest; break; default: rest = quot % 16 + rest; &#125; quot = quot / 16; &#125; switch (quot) &#123; case 10: return \"A\" + rest; case 11: return \"B\" + rest; case 12: return \"C\" + rest; case 13: return \"D\" + rest; case 14: return \"E\" + rest; case 15: return \"F\" + rest; default: return quot + rest; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ASM","slug":"Programming/ASM","permalink":"http://perfectacle.github.io/categories/Programming/ASM/"}],"tags":[{"name":"ASM","slug":"ASM","permalink":"http://perfectacle.github.io/tags/ASM/"},{"name":"Assembly","slug":"Assembly","permalink":"http://perfectacle.github.io/tags/Assembly/"}]},{"title":"(C++) 참고용 정리 - 변수의 주소","slug":"Cpp-ref-001","date":"2017-01-02T00:59:21.000Z","updated":"2017-08-03T18:12:53.000Z","comments":true,"path":"2017/01/02/Cpp-ref-001/","link":"","permalink":"http://perfectacle.github.io/2017/01/02/Cpp-ref-001/","excerpt":"","text":"12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int num2 = 11; int num = 11; int num3 = num; // 같은 값이던 변수를 참조하던 다른 메모리 공간을 차지함. cout &lt;&lt; &amp;num2 &lt;&lt; endl; // 0x7FFF5322DAD8 cout &lt;&lt; &amp;num &lt;&lt; endl; // 0x7FFF5322DAD4 cout &lt;&lt; &amp;num3 &lt;&lt; endl; // 0x7FFF5322DAD0 return 0;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"C/C++","slug":"Note/C-C","permalink":"http://perfectacle.github.io/categories/Note/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"http://perfectacle.github.io/tags/C/"},{"name":"Pointer","slug":"Pointer","permalink":"http://perfectacle.github.io/tags/Pointer/"},{"name":"Address","slug":"Address","permalink":"http://perfectacle.github.io/tags/Address/"}]},{"title":"(Java) 자바의 정석 3판 004일차 - 연산자(우선 순위 및 결합 규칙), switch 문","slug":"Java-study-004day","date":"2017-01-01T23:05:49.000Z","updated":"2017-08-04T04:30:47.000Z","comments":true,"path":"2017/01/02/Java-study-004day/","link":"","permalink":"http://perfectacle.github.io/2017/01/02/Java-study-004day/","excerpt":"","text":"연산자 우선순위x &lt;&lt; 2 + 1 =&gt; x &lt;&lt; (2 + 1)data &amp; 0xFF == 0 =&gt; data &amp; (0xFF == 0)x &lt; -1 || x &gt; 3 &amp;&amp; x &lt; 5 =&gt; x &lt; -1 || (x &gt; 3 &amp;&amp; x &lt; 5) 괄호는 연산자가 아닌 우선순위를 임의로 정하는 기호임. 연산자 결합 규칙x = y = 3 =&gt; x = 3 =&gt; x = 3, y = 3식을 평가하면 단 하나의 결과를 얻을 수 있음.할당 연산자인 y = 3도 하나의 식으로 쓸 수 있으며저장된 값, 즉 3을 결과로 반환함.123456public class test &#123; public static void main(String[] args) &#123; int num; System.out.println(num = 3); // 3 &#125;&#125; 형변환타입이 다른 피 연산자끼리의 연산은 값 손실 최소화를 위해 큰 타입으로 자동 변환.형변환 연산자 생략해도 자동으로 붙음.연산 결과도 큰 타입의 결과로 반환.1.1f + 1L =&gt; 1.1f + (float)1L =&gt; 1.1f + 1.0f = 2.1fint보다 작은 byte, short, char는 자동으로 int로 바뀜.1 + ‘A’ =&gt; 1 + (int)’A’ =&gt; 1 + 65 = 66boolean을 제외한 기본형은 연산이 가능함.1234567891011public class test &#123; public static void main(String[] args) &#123; boolean j = true; // 다 오류다. System.out.println(j + 'A'); System.out.println(j + 1); System.out.println(j + 2.1); System.out.println(++j); System.out.println(j &lt;&lt; 0); &#125;&#125; 산술 연산0으로 나눴을 때 무조건 오류가 나는 게 아니었다.123456public class test &#123; public static void main(String[] args) &#123; System.out.println(3.0 / 0); // Infinity, 3.0 / 0.0 으로 형변환이 일어나기 때문. System.out.println(3 / 0); // java.lang.ArithmeticException: / by zero &#125;&#125; 나머지 연산자도 한번 보자.123456public class test &#123; public static void main(String[] args) &#123; System.out.println(3.0 % 0); // NaN System.out.println(3 % 0); // java.lang.ArithmeticException: / by zero &#125;&#125; int 보다 작은 타입끼리의 연산은 형변환이 필수적이다.1234567891011public class test &#123; public static void main(String[] args) &#123; byte num = 1, num2 = 3, num3; num3 = 1 + 2; // 에러 발생 안함. num3 = (byte)(num + num2); // 이렇게 해줘야함. // (byte)num + num2 =&gt; (byte)num + (int)num2 =&gt; (int)num + (int)num2와 같아짐. num3 = (byte)num + num2; // 에러 발생. // + 때문에 형변환이 발생. num3 = num + num2; // (int)num + (int)num2 =&gt; (int)(num + num2)가 됨. &#125;&#125; 더 큰 타입으로 선언했다고 해도 형변환 연산을 적절하게 써줘야 손실이 일어나지 않는다.123456789101112131415public class test &#123; public static void main(String[] args) &#123; int num = 1000000; int num2 = 2000000; // int 형을 long으로 변환 후에 저장. (long)(num * num2) // 이미 오버플로우가 발생한 int를 long으로 변환한들 원래 값으로 돌아오지 않음. long num3 = num * num2; System.out.println(num3); // -1454759936 // 아래 3가지 중 하나처럼 하면 됨. num3 = (long)num * num2; num3 = num * (long)num2; num3 = (long)num * (long)num2; System.out.println(num3); &#125;&#125; 리터럴과 상수 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에컴파일러가 미리 덧셈 연산을 수행한 후 그 결과를 저장함.int num = 11 * 11이라고 치면 컴파일 후에는int num = 121이 저장되는 거임.하지만 변수가 들어간 연산은 계산 결과를 예측할 수가 없음.int num = num2 * 11이라고 치면 컴파일 후에도int num = num2 * 11이 저장됨. 위와 같은 이유로 리터럴과 상수 간의 연산은 계산 결과를 예측가능하기 때문에형변환 연산자가 생략이 가능한 경우도 있음.1234567891011public class test &#123; public static void main(String[] args)&#123; char c1 = 'a'; final char c2 = 'b'; char c3 = 'a' + 1; // 리터럴 간의 연산이므로 컴파일 후엔 'b'가 저장됨. char c4 = c2 + 1; // 상수와 리터럴 간의 연산이므로 컴파일 후엔 'c'가 저장됨. // 에러, 변수가 껴있는 연산이므로 컴파일 후에도 c1 + 1로 저장됨. // 컴파일 후에 c1이 int보다 작으므로 (int)c1 + 1과 같이 변하게 됨. char c5 = c1 + 1; &#125;&#125; 문자열 비교 메소드 equals()문자열 클래스 String은 기본형이 아니다.따라서 String 클래스의 인스턴스들은 참조형이다.참조형은 변수, 상수에 값을 저장하는 게 아니라 주소(번지)를 저장한다.123456789101112public class test &#123; public static void main(String[] args)&#123; String str = new String(\"ab\"); String str2 = new String(\"ab\"); System.out.println(str == str2); // false, 둘은 다른 주소값을 참조함. System.out.println(str.equals(str2)); // true, 둘은 같은 문자열을 갖고 있음. str = str2 = \"ab\"; // new 키워드를 쓰지 않으면 클래스의 인스턴스가 되지 않아서인지 둘 다 true System.out.println(str == str2); // true System.out.println(str.equals(str2)); // true &#125;&#125; 문자가 숫자인가? 영문자인가?123456789public class test &#123; public static void main(String[] args)&#123; char ch = '1'; System.out.println('0' &lt;= ch &amp;&amp; ch &lt;= '9'); // 숫자면 true ch = 'c'; // 괄호가 없어도 되지만 가독성을 위해 넣음. System.out.println(('A' &lt;= ch &amp;&amp; ch &lt;= 'Z') || ('a' &lt;= ch &amp;&amp; ch &lt;= 'z')); // 영어 대소문자면 true &#125;&#125; 효율적인 논리 연산자x || y =&gt; x가 참이면 무조건 참.즉 x가 참이면 y는 평가하지도 않음.x &amp;&amp; y =&gt; x가 거짓이면 무조건 거짓.즉 x가 거짓이면 y는 평가하지도 않음.이렇게 좌변에 어떤 값을 넣는가에 따라서 연산 속도에 영향을 미침.1234567891011121314151617181920public class test &#123; public static void main(String[] args)&#123; int num = 0, num2 = 1; System.out.println(num == 0 || ++num2 != 0); // num == 0이 참이되자 ++num2는 실행도 안 됨. System.out.println(num + \" \" + num2); // 0 1 System.out.println(num != 0 || ++num2 == 0); // num != 0이 거짓이되자 ++num2가 실행됨. System.out.println(num + \" \" + num2); // 0 2 System.out.println(num != 0 &amp;&amp; ++num2 == 0); // num != 0이 거짓이되자 ++num2는 실행도 안 됨. System.out.println(num + \" \" + num2); // 0 2 System.out.println(num == 0 &amp;&amp; ++num2 == 0); // num == 0이 참이되자 ++num2가 실행 됨. System.out.println(num + \" \" + num2); // 0 3 &#125;&#125; 비트 연산자전자 계산기를 배우니까 드디어 이해가 간다.논리 게이트에서 AND 연산자(&amp;)특정 비트의 값을 뽑아낼 때 사용. OR 연산자(|)특정 비트의 값을 변경할 때 사용. XOR 연산자(^)XOR을 한 번 때리면 암호화, 두 번 때리면 복호화 NOT 연산자(~)1의 보수를 얻을 때 사용.십진수를 이진수로 바꾼 후 각 비트별로 연산을 때린 후 다시 십진수로 바꾼 결과를 반환한다.123456789101112131415161718192021222324252627282930313233343536373839public class test &#123; static String toBinaryString(int num) &#123; String zero = \"00000000000000000000000000000000\"; String tmp = zero + Integer.toBinaryString(num); return tmp.substring(tmp.length()-32); &#125; public static void main(String[] args)&#123; /* num = 0XAB 00000000000000000000000010101011 num2 = 0XF 00000000000000000000000000001111 0XAB &amp; 0XF = 0XB 00000000000000000000000000001011 0XAB | 0XF = 0XAF 00000000000000000000000010101111 0XAB ^ 0XF = 0XA4 00000000000000000000000010100100 0XAB ^ 0XF ^ 0XF = 0XAB 00000000000000000000000010101011 num3 = 0X2 00000000000000000000000000000010 ~num3 = -3 11111111111111111111111111111101 num3 + ~num3 = -1 11111111111111111111111111111111 ~num3 + 1 = -2 11111111111111111111111111111110 */ int num = 0xAB, num2 = 0xF, num3 = 2; System.out.printf(\"num = %#X\\t\\t\\t\\t\\t%s%n\", num, toBinaryString(num)); System.out.printf(\"num2 = %#X\\t\\t\\t\\t\\t%s%n\", num2, toBinaryString(num2)); // 1인 비트들만 뽑아냄. System.out.printf(\"%#X &amp; %#X = %#X\\t\\t\\t%s%n\", num, num2, num &amp; num2, toBinaryString(num &amp; num2)); // 특정 비트들을 1로 바꿈. System.out.printf(\"%#X | %#X = %#X\\t\\t\\t%s%n\", num, num2, num | num2, toBinaryString(num | num2)); // 간단한 암호화. System.out.printf(\"%#X ^ %#X = %#X\\t\\t\\t%s%n\", num, num2, num ^ num2, toBinaryString(num ^ num2)); // 간단히 암호화한 것을 복호화. System.out.printf(\"%#X ^ %#X ^ %#X = %#X\\t\\t%s%n\", num, num2, num2, num ^ num2 ^ num2, toBinaryString(num ^ num2 ^ num2)); System.out.printf(\"num3 = %#X\\t\\t\\t\\t\\t%s%n\", num3, toBinaryString(num3)); // 1의 보수를 구함. System.out.printf(\"~num3 = %d\\t\\t\\t\\t\\t%s%n\", ~num3, toBinaryString(~num3)); // 직접 더해보니 모든 비트가 1이 되는 걸 보니 1의 보수가 맞음. System.out.printf(\"num3 + ~num3 = %d\\t\\t\\t%s%n\", num3 + ~num3, toBinaryString(num3 + ~num3)); // 1의 보수에 1을 더하면 2의 보수, 즉 음수를 구할 수 있음. System.out.printf(\"~num3 + 1 = %d\\t\\t\\t\\t%s%n\", ~num3 + 1, toBinaryString(~num3 + 1)); &#125;&#125; 쉬프트 연산자연산 속도가 상당히 빠르다.하지만 가독성이 안 좋다.피연산자의 타입을 일치시키지 않는다.byte, short, char는 int로 자동 형변환이 일어난다.속도가 엄청 중요시되는 곳이 아니면 곱셈, 나눗셈을 쓰자. 삼항 연산자역시 형변환이 일어난다.12345public class test &#123; public static void main(String[] args) &#123; System.out.println(true ? 0 : .1); // 0.0 &#125;&#125; 대입 연산자(할당 연산자)lvalue = rvaluel은 left, r은 right의 준말.lvalue에는 변수와 이 값을 변경할 수 있는 것만 들어갈 수 있고,rvalue에는 변수 뿐만 아니라 식, 상수, 리터럴 등등이 가능하다. x = y = 3 y = 3 =&gt; 3 x = 3 복합 연산자123456789public class test &#123; public static void main(String[] args) &#123; int i = 1, j = 2; i += 1 + j; // i = i + (1 + j) = i + 1 + j System.out.println(i); // 4 i *= 1 + j; // i = i * (1 + j) System.out.println(i); // 12 &#125;&#125; 반복문 - switch장단점 가독성이 좋아짐. 조건을 한 번만 검사하면 돼서 속도가 빠름. if 문으로 표현 가능하나 switch 문으로 표현 불가능한 경우가 있음. 제약조건 switch 조건식은 (정수)리터럴, 변수, 상수, (문자)리터럴, 변수, 상수, (문자열)리터럴, 변수, 상수만 가능 case 문의 값은 정수 리터럴, 정수 상수, 문자 리터럴, 문자 상수, 문자열 리터럴, 문자열 상수만 가능함. 문자는 자동으로 int형으로 변환돼서 정수와 같이 취급됨. 자바7부터 문자열 관련 내용이 추가됨.123456789101112131415161718public class test &#123; public static void main(String[] args) &#123; final int num = 48; int num2 = 47; switch ('1') &#123; case 49: // 조건식은 char이지만 int와 호환 가능 System.out.println(\"str\"); break; case num: // num은 final 지정 예약어를 써서 상수로 만들었으므로 가능함. System.out.println(\"str\"); break; case num2: // 변수는 불가능! System.out.println(\"str\"); break; case \"asdf\": // 조건식은 char인데 값은 string이라서 오류. &#125; &#125;&#125; 연습 문제 오답 연산자의 우선 순위사칙 연산이 시프트 연산자보다 우선순위가 높다. 1234567public class test &#123; public static void main(String[] args) &#123; int x = 2; // int는 32비트, 33 % 32 = 1; System.out.println(1 + x &lt;&lt; 33); // 3 &lt;&lt; 33 = 3 &lt;&lt; 1 = 3 * 2^1 = 3 * 2 = 6 &#125;&#125; 나의 머리를 때린 문제 아래는 변수 num의 값보다 크면서도 가장 가까운 10의 배수에서 변수 num의 값을뺀 나머지를 구하는 코드이다. 예를 들어 24의 크면서도 가장 가까운 10의 배수는 30이다.19의 경우 20이고, 81의 경우 90이 된다. 30에서 24를 뺀 나머지는 6이기 때문에변수 num의 값이 24라면 6을 결과로 얻어야 한다. 123456789public class test &#123; public static void main(String[] args) &#123; int num = 24; // 내가 생각한 답. System.out.println((num / 10 + 1) * 10 - num); // 저자가 생각한 답. 진짜 천재다. 문제는 함정 투성이었다 ㅠㅠ System.out.println(10 - num%10); &#125;&#125; 실수형 비교boolean result = d==f2; → boolean result = (float)d==f2;비교연산자도 이항연산자이므로 연산 시에 두 피연산자의 타입을 맞추기 위해 형변환이 발생한다.그래서 double과 float의 연산은 double과 double의 연산으로 자동형변환 되는데실수는 정수와 달리 근사값으로 표현을 하기 때문에 float를 double로 형변환했을 때 오차가 발생할 수 있다.그래서 float값을 double로 형변환하기 보다는 double값을 유효자리수가 적은float로 형변환해서 비교하는 것이 정확한 결과를 얻는다.&nbsp;이제부터 나만의 해설.같은 수가 있을 때 float로 표현한 실수가 double로 표현한 실수보다 오차가 클 수 있다.따라서 오차가 큰 float를 double로 바꿔도 오차가 큰 double이 된다.따라서 float를 double로 바꿨다 하더라도오차가 큰 double와 오차가 작은 double을 비교하면 신뢰할 수 없는 값이 나온다.그럼 역으로 오차가 작은 double을 오차가 큰 float로 형변환 시키는 것이다.이러한 역발상을 통해 둘 다 오차가 큰 float로 만들어서 비교하면 신뢰할 수 있는 결과가 나온다.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"연산자","slug":"연산자","permalink":"http://perfectacle.github.io/tags/연산자/"},{"name":"조건문","slug":"조건문","permalink":"http://perfectacle.github.io/tags/조건문/"}]},{"title":"(Java) 자바의 정석 3판 003일차 - 형변환, 정규화, 연산자","slug":"Java-study-003day","date":"2017-01-01T11:00:22.000Z","updated":"2017-08-04T04:30:47.000Z","comments":true,"path":"2017/01/01/Java-study-003day/","link":"","permalink":"http://perfectacle.github.io/2017/01/01/Java-study-003day/","excerpt":"","text":"형변환(캐스팅, Casting)기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 형변환이 가능.역시 자스를 먼저 배우고 나니 자스의 자유로운 형변환이 그리울 때가 있다.또한 기본형과 참조형(reference type)간의 형변환은 불가능하다.또한 실수형을 정수형으로 바꾸면 반올림 하지 않고 소수점 이하를 다 짜른다.왜냐하면 정수형에서는 소수점 이하를 표현할 방법이 없기 때문이다.형변환을 할 때 캐스팅 연산자를 써줘야하지만 생략하면 자동으로 컴파일러가 붙여준다.하지만 손실이 발생할 수 있는 경우에는 오류가 발생한다.따라서 손실이 발생하는 경우에는 무조건 캐스팅 연산자를 써줘야한다.1234567891011121314151617public class test &#123; public static void main(String[] args) &#123; char ch = 'A'; short num = 255; int num2 = num; num2 = ch; long num3 = 12345678781234L; // float은 4byte지만 부동 소수점 형태로 표현되기 때문에 8byte인 long보다 더 넓은 범위를 표현할 수 있다. // 하지만 정밀도 때문에 오차가 발생할 수는 있다. float num4 = num3; double num5 = num3; // ch와 num은 둘 다 2byte지만 ch는 unsigned short와 같이 부호가 없으므로 표현 범위가 다름. // 따라서 서로 손실이 발생하므로 형변환 연산자가 꼭 존재해야함. ch = (char)num; num = (short)ch; &#125;&#125; 십진수를 2진수로 보기123456789public class test &#123; public static void main(String[] args) &#123; int num = (int)-2.8d; // num = 11111111111111111111111111111110 System.out.println(\"num = \" + Integer.toBinaryString(num)); num = (int)2.8d; System.out.println(\"num = \" + Integer.toBinaryString(num)); // num = 10 &#125;&#125; 정규화정규표현식의 정규는 많이 들어봤는데 그것과는 많이 다른 것이다.기본적으로 부동소수점에 대한 이해를 하고 있어야한다.우선 정의부터 살펴보면 2진수로 변환된 실수를 저장기 전에 1.xxx x 2n의 형태로 변환하는 과정.2진수로 변환된 실수를 정수부에 1만 남기고 소수점에 관한 정보는 2n으로 표현한 것. 십진 실수 10.625를 2진 실수로 바꾸면 1010.101이다.2진수로 변환된 실수를 정규화하면 1.010101 x 23가 된다.이를 지수 표기법(Exponential Notation)으로 바꾸면 1.010101e3이 된다.이 정규화된 수를 토대로 IEE754로 표기하여 저장하는 것이다. 연산자(operator) 식(expression)연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것.2+3 등등 식을 평가(evaluation)하다.식을 계산하여 결과를 얻는 것단 하나의 식을 평가(계산)하면 단 하나의 결과를 얻음. 문(statement)식을 프로그램에 포함시키려면 식의 끝에 세미콜론을 붙여 하나의 문으로 만들어야함.2+3; 등등하지만 결과를 얻었지만 쓰이지 않고 사라지기 때문에 무의미함.나중에 사용하기 위해 메모리 상의 공간(변수, 상수)에 저장한 후 꺼내 쓰면 됨.int num = 1 + 2;int num2 = num * 3;변수 선언 = 식; =&gt; 하나의 문장.하지만 다른 곳에서도 쓰이지 않을 결과라면 굳이 식을 문으로 바꾸지 않아도 됨.아래와 같이 메소드의 매개변수로 쓰이는 등등의 경우와 같음.System.out.println(2+3);식을 혼자 쓴 게 아니라 문 안에 식이 쓰인 것이다. 연습문제 오답 char의 형변환!12345678public class test &#123; public static void main(String[] args) &#123; System.out.println('A' + 'B'); // 65 + 66 = 131 System.out.println('1' + 2); // 49 + 2 = 51 System.out.println('1' + '2'); // 49 + 50 = 99 System.out.println(\"\" + true); // \"true\" &#125;&#125; 문자열 + any type → 문자열 + 문자열 → 문자열any type + 문자열 → 문자열 + 문자열 → 문자열 System은 키워드가 아니었다! 참조형 변수(reference type) 4byte이다!!JAVA 변수타입참조형 변수는 null 또는 객체의 주소(4 byte, 0x0~0xffffffff)를 값으로 갖는다.null은 어떤 값도 갖고 있지 않음, 즉 어떠한 객체도 참조하고 있지 않다는 것을 뜻한다. 캐스팅 연산자 생략 1234567public class test &#123; public static void main(String[] args) &#123; int num = 0; // 표현할 수 있는 범위더라도 int =&gt; 4byte, byte =&gt; 1byte 이므로 캐스팅 연산자 꼭 써줘야함. byte num2 = num; &#125;&#125; 접근 지정자, 지정 예약어, 메소드접근 지정자 - public, protect, default, private지정 예약어 - this, static, final메소드 - 리턴타입 이름(매개변수) {}지정 예약어 this를 빼고 설명. 지정 예약어끼리는 순서 상관 없음 =&gt; static final이던 final static이던 접근 지정자와 지정 예약어도 순서 상관 없음 =&gt; public static이던 static public이던 하지만 메소드는 무조건 접근 지정자와 지정 예약어 뒤에 와야함. 접근 지정자를 생략하면 default 접근 지정자가 적용됨. 지정 예약어는 생략 가능하며 생략해도 기본값이 없음. 메소드에서는 매개변수를 제외한 모든 것은 생략 불가능. 즉 기본 값이 없음. 변수의 기본값 참조형 - null 기본형 boolean - false char - ‘\\u0000’ byte - 0 short - 0 int - 0 long - 0L or 0l float - 0.0F or 0.0f double - 0.0 or 0.0D or 0.0dbyte, short는 컴파일 할 때 자동으로 int 타입으로 바꿈.long에 접미어 L을 붙이는 이유는 int와 다른 메모리 공간을 차지하게 하기 위함.float도 double과 차별을 두기 위해 접미어를 붙이게 끔 설계됨.","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"연산자","slug":"연산자","permalink":"http://perfectacle.github.io/tags/연산자/"},{"name":"형변환","slug":"형변환","permalink":"http://perfectacle.github.io/tags/형변환/"},{"name":"정규화","slug":"정규화","permalink":"http://perfectacle.github.io/tags/정규화/"}]},{"title":"(Java) 자바의 정석 3판 002일차 - char의 형변환과 실수형(부동 소수점)","slug":"Java-study-002day","date":"2016-12-31T09:12:20.000Z","updated":"2017-08-04T04:30:47.000Z","comments":true,"path":"2016/12/31/Java-study-002day/","link":"","permalink":"http://perfectacle.github.io/2016/12/31/Java-study-002day/","excerpt":"","text":"char의 연산자별 형변환.전위&amp;후위 연산자는 형변환을 하지 않고기타 연산자는 int로 형변환을 함.12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; char ch = 65; System.out.println(ch++); // 'A' System.out.println(ch); // 'B' System.out.println(++ch); // 'C' ch = 65; System.out.println(ch); // 'A' System.out.println(ch+0); // 65 System.out.println(+ch); // 65 System.out.println(-ch); // -65 System.out.println(ch &lt;&lt; 1); // 130 System.out.println(ch); // 'A' short num = 0; // num = ch + 1; // error int num2 = 0; num2 = ch + 1; // 에러가 나지 않음. &#125;&#125; 170102 내용 수정형변환은 쉬프트 연산자(&lt;&lt;, &gt;&gt;), 증감 연산자(++, –)에서만 일어나지 않음. 오버 플로우(overflow)정수형최대값 + 1 == 최소값최소값 - 1 == 최대값 실수형최대값 + @ == Infinity최소값 - @ == -Infinity표현할 수 없는 아주 작은 0에 수렴하는 값 == 0.0(underflow)12345678public class test &#123; public static void main(String[] args) &#123; System.out.println(Float.MAX_VALUE * 2); // Infinity System.out.println(Float.MAX_VALUE * -2); // -Infinity System.out.println(Float.MIN_VALUE * 0.1f); // 0.0 (underflow) System.out.println(Float.MIN_VALUE * -0.1f); // -0.0 (underflow) &#125;&#125; 실수형의 오차IEEE 754전기 전자 기술자 협회(IEEE)에서 개발했고, 컴퓨터에서 부동 소수점을 표기하기 위한 표준.실수를 표기하는 데는 위와 같이 부동 소수점이 있고, 고정 소수점이 있다.고정 소수점은 매우 직관적이라는 장점이 있지만범위가 작고, 정밀도가 낮다.(이 말은 오차 없이 표현해낼 수 있는 수의 범위가 매우 좁다고 이해하면 되려나??)그에 따라 부동 소수점이 현재 쓰이는 것으로 알고 있다. 나는 정밀도(precision)에 대해 이해하지 못해서 정리를 해보자 한다.float 정밀도: 7자리double 정밀도: 15자리나는 아래와 같이 소수점을 제외한 십진수 7개를 뜻하는 줄 알았다.xxxx.xxxx.xxxxxx 뭐 반은 맞고 반은 틀렸달까… 예제를 보고 이해해보자.123456789101112public class test &#123; public static void main(String[] args) &#123; // 정밀도는 오차 없이 표현하는 10진수의 갯수이다. // 오차가 있을 수도, 없을 수도 있다. // 10진수 8개를 오차없이 표현해냈다. System.out.println(1.2345678e-3f); // 0.0012345678 // 10진수 8개를 오차있이 표현해냈다. System.out.println(1.2345679e-3f); // 0.001234568 // double은 15자리의 정밀도를 가지므로 10진수 8개 정도는 거뜬하다. System.out.println(1.2345679e-3); // 0.0012345679 &#125;&#125; 또한 소수점 계산시 오차가 발생한다.0.1 + 0.2 == 0.30000000000000004아주 괴랄한 숫자가 나온다.왜 나오는지 파악해보자.는 귀찮으니 아래 글들을 참고하자.소수점 때문에 바보가 되는 컴퓨터??컴퓨터에서는 0.1을 어떻게 저장/표현 하나요?!10진수 소수점을 2진수 변환소수점끼리의 계산은 끝자리가 5로 끝나는 (0.00005, 0.231423415 등등) 숫자들끼리의 연산이 아니고서는정확한 값이 나온다는 확신을 가질 수가 없다.왜냐하면 5로 끝나지 않는 0.1 같은 십진 소수를 이진 소수로 바꿀 방법이 없다.10진수로는 유한소수여도 2진수로는 무한 소수인 경우가 존재하기 때문에…2진수로도 무한 소수가 아니더라도 가수를 저장할 수 있는 공간이 한정돼있기 때문에버려지는 수에 의해 오차가 발생하기도 한다.아마 같은 수라도 고정 소수점에서는 오차가 발생하지 않을 수도 있지 않을까.. 하는 생각을 한다.이는 부동 소수점이 가지는 단점이며 소수를 정수로 바꿔서 연산 후 다시 소수로 바꾸는 방법이 있다.정수는 오차가 없기 때문이다. 실수형의 정밀도왜 float은 7자리, double은 15자리의 정밀도를 가질까?그것은 float은 1자리의 부호 비트, 8자리의 지수 비트, 23자리의 가수 비트 = 32비트23자리의 2진수 =&gt; 약 7자리의 10진수가 표현이 가능하기 때문이다.double도 찾아보면 마찬가지의 공식으로 결과가 나온다. 바이어스 표기법부동소수점에 대한 이해위 링크를 참조하자. 부동 소수점에서 지수부를 표현할 때는 바이어스 표기법을 사용한다.바이어스 표기법 = 2의 보수 + 바이어스 상수. 바이어스 상수: 2n-1-1n은 지수를 나타내는 비트의 갯수.음의 지수를 나타내기 위해 n비트로 나타낼 수 있는 갯수를 반으로 쪼개고(n-1)0이 포함돼있기 때문에 -1을 해준다.정수를 표현할 때는 음수가 표현할 수 있는 갯수가 1개가 더 많았는데실수의 지수를 표현할 때는 양수가 표현할 수 있는 갯수가 1개 더 많은 차이점이 존재한다. float: 28-1-1 = 27-1 = 128-1 = 127(-127~128의 지수 표현 가능)double: 252-1-1 = 251-1 = 알아서 계산하지만 자바에서는 마지막 끝 값들인 -2n-1-1 ~ 2n-1은 NaN, ±Infinity를 표현하는데 쓰임.따라서 실제로 쓰이는 범위는-2n-1 + 1 ~ 2n-1-1 이라고 보면 됨 double은 너무 크니까 float를 기준으로 설명.3을 바이어스 표기법으로 나타내면3 + 127 = 00000101 + 01111111 = 10000010위와 같이 하면 어려우니까 그냥 아래와 같이 계산하는 게 훨씬 쉽다.지수 + 바이어스 상수 = 10진수 =&gt; 2의 보수법으로 변경3 + 127 = 130 = 10000010-126 = -126 + 127 = 1 = 00000001128 = 128 + 127 = 255 = 11111111","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"},{"name":"부동소수점","slug":"부동소수점","permalink":"http://perfectacle.github.io/tags/부동소수점/"}]},{"title":"(Java) 자바의 정석 3판 001일차 - 컴퓨터 이론, 리터럴 & 변수 & 변수","slug":"Java-study-001day","date":"2016-12-30T08:18:24.000Z","updated":"2017-08-04T04:15:19.000Z","comments":true,"path":"2016/12/30/Java-study-001day/","link":"","permalink":"http://perfectacle.github.io/2016/12/30/Java-study-001day/","excerpt":"","text":"컴퓨터는 왜 2진수를 사용할까?10진법이 익숙한 이유는 손가락이 10개이기 때문이지 않을까?에니악은 10진법 체계였지만 전기회로는 전압이 불안정해서 전압을 10단계로 나누어 처리하는데 한계가 있음에드박은 단 두가지 단계, 전기가 흐르면 1, 전기가 흐르지 않으면 0만으로 동작하게 설계되었다따라서 컴퓨터와 같은 전기회로는 2진 체계를 사용하게 되었다. 그렇다면 8진수와 16진수는 왜 생겼을까?2진수는 숫자를 표현하기 위해 상당히 많은 자릿수를 차지한다.코딩할 때도 이렇게 많은 자릿수는 가독성을 해칠 수 있다.따라서 이런 단점을 보완하기 위해 8진수와 16진수가 등장했다.그렇다면 왜 8진수와 16진수일까?2진수 2자리로는 4진수를2진수 3자리로는 8진수를2진수 4자리로는 16진수를 표현할 수 있다.2진수 2자리는 그닥 많은 자릿수를 절약할 수 없어서 사용을 안 하게 된 게 아닐까 싶다…8진수를 사용하는 대표적인 예는 리눅스나 FTP 등에서 파일이나 폴더에 관한 권한을 표현하기 위해 많이 쓰인다.777 을 예로 들면r 읽기 허용(4) w 쓰기 허용(2) x 실행 허용(1) 을 다 더하면 7이 나오고u 사용자(소유자) g 그룹 o 기타(사용자와 그룹을 제외한 사람) 순서로 기술하면 된다.16진수를 사용하는 대표적인 예는 rgb 컬러 코드(#ff00ff), 유니코드(\\u0061, U+0061, 0x0061 등등)에서 쓰인다. boolean은 1bit가 아닌 왜 1byte일까?Why is a boolean 1 byte and not 1 bit of size?CPU가 메모리(RAM)의 주소(address)에 접근해야하는데하나의 메모리 주소가 가지는 데이터의 크기는 1byte(8bit)이다.따라서 CPU가 메모리 주소에 접근해서 사용할 수 있는 최소한의 단위는 1byte가 된다.따라서 boolean은 1bit가 아니라 1byte가 된 것이다. 1byte는 왜 8bit일까?아스키(Ascii)메모리 하나당 차지하는 바이트 수에 대해 궁금한 점이 있습니다.메모리 주소당 데이터용량이 1바이트인 이유가 먼가요??1바이트는 왜 8비트일까?과거에는 1byte가 7bit, 9bit 등등이던 시절이 있다고 하지만 현재는 8비트로 거의 표준이 된 것 같다.이에 대한 이유로 내 나름대로 결론을 내린 것은 미국에서 컴퓨터를 개발했기 때문이라고 본다.미국에서 문자를 사용하기 위한 코드로 ascii 코드(7bit)가 있는데왜 7bit가 아닌 8bit가 1byte가 되었을까?내 나름대로 추측을 해보자면 데이터 송수신의 오류를 검출하기 위한 패리티 비트로 1비트가 추가됐다. 유럽권을 고려해서 확장 아스키 코드를 베이스로 정했다. 정확히 뭔지는 모르겠으나 ascii 코드를 베이스로 1byte의 bit수가 정해진 것에는 틀림이 없는 것 같다. 리터럴, 변수, 상수 리터럴 - 짧게 얘기하면 변하지 않는 값길게 얘기하면 우리는 변하지 않는 값을 일상생활에서는 상수라고 불렀다.하지만 상수는 프로그래밍 세계에서는 좀 다른 뜻으로 불리기 때문에그와 차별성을 부여하기 위해 리터럴이라고 붙였다.“ch”, ‘c’, 123, 123.55 등등 모두 리터럴이다. 변수 - 짧게 얘기하면 변하는 수길게 얘기하면 단 하나의 값을 저장할 수 있는 메모리 상의 공간.int num = 2;int num;까지만 하면 램(RAM, Random Access Memory)에서사용 중이지 않은 주소 4개를 랜덤하게 접근해서 공간 확보만 함.램은 여러 프로그램이 공유하는 자원이므로 이전에 다른 프로그램에 의해 저장된 값이 남아있을 수 있음.그 다른 프로그램에 의해 저장된 알 수 없는 값을 쓰레기값(garbage value)이라고 함. 상수 - 짧게 얘기하면 변하지 않는 수길게 얘기하면 단 하나의 변하지 않는 값을 저장할 수 있는 메모리 상의 공간.상수가 필요한 이유는 리터럴에 의미있는 이름을 붙여서 가독성을 높이기 위함이다. 1234567891011121314// 상수를 사용하지 않음.public class test &#123; public static void main(String[] args) &#123; int triangleArea = 20 * 10 / 2; &#125;&#125;// 상수를 사용함.public class test &#123; public static void main(String[] args) &#123; final int WIDTH = 20; final int HEIGHT = 10; int triangleArea = WIDTH * HEIGHT / 2; &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"http://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"http://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"http://perfectacle.github.io/tags/자바의-정석/"}]},{"title":"(ES6) Interface","slug":"es6-interface","date":"2016-12-25T13:17:14.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2016/12/25/es6-interface/","link":"","permalink":"http://perfectacle.github.io/2016/12/25/es6-interface/","excerpt":"","text":"이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.이터레이터 인터페이스와 이터러블 인터페이스는 다음 포스트에서 정리할 예정이다.이 글을 읽고난 후에 (ES6) Symbol에 대한 글부터 읽어보길 바란다.다소 짧아서 어디 공유하기 부끄럽지만 이렇게 짧은 내용들이 집중해서 읽기에 참 좋은 것 같다. InterfaceECMAScript2015(이하 ES6) 들어서서 인터페이스는 고유 명사가 되었다. 고유명사(固有名詞)낱낱의 특정한 사물이나 사람을 다른 것들과 구별하여 부르기 위하여 고유의 기호를 붙인 이름. Java에서 Interface는 다음과 같은 명세를 준수해야 Interface라고 부른다.자바 허접이라 다음 링크를 참조하였다.JAVA 강좌 21편. 인터페이스(Interface)Interface는 객체인가? 메소드는 public abstract로 선언된 추상 메소드만을 가진다. 변수는 public static final로 선언된 상수만을 가진다. 위 2가지 조건만 만족하면 자바에서는 인터페이스라고 불리운다.나머지는 인터페이스의 특징인 것 같아 생략하였다. (다중 상속 등등)자바에서 인터페이스는 고유 명사이며 위와 같은 의미를 가진다. 이와 같이 ES6에서도 이제 인터페이스는 자바와 같이 고유 명사가 되었다.그 말은 ES6에서의 인터페이스는 다른 곳에서 쓰이는 인터페이스와는 다른 것이라는 걸 뜻한다.아래 사이트를 가도 볼 수 있다.http://www.ecma-international.org/ecma-262/6.0/#sec-iteration그럼 ES6에서 말하는 인터페이스는 무엇인지 살펴보자. 객체가 가져야하는 키를 명시. 그 키가 가져야 하는 값을 명시. 위 조건만 만족하면 ES6에서는 인터페이스라고 불리울 수 있다.인터페이스는 객체나 클래스가 아닌 하나의 명세라고 보면 될 것 같다.그럼 test 인터페이스를 정의해보자.안타깝게도 사용자 인터페이스를 정의할 방법은 없는 것 같지만,설명을 위해 작성해보았다. test와 testing이라는 키를 가짐. test는 매개변수로 숫자를 받고 매개변수의 제곱한 결과를 반환함. testing은 boolean 값을 가짐. 하나만 하면 심심하니 test2라는 인터페이스도 정의해보자. name과 age라는 키를 가짐. name은 string 값을 가짐. age는 number 값을 가짐. 그럼 위 인터페이스를 충족하는 객체를 만들어보자.1234567const obj = &#123; test: num =&gt; Math.pow(num, 2), testing: false, name: \"양간장\", age: 24, etc: \"위 키들을 제외하고는 어떠한 키가 오던 상관이 없다.\"&#125; obj 객체는 test와 test2 인터페이스 조건을 충족하므로 test, test2 인터페이스를 따르는 객체이다. test 인터페이스의 조건을 충족하므로 test 인터페이스를 따르는 객체이다. test라는 키를 가지고 있다. test라는 키의 값은 숫자를 매개변수로 받고 매겨변수로 받은 숫자를 제곱해서 반환한다. testing이라는 키를 가지고 있다. testing이라는 키의 값은 boolean 값을 가진다. test2 인터페이스의 조건을 충족하므로 test2 인터페이스를 따르는 객체이다. name이라는 키를 가지고 있다. name이라는 키의 값은 string 값을 가진다. age라는 키를 가지고 있다. age라는 키의 값은 number 값을 가진다. 그 이외에 키에 관해서는 test와 test2 인터페이스에서 명세한 바가 없으므로 전혀 상관이 없다.이는 마치 덕타이핑(duck typing)과 매우 유사한 것 같다. 덕 타이핑(duck typing)오리처럼 생겨서 오리처럼 걷고 오리처럼 꽥꽥 소리를 낸다면 그건 오리다라는 속담에서 유래됐다고 한다. name, age 키가 있고 그 키에 맞는 값들을 가진다면 그건 test2 인터페이스를 따르는 것이다.다른 어떠한 키가 오더라도 위 두개의 키만 조건을 준수한다면 test2 인터페이스를 따른다는 것이다.좀 다른 건가…? 역시 남이 떠다 먹여주는 정보들만 받아 먹다보니 혼자서 탐구하는 것은 정말 어려운 것 같다. 뭐 여하튼 이렇듯 ES6에서는 사용자가 인터페이스를 정의할 수 없다보니표준으로 정의해놓은 인터페이스가 있는데 그게 바로이터러블 인터페이스와 이터레이터 인터페이스인데 길어서 인터페이스는 빼는 것 같다.위 두 인터페이스 외에도 많은 것 같은데(사실 모른다.)대표적인 두 인터페이스만 다음 포스트에서 다뤄야할 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"Interface","slug":"Interface","permalink":"http://perfectacle.github.io/tags/Interface/"}]},{"title":"(ES6) Number 객체와 함수","slug":"ES6-Number-object-and-function","date":"2016-12-24T06:11:28.000Z","updated":"2017-08-03T11:13:00.000Z","comments":true,"path":"2016/12/24/ES6-Number-object-and-function/","link":"","permalink":"http://perfectacle.github.io/2016/12/24/ES6-Number-object-and-function/","excerpt":"","text":"(ES6) 숫자형을 보고 이 글을 보는 걸 추천한다. 목차 Number 객체(Global 객체) Properties Methods Number 함수 함수 생성자 Number ↔ String Number 객체(Global 객체)ES5까지 Number 객체는 거의 래퍼 객체의 역할만을 수행했다.하지만 ES6에 들어서면서 다양한 프로퍼티와 메소드들이 생기면서래퍼 객체 이상의 역할을 수행하는 전역 객체와 같이 쓸 수 있게 되었다.래퍼 객체는 원시 타입의 값을 객체로 다루기 위한 객체이며,래퍼 객체의 진가는 prototype 프로퍼티를 통해 드러나게 된다.래퍼 객체를 어떻게 사용하는지는 나중에 보도록 하고,일단 Number 객체의 구조를 보도록 하자.1console.dir(Number); Properties* 표시는 ES6에서 새로 추가됨. Number.POSITIVE_INFINITY Number.NEGATIVE_INFINITY Number.NaN Number.MIN_VALUE Number.MAX_VALUE Number.MIN_SAFE_INTEGER * Number.MAX_SAFE_INTEGER * Number.EPSILON * Number.prototype 표준 프로퍼티들은 상수이다.즉 변경이 불가능하다.12Number.EPSILON = \"asdf\"; // 오류는 나지 않는다.console.log(Number.EPSILON); // 2.220446049250313e-16 Number.POSITIVE_INFINITY &amp; Number.NEGATIVE_INFINITY &amp; Number.NaN123console.log(Number.POSITIVE_INFINITY === Infinity); // trueconsole.log(Number.NEGATIVE_INFINITY === -Infinity); // trueconsole.log(isNaN(Number.NaN)); // true Number.MIN_VALUE &amp; Number.MAX_VALUEProblem in ES부동 소수점에 대한 이해수의 표현범위가 다른 int와 float, 그리고 신뢰할 수 없는 부동소수점123456console.log(Number.MIN_VALUE); // 5e-324console.log(Number.MIN_VALUE - 1); // -1console.log(Number.MIN_VALUE + 1); // 1console.log(Number.MAX_VALUE); // 1.7976931348623157e+308console.log(Number.MAX_VALUE + 1); // 1.7976931348623157e+308console.log(Number.MAX_VALUE + 1 === Number.MAX_VALUE - 1); // true Number.MIN_SAFE_INTEGER * &amp; Number.MAX_SAFE_INTEGER *Solution in ES612345678console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991console.log(-(Math.pow(2, 53) - 1)); // -9007199254740991console.log(Number.MIN_SAFE_INTEGER !== Number.MIN_SAFE_INTEGER + 1); // trueconsole.log(Number.MIN_SAFE_INTEGER - 1 !== Number.MIN_SAFE_INTEGER - 2); // falseconsole.log(Number.MAX_SAFE_INTEGER); // 9007199254740991console.log(Math.pow(2, 53) - 1); // 9007199254740991console.log(Number.MAX_SAFE_INTEGER !== Number.MAX_SAFE_INTEGER - 1); // trueconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); // true Polyfill123456789101112131415161718if(!Number.MIN_SAFE_INTEGER) &#123; if(!Object.create) &#123; // in ES3 Number.MIN_SAFE_INTEGER = -(Math.pow(2, 53) - 1); &#125; else &#123; // in ES5 Object.defineProperty(Number, \"MIN_SAFE_INTEGER\", &#123; value: -(Math.pow(2, 53) - 1) &#125;); &#125;&#125;if(!Number.MAX_SAFE_INTEGER) &#123; if(!Object.create) &#123; // in ES3 Number.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; &#125; else &#123; // in ES5 Object.defineProperty(Number, \"MAX_SAFE_INTEGER\", &#123; value: Math.pow(2, 53) - 1 &#125;); &#125;&#125; Number.EPSILON *Problem in ES12console.log(.1 + .2); // 0.30000000000000004console.log(0.1 + 0.2 === 0.3); // false ES에서는 위와 같이 소수점 계산에서 고질적인 문제를 안고 있다.이는 아마 IEEE에서 제정한 부동소수점 표현 형식인 IEE754의 고질적인 문제라고 보여진다.실수 표현 문제 발생 이유 or 오차 발생 이유 자바스크립트의 숫자는 십진 부동 소수점 숫자로 접근하는데 반해 그 내부 동작 원리는 이진 부동 소수점 숫자이기 때문에 오차가 발생한다.원문 보기JavaScript’s numbers are usually entered as decimal floating-point numbers,but they are internally represented as binary floating-point numbers.That leads to imprecision. 위와 같은 문제는 IEE754를 사용하는 Java에서도 동일하게 발생한다.123456public class test &#123; public static void main(String[] args) &#123; System.out.println(0.1 + 0.2); // 0.30000000000000004 System.out.println(0.3 == 0.1+0.2); // false &#125;&#125; 어찌보면 0.00000000000000004 정도의 오차는 무시되도 되는 작은 숫자이다. Solution in ES6Number.EPSILON은 오차없이 나타낼 수 있는 가장 작은 양의 소수를 나타낸다.이렇게 무시되어도 될 정도의 작은 오차를 구분하기 위해 등장한 프로퍼티이다.123456console.log(5e2); // 500console.log(5e-2); // 0.05console.log(0.5e2); // 50console.log(Number.EPSILON); // 2.220446049250313e-16console.log(Number.EPSILON.toFixed(20)); // 0.00000000000000022204 과연 0.0000000000000004는 무시돼도 될 정도로 작은 오차인지 살펴보자.12345/* * 0.00000000000000004 * 0.00000000000000022204 */console.log(0.0000000000000004 &lt; Number.EPSILON); // true 즉 좌변에 있는 값이 우변에 있는 Number.EPSILON 보다도 작다면 무시해도 되는 오차다. Usage1234567// 이 함수가 true를 반환하면 formula와 result는 동일하다고 보면 됨.// Number.EPILON은 항상 양수이기 때문에 Math.abs 메소드를 사용하여// 계산식의 결과를 절대값으로 바꾼 후 오차를 비교해야함.const isEqual = (formula, result) =&gt; Math.abs(formula - result) &lt; Number.EPSILON;console.log(isEqual(0.1 + 1 - 2.2, -1.1)); // trueconsole.log(isEqual(0.1 + 1 - 2.2, -1.2)); // false Polyfill123456789if(!Number.EPSILON) &#123; if(!Object.create) &#123; // in ES3 Number.EPSILON = 2.220446049250313e-16; &#125; else &#123; // in ES5 Object.defineProperty(Number, \"EPSILON\", &#123; value: 2.220446049250313e-16 &#125;); &#125;&#125; Number.prototype숫자가 상속받는 프로퍼티와 메소들을 정의해놓은 프로퍼티이다.표준 메소드 및 프로퍼티가 미리 정의돼있으며, 사용자가 직접 정의하려면 아래와 같이 하면 된다.1234Number.prototype.lastNum = function() &#123; return this % 10;&#125;;console.log(12.0.lastNum()); // 2 Methods* 표시는 ES6에서 새로 추가됨. Number.isFinite() * Number.isInteger() * Number.isNaN() * Number.isSafeInteger() * Number.parseInt() * Number.parseFloat() * Number.prototype.toFixed() Number.prototype.toPrecision() Number.prototype.toExponential() Number.prototype.toString() Number.prototype.valueOf() Number.prototype.toLocaleString() 메소드는 수정 가능하다.12Number.isFinite = () =&gt; \"a\";console.log(Number.isFinite(123)); // \"a\" Number.isFinite() *in ES1234567891011console.log(isFinite(0)); // trueconsole.log(isFinite(255)); // trueconsole.log(isFinite(-254)); // trueconsole.log(isFinite(\"1\")); // trueconsole.log(isFinite(NaN)); // falseconsole.log(isFinite(Infinity)); // falseconsole.log(isFinite(-Infinity)); // falseconsole.log(isFinite(null)); // trueconsole.log(isFinite(&#123;&#125;)); // falseconsole.log(isFinite(undefined)); // falseconsole.log(isFinite([])); // true in ES61234567891011console.log(Number.isFinite(0)); // trueconsole.log(Number.isFinite(255)); // trueconsole.log(Number.isFinite(-254)); // trueconsole.log(Number.isFinite(\"1\")); // falseconsole.log(Number.isFinite(NaN)); // falseconsole.log(Number.isFinite(Infinity)); // falseconsole.log(Number.isFinite(-Infinity)); // falseconsole.log(Number.isFinite(null)); // falseconsole.log(Number.isFinite(&#123;&#125;)); // falseconsole.log(Number.isFinite(undefined)); // falseconsole.log(Number.isFinite([])); // false Polyfill123Number.isFinite = Number.isFinite || function(value) &#123; return typeof value === \"number\" &amp;&amp; isFinite(value);&#125; Number.isInteger() *123456789101112console.log(Number.isInteger(0)); // trueconsole.log(Number.isInteger(255)); // trueconsole.log(Number.isInteger(-254)); // trueconsole.log(Number.isInteger(1.1)); // falseconsole.log(Number.isInteger(\"1\")); // falseconsole.log(Number.isInteger(NaN)); // falseconsole.log(Number.isInteger(Infinity)); // falseconsole.log(Number.isInteger(-Infinity)); // falseconsole.log(Number.isInteger(null)); // falseconsole.log(Number.isInteger(&#123;&#125;)); // falseconsole.log(Number.isInteger(undefined)); // falseconsole.log(Number.isInteger([])); // false Polyfill12345Number.isInteger = Number.isInteger || function(value) &#123; return typeof value === \"number\" &amp;&amp; isFinite(value) &amp;&amp; Math.floor(value) === value;&#125;; Number.isNaN() *Problem1console.log(NaN === NaN); // false in ES123456789101112console.log(isNaN(0)); // falseconsole.log(isNaN(-Infinity)); // falseconsole.log(isNaN(\"1.1\")); // falseconsole.log(isNaN(NaN)); // trueconsole.log(isNaN(\"NaN\")); // trueconsole.log(isNaN(\"a\")); // trueconsole.log(isNaN(0 / 0)); // trueconsole.log(isNaN(&#123;&#125;)); // trueconsole.log(isNaN([])); // falseconsole.log(isNaN(undefined)); // trueconsole.log(isNaN(null)); // falseconsole.log(isNaN(/a/)); // true in ES6123456789101112console.log(Number.isNaN(0)); // falseconsole.log(Number.isNaN(-Infinity)); // falseconsole.log(Number.isNaN(\"1.1\")); // falseconsole.log(Number.isNaN(NaN)); // trueconsole.log(Number.isNaN(\"NaN\")); // falseconsole.log(Number.isNaN(\"a\")); // falseconsole.log(Number.isNaN(0 / 0)); // trueconsole.log(Number.isNaN(&#123;&#125;)); // falseconsole.log(Number.isNaN([])); // falseconsole.log(Number.isNaN(undefined)); // falseconsole.log(Number.isNaN(null)); // falseconsole.log(Number.isNaN(/a/)); // false Polyfill12345678Number.isNaN = Number.isNaN || function(value) &#123; return typeof value === \"number\" &amp;&amp; isNaN(value);&#125;;// OrNumber.isNaN = Number.isNaN || function(value) &#123; return value !== value;&#125;; Number.isSafeInteger() *12345678console.log(Number.isSafeInteger(3)); // trueconsole.log(Number.isSafeInteger(Math.pow(2, 53))); // falseconsole.log(Number.isSafeInteger(Math.pow(2, 53) - 1)); // trueconsole.log(Number.isSafeInteger(NaN)); // falseconsole.log(Number.isSafeInteger(Infinity)); // falseconsole.log(Number.isSafeInteger(\"3\")); // falseconsole.log(Number.isSafeInteger(3.1)); // falseconsole.log(Number.isSafeInteger(3.0)); // true Polyfill123Number.isSafeInteger = Number.isSafeInteger || function (value) &#123; return Number.isInteger(value) &amp;&amp; Math.abs(value) &lt;= Number.MAX_SAFE_INTEGER;&#125;; Number.parseInt() *Syntax1Number.parseInt(string[, radix]) Parameters string: 문자열 radix: 2~36진수, 10이 기본값. Example123456789101112console.log(Number.parseInt === parseInt); // trueconsole.log(Number.parseInt(\"11\")); // 11console.log(Number.parseInt(\"11.11\")); // 11console.log(Number.parseInt(\"11A\")); // 11console.log(Number.parseInt(\"A11\")); // NaNconsole.log(Number.parseInt(\"11A1\")); // 11console.log(Number.parseInt(\"11.A\")); // 11console.log(Number.parseInt(\"011\")); // 11console.log(Number.parseInt(\"11 0\")); // 11console.log(Number.parseInt(\"0xFF\")); // 255console.log(Number.parseInt(true)); // NaNconsole.log(Number.parseInt(new Date())); // NaN Problem1234console.log(Number.parseInt(\"0b111\")); // 0console.log(Number.parseInt(\"0b111\", 2)); // 0console.log(Number.parseInt(\"0o10\")); // 0console.log(Number.parseInt(\"0o10\", 8)); // 0 Solution12345678console.log(Number.parseInt(\"111\", 2)); // 7console.log(new Number(\"0b111\").valueOf()); // 7console.log(Number(\"0b111\")); // 7console.log(+\"0b111\"); // 7console.log(Number.parseInt(\"10\", 8)); // 8console.log(new Number(\"0o10\").valueOf()); // 8console.log(Number(\"0o10\")); // 8console.log(+\"0o10\"); // 8 Polyfill1Number.parseInt = Number.parseInt || parseInt; Number.parseFloat() *123456789101112console.log(Number.parseFloat === parseFloat); // trueconsole.log(Number.parseFloat(\"11\")); // 11console.log(Number.parseFloat(\"11.11\")); // 11.11console.log(Number.parseFloat(\"11A\")); // 11console.log(Number.parseFloat(\"A11\")); // NaNconsole.log(Number.parseFloat(\"11A1\")); // 11console.log(Number.parseFloat(\"11.A\")); // 11console.log(Number.parseFloat(\"011\")); // 11console.log(Number.parseFloat(\"11 0\")); // 11console.log(Number.parseFloat(\"0xFF\")); // 0console.log(Number.parseFloat(true)); // NaNconsole.log(Number.parseFloat(new Date())); // NaN Polyfill1Number.parseFloat = Number.parseFloat || parseFloat; Number.prototype.toFixed() &amp; Number.prototype.toPrecision()실수를 반올림 할 때 쓰인다.123456const num = 123.45678;console.log(num.toFixed()); // \"123\"console.log(num.toPrecision()); // \"123.45678\"console.log(num.toString()); // \"123.45678\"console.log(num.toFixed(4)); // \"123.4568\"console.log(num.toPrecision(4)); // \"123.5\" Number.prototype.toExponential숫자를 지수를 통해 표현할 때 쓰인다.123456let num = 7817.1278;console.log(num.toExponential()); // \"7.8171278e+3\"console.log(num.toExponential(2)); // \"7.82e+3\"console.log(num.toExponential(6)); // \"7.817128e+3\"num = 0.1445;console.log(num.toExponential()); // \"1.445e-1\" Number.prototype.toString()숫자를 문자열로 바꿀 때 쓰인다.1234567console.log(1.1.toString()); // \"1.1\"console.log(1.0.toString()); // \"1\"console.log(0b11.toString()); // \"3\"console.log(NaN.toString()); // \"NaN\"console.log(Infinity.toString()); // \"Infinity\"console.log(-Infinity.toString()); // -Infinityconsole.log(0.0.toString()); // \"0\" Number.prototype.valueOf()숫자 객체의 인스턴스에서 숫자값을 얻어올 때 쓰인다.123console.log(new Number(11).valueOf()); // 11console.log(new Number(0b11).valueOf()); // 3console.log(new Number(&#123;&#125;).valueOf()); // NaN Number.prototype.toLocaleString()Syntax1Number.prototype.toLocaleString([locales [, options]]); Parameters localesBCP 47 language taglanguage[-script][-region]*(-variant)*(-extension)[-privateuse]“en-US”, “en-CA”, “tlh-Kore-AQ-fonipa”, “ja-JP”, “zh-Hans-CN”, etc. Optionsstyle: “currency”, “percent”, “decimal”(default)currency: Current currency &amp; funds code list“USD”, “EUR”, “KRW”, “JPY”, “CNY”, etc.etc options. Checking for support1234567const isSupportToLocaleString = () =&gt; !!(Intl &amp;&amp; typeof Intl === \"object\" &amp;&amp; typeof Intl.NumberFormat === \"function\");if(isSupportToLocaleString()) &#123; // if support toLocaleString() // blahblah...&#125; else &#123; // if not support toLoacleString() // blahblah...&#125; Usage12345678const num = 123456.789;console.log(num.toLocaleString(\"en-US\")); // \"123.456.789\"console.log(num.toLocaleString(\"zh-Hans-CN-u-nu-hanidec\")); // \"一二三,四五六.七八九\"console.log(num.toLocaleString(\"en-US\", &#123;style: \"currency\", currency: \"USD\"&#125;)); // \"$123,456.79\"console.log(num.toLocaleString(\"en-UK\", &#123;style: \"currency\", currency: \"EUR\"&#125;)); // \"€123,456.79\"console.log(num.toLocaleString(\"tlh-Kore-AQ-fonipa\", &#123;style: \"currency\", currency: \"KRW\"&#125;)); // \"₩123,457\"console.log(num.toLocaleString(\"ja-JP\", &#123;style: \"currency\", currency: \"JPY\"&#125;)); // \"￥123,457\"console.log(num.toLocaleString(\"zh-Hans-CN\", &#123;style: \"currency\", currency: \"CNY\"&#125;)); // \"￥123,456.79\" Number 함수 함수 생성자 함수Syntax1Number(value); Parametervalue: 어떠한 데이터 타입의 값도 올 수 있다. Usage매개변수로 넘긴 값들을 숫자로 바꿀 때 사용한다. Example123456789101112console.log(Number(\"11\")); // 11console.log(Number(\"11.11\")); // 11.11console.log(Number(\"11A\")); // NaNconsole.log(Number(\"A11\")); // NaNconsole.log(Number(\"11A1\")); // NaNconsole.log(Number(\"11.A\")); // NaNconsole.log(Number(\"011\")); // 11console.log(Number(true)); // 1console.log(Number(new Date())); // 1481186433309console.log(Number([0, 1])); // NaNconsole.log(Number(&#123;a: \"b\"&#125;)); // NaNconsole.log(Number(11)); // 11 생성자Syntax1new Number(value); Parametervalue: 어떠한 데이터 타입의 값도 올 수 있다. Structure123const objNum = new Number(11);console.log(typeof objNum); // \"object\"console.dir(objNum); __proto__12const objNum = new Number(11);console.log(Number.prototype === objNum.__proto__); // true 숫자의 래퍼 객체(Number)에서 미리 정의해놓은 프로퍼티(prototype)이다.이 프로퍼티에는 숫자의 표준 메소드와 프로퍼티가 정의돼있다.숫자 객체의 인스턴스(new Number())는 숫자 래퍼 객체(Number)로부터prototype 프로퍼티를 __proto__라는 이름으로 상속받는다. NecessityThe Secret Life of JavaScript PrimitivesES에서 숫자 원시값의 프로퍼티와 메소드를 사용할 때 내부 동작 원리는 아래와 같다.123456789// 우리가 알던 방식대로 메소드 사용해보자.11.1.toString(); // \"11.1\";/* * Number.prototype.toString() 메소드를 쓰기 위해서 * 원시값인 11.1을 Number 객체로 바꿔줘야한다. * 따라서 위 내용은 아래와 같이 자동으로 동작하게 된다. */new Number(11.1).toString(); // 11.1 Number ↔ String123456const num1 = \"10\";const num2 = \"10\";const sum = num1 + num2; // \"1010\"const sub = num1 - num2; // 0const mul = num1 * num2; // 100const div = num1 / num2; // 1 String to Number Number.parseInt(string[, radix]) Number.parseFloat(string) new Number(string).valueOf() Number() +string, 1*string Number.parseInt(str[, radix])12345678910console.log(Number.parseInt(\"11\")); // 11console.log(Number.parseInt(\"11.11\")); // 11console.log(Number.parseInt(\"11A\")); // 11console.log(Number.parseInt(\"A11\")); // NaNconsole.log(Number.parseInt(\"11A1\")); // 11console.log(Number.parseInt(\"11.A\")); // 11console.log(Number.parseInt(\"011\")); // 11console.log(Number.parseInt(\"11 0\")); // 11console.log(Number.parseInt(\"0b11\")); // 0console.log(Number.parseInt(\"0o11\")); // 0 Number.parseFloat(str)12345678910console.log(Number.parseFloat(\"11\")); // 11console.log(Number.parseFloat(\"11.11\")); // 11.11console.log(Number.parseFloat(\"11A\")); // 11console.log(Number.parseFloat(\"A11\")); // NaNconsole.log(Number.parseFloat(\"11A1\")); // 11console.log(Number.parseFloat(\"11.A\")); // 11console.log(Number.parseFloat(\"011\")); // 11console.log(Number.parseFloat(\"11 0\")); // 11console.log(Number.parseFloat(\"0b11\")); // 0console.log(Number.parseFloat(\"0o11\")); // 0 new Number(string).valueOf()12345678910console.log(new Number(\"11\").valueOf()); // 11console.log(new Number(\"11.11\").valueOf()); // 11.11console.log(new Number(\"11A\").valueOf()); // NaNconsole.log(new Number(\"A11\").valueOf()); // NaNconsole.log(new Number(\"11A1\").valueOf()); // NaNconsole.log(new Number(\"11.A\").valueOf()); // NaNconsole.log(new Number(\"011\").valueOf()); // 11console.log(new Number(\"11 0\").valueOf()); // NaNconsole.log(new Number(\"0b11\").valueOf()); // 3console.log(new Number(\"0o11\").valueOf()); // 9 Number(string)123456789console.log(Number(\"11\")); // 11console.log(Number(\"11.11\")); // 11.11console.log(Number(\"11A\")); // NaNconsole.log(Number(\"A11\")); // NaNconsole.log(Number(\"11A1\")); // NaNconsole.log(Number(\"11.A\")); // NaNconsole.log(Number(\"011\")); // 11console.log(Number(\"0b11\")); // 3console.log(Number(\"0o11\")); // 9 +string, 1*string123456789console.log(+\"11\"); // 11console.log(+\"11.11\"); // 11.11console.log(+\"11A\"); // NaNconsole.log(+\"A11\"); // NaNconsole.log(+\"11A1\"); // NaNconsole.log(+\"11.A\"); // NaNconsole.log(+\"011\"); // 11console.log(+\"0b11\"); // 3console.log(+\"0o11\"); // 9 Performance123456789101112131415161718192021222324252627282930313233343536const iterations = 10000000;console.time(\"Number.parseInt()\");for(let i=0; i&lt;iterations; i++)&#123; Number.parseInt(\"1.1\"); // Number.parseInt(): 561.062ms&#125;console.timeEnd(\"Number.parseInt()\");console.time(\"Number.parseInt() with radix\");for(let i=0; i&lt;iterations; i++)&#123; Number.parseInt(\"1.1\", 10); // Number.parseInt() with radix: 511.062ms&#125;console.timeEnd(\"Number.parseInt() with radix\");console.time(\"Number.parseFloat()\");for(let i=0; i&lt;iterations; i++)&#123; Number.parseFloat(\"1.1\"); // Number.parseFloat(): 737.437ms&#125;console.timeEnd(\"Number.parseFloat()\");console.time(\"new Number().valueOf()\");for(let i=0; i&lt;iterations; i++)&#123; new Number(\"1.1\").valueOf(); // new Number().valueOf(): 1112.782ms&#125;console.timeEnd(\"new Number().valueOf()\");console.time(\"Number()\");for(let i=0; i&lt;iterations; i++)&#123; Number(\"1.1\"); // Number(): 1066.577ms&#125;console.timeEnd(\"Number()\");console.time(\"+string\");for(let i=0; i&lt;iterations; i++)&#123; +\"1.1\"; // +string: 20.724ms&#125;console.timeEnd(\"+string\");console.time(\"1*string\");for(let i=0; i&lt;iterations; i++)&#123; 1*\"1.1\"; // 1*string: 21.459ms&#125;console.timeEnd(\"1*string\"); Number to String Number.prototype.toString() String(number) “” + number Number.prototype.toString()1234567console.log(1.1.toString()); // \"1.1\"console.log(1.0.toString()); // \"1\"console.log(0b11.toString()); // \"3\"console.log(NaN.toString()); // \"NaN\"console.log(Infinity.toString()); // \"Infinity\"console.log(-Infinity.toString()); // -Infinityconsole.log(0.0.toString()); // \"0\" String(number)1234567console.log(String(1.1)); // \"1.1\"console.log(String(1)); // \"1\"console.log(String(0b11)); // \"3\"console.log(String(NaN)); // \"NaN\"console.log(String(Infinity)); // \"Infinity\"console.log(String(-Infinity)); // \"-Infinity\"console.log(String(0)); // \"0\" “” + number1234567console.log(\"\" + 1.1); // \"1.1\"console.log(\"\" + 1); // \"1\"console.log(\"\" + 0b11); // \"3\"console.log(\"\" + NaN); // \"NaN\"console.log(\"\" + Infinity); // \"Infinity\"console.log(\"\" + -Infinity); // \"-Infinity\"console.log(\"\" + 0); // \"0\" Performance12345678910111213141516const iterations = 10000000;console.time(\"Number.prototype.toString()\");for(let i=0; i&lt;iterations; i++)&#123; 1.1.toString(); // Number.prototype.toString(): 268.619ms&#125;console.timeEnd(\"Number.prototype.toString()\");console.time(\"String(number)\");for(let i=0; i&lt;iterations; i++)&#123; String(1.1); // String(): 159.045ms&#125;console.timeEnd(\"String(number)\");console.time(\"\\\"\\\" + number\");for(let i=0; i&lt;iterations; i++)&#123; \"\" + 1.1; // \"\" + number: 20.594ms&#125;console.timeEnd(\"\\\"\\\" + number\");","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"Number","slug":"Number","permalink":"http://perfectacle.github.io/tags/Number/"}]},{"title":"(ES6) 숫자형","slug":"ES6-Number-type","date":"2016-12-22T16:37:53.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2016/12/23/ES6-Number-type/","link":"","permalink":"http://perfectacle.github.io/2016/12/23/ES6-Number-type/","excerpt":"","text":"이 글을 읽고 (ES6) Number 객체와 함수를 이어서 보는 걸 추천한다. 자료형ES에서 숫자형은 단 하나의 자료형 뿐이다.Double: 자바나 C 등등의 언어에서 실수를 표현하기 위한 자료형, 8Byte = 64BitDouble-precision floating-point format 부호(sign)를 표현하기 위한 1비트 (+, -) 지수부(exponent part)를 표현하기 위한 11비트 가수부(fraction part)를 표현하기 위한 52비트 유효 범위: -(253-1) ~ 253-11234console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991console.log(-(Math.pow(2, 53) - 1)); // -9007199254740991console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991console.log(Math.pow(2, 53) - 1); // 9007199254740991 즉 ES에서 정수형(Integer)은 존재하지 않는다.모든 숫자는 부동 소수점(Floating Point) 형태로 표현되는 실수(Real Number)이다.실수는 소수 표현이 가능하고, 실수를 표현하는 방법으로 고정 소수점(Fixed Point)와부동 소수점(Floating Point)이 있으니 직접 찾아보길 바란다.12console.log(1 === 1.0); // trueconsole.log(1 .toString() === 1.0.toString()); // true 문제점 실수 계산 12console.log(.1 + .2); // 0.30000000000000004console.log(0.1 + 0.2 === 0.3); // false ES에서는 위와 같이 소수점 계산에서 고질적인 문제를 안고 있다.이는 아마 IEEE에서 제정한 부동소수점 표현 형식인 IEE754의 고질적인 문제라고 보여진다.실수 표현 문제 발생 이유 or 오차 발생 이유 자바스크립트의 숫자는 십진 부동 소수점 숫자로 접근하는데 반해 그 내부 동작 원리는 이진 부동 소수점 숫자이기 때문에 오차가 발생한다.원문 보기JavaScript’s numbers are usually entered as decimal floating-point numbers,but they are internally represented as binary floating-point numbers.That leads to imprecision. 위와 같은 문제는 IEE754를 사용하는 Java에서도 동일하게 발생한다.123456public class test &#123; public static void main(String[] args) &#123; System.out.println(0.1 + 0.2); // 0.30000000000000004 System.out.println(0.3 == 0.1+0.2); // false &#125;&#125; 이를 위한 해결방안으로 Number.EPSILON이 나왔다. 신뢰할 수 없는 범위 부동 소수점에 대한 이해수의 표현범위가 다른 int와 float, 그리고 신뢰할 수 없는 부동소수점12console.log(-9007199254740992 === -9007199254740993); // trueconsole.log(9007199254740992 === 9007199254740993); // true 부동 소수점의 단점은 일정 범위를 넘어가면 계산의 결과를 신뢰할 수 없다는 점이다.ES에서 쓰이는 숫자형에서 신뢰할 수 있는 범위는 위에 적어논 바와 같다. 123// \"-9007199254740991 ~ 9007199254740991\"console.log(-(Math.pow(2, 53) - 1) + ' ~ ' + (Math.pow(2, 53) - 1));console.log(Number.MIN_SAFE_INTEGER + ' ~ ' + Number.MAX_SAFE_INTEGER); 특수한 숫자들또한 숫자형에서는 특수한 네 가지 값이 존재한다. NaN(Not a Number) (+)Infinity -Infinity -0(Negative Zero) 1234567console.log(1 / \"A\"); // NaNconsole.log(Number.MAX_VALUE + 1e+291); // 1.7976931348623157e+308console.log(Number.MAX_VALUE + 1e+292); // Infinityconsole.log(Number.MAX_VALUE / -0.5); // -Infinityconsole.log(Number.MAX_VALUE * 1.000000000000001); // Infinityconsole.log(Number.MAX_VALUE * 1.0000000000000001); // 1.7976931348623157e+308console.log(1.0000000000000001 === 1); // true 음수 0+0과 -0은 같다??123456789console.log(0 == -0); // trueconsole.log(0 === -0); // trueconsole.log(0 != -0); // falseconsole.log(0 !== -0); // falseconsole.log(0 &lt; -0); // falseconsole.log(0 &gt; -0); // falseconsole.log(\"\" + -0); // \"0\"console.log(String(-0)); // \"0\"console.log(JSON.stringify(-0)); // \"0\" 하지만 아래 현상은 어떻게 설명할 수 있을까?123456789101112console.log(1 / 0); // Infinityconsole.log(1 / -0); // -Infinityconsole.log(Infinity === -Infinity); // falseconsole.log(-0.0.toString()); // -0console.log(-0 .toString()); // -0console.log(-.0.toString()); // -0console.log(+\"-0\"); // -0console.log(Number(\"-0\")); // -0console.log(JSON.parse(\"-0\")); // -0console.log(Math.max(-0, 0)); // 0console.log(Math.min(-0, 0)); // -0console.log(Object.is(0, -0)); // false 필요성You Don’t Know JS: Types &amp; Grammar - Zeros스피드나 x, y와 같은 방향 같은 요소를 쓰는 어플리케이션에서 만약 -0이 0으로 바뀐다면,속도나 방향 등등의 정보를 잃게될 것이다. There are certain applications where developers use the magnitude of a value to represent one piece of information (like speed of movement per animation frame) and the sign of that number to represent another piece of information (like the direction of that movement).In those applications, as one example, if a variable arrives at zero and it loses its sign, then you would lose the information of what direction it was moving in before it arrived at zero. Preserving the sign of the zero prevents potentially unwanted information loss.` 진수 리터럴2진수수학식: 11(2)기타 프로그래밍 언어: 0b11, 0B11 in ES1console.log(parseInt('11', 2)); // 3 in ES612console.log(0b11); // 3console.log(0B11); // 3 8진수수학식: 71(8)기타 프로그래밍 언어: 071 in ES1console.log(071); // 57 in strict mode12'use strict';console.log(071); // Uncaught SyntaxError: Octal literals are not allowed in strict mode. ES5의 strict mode에서는 8진수 리터럴이 적용되지 않는다.왜냐하면 ES5에는 8진수 문법이 존재하지 않기 때문이다.그럼에도 불구하고 브라우저 벤더들은 비표준 요소인 8진수 리터럴을 지원하게끔 구현하였다.따라서 strict mode에 따라서 8진수 리터럴의 사용 가능 여부가 달려있다. MDN Strict mode strict mode in ECMAScript 5 forbids octal syntax.Octal syntax isn’t part of ECMAScript 5,but it’s supported in all browsers by prefixing the octal number with a zero:0644 === 420 and “\\045” === “%”.` in ES612console.log(0o71); // 57console.log(0O71); // 57 16진수수학식: FF(16)기타 프로그래밍 언어: 0xFF, xFF, hFF, etc. in ES1234console.log(0xff); // 255console.log(0Xff); // 255console.log(0xA); // 10console.log(0XA); // 10 주의사항1console.log(0b11.1); // Uncaught SyntaxError: missing ) after argument list 10진수를 제외한 진수 리터럴은 정수만 표현 가능하다..을 붙인다고 해서 실수가 되는 게 아니라 Number.prototype.1로 접근을 하게 된다.10진수의 경우에는 실수 취급한다. 123Number.prototype.Aa = 'Aa';console.log(0b11.Aa); // 'Aa'1.Aa; // Uncaught SyntaxError: Invalid or unexpected token","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"Number","slug":"Number","permalink":"http://perfectacle.github.io/tags/Number/"}]},{"title":"JetBrains 회사 제품의 라이센스","slug":"JetBrains-License","date":"2016-12-18T13:01:28.000Z","updated":"2017-02-09T13:24:07.000Z","comments":true,"path":"2016/12/18/JetBrains-License/","link":"","permalink":"http://perfectacle.github.io/2016/12/18/JetBrains-License/","excerpt":"","text":"여름방학에 현장실습을 하면서 다음과 같은 경험을 했다. A: 권성 씨, 에디터 좋다. 뭐 써요?나: 저 웹스톰이요. 저희 학교는 교직원에게만 이메일을 줘서 친구 걸로 인증했어요.A: 뭐 같은 대학생이니까 상관 없으려나…(잠시 후…)A: 어, 웹스톰은 기업용이 아니면 기업에서는 쓰면 안 된다고 하는데요?나: (나니?!) 국내 유통 업체에서 팔고있는 웹스톰 개인용 라이센스&nbsp;내가 느끼기에는 ‘개인용’이란 단어를 교묘하게‘가정용/학생용’이라는 단어로 바꿔치운 상술로 밖에 보이지 않았다.이 당시에는 서로 바빠서 그냥 무시하고 웹스톰을 계속 썼었는데,나중에 취직을 하게 되면 계속 써야할텐데 그 비싼 기업용 라이센스를사야하나 싶어서 이번에 집중적으로 알아보았다. 개인용 라이센스를 기업에서도 쓸 수 있는가?&nbsp;Can I use my personal license at work and at home?Yes, you can use your personal license at work as well as at home. You can use it working on your personal projects as well as projects of your company. Our EULAs do not restrict this.그냥 써도 된다는 소리다.&nbsp;Can I use my personal license for commercial development?Yes, you can use your license for any kind of development. However, only you may use your personal license; you may not share it with others.직관적으로 상업용 개발을 하는데 개인용 라이센스를 써도 되느냐?Yes, 하지만 타인과 공유는 하지 말란다.&nbsp; 개인용 라이센스를 데스크탑과 랩탑에 동시에 설치해도 되는가?&nbsp;Can I use my personal license on multiple machines?You may install the product on multiple machines and multiple OS’s. However, please note, that our licenses do not allow concurrent connections. This means that the license may only be used on one machine at a time.다수의 컴퓨터와 다수의 OS에 설치 해도 되지만 동시에 사용하지 말라고 하는데…무슨 탐지 기술이라도 있나 싶어서 다른 글을 더 찾아보니…&nbsp;Using IDE on different machines and operating systems with the same licenseHowever, IDE checks for the number of running copies on the local network when starting. In case it finds any copies started with the same license, they are all shut down except the last one.로컬 네트워크(같은 공유기에 물려있는 경우)에 동일한 라이센스의 IDE가 감지된 경우마지막에 실행된 IDE를 빼고 종료를 시킨다고 한다.그럼 전 세계의 만날 일 없는 개발자들과 공유하면… 양심에 맡기자.&nbsp; 개인용 라이센스와 기업용 라이센스는 무슨 차이인가?&nbsp;What is the difference between commercial and personal licenses?A Commercial license is the standard licensing option for organizations and business entities. Licenses are purchased by the company and can be used by any person within this organization.기업용(상업용, Commercial) 라이센스는 기업이나 기관에서 살 수 있으며,즉 개인이 기업용 라이센스를 사는 것은 불가능하며,해당 기업과 기관에 속한 조직원이라면 누구나 해당 라이센스를 쓸 수 있다.&nbsp;A Personal license is an option for private individuals who purchase a license with their own funds, and solely for their own use. Personal licenses are not to be purchased, refunded or in any way financed by companies.개인용 라이센스는 개인이 살 수 있으며,즉 기업이 개인용 라이센스를 사주는 것은 불가능하다.&nbsp;위 사항만 보면 아래와 같은 사항에 대해 어떠한 차이점이 존재하는지 의문점이 생긴다.개인용 라이센스를 개인이 사서 개인이 회사에서 작업하나기업용 라이센스를 기업이 사서 개인이 회사에서 작업하나Commercial vs Personal software licensesFor Jetbrains, the corporate license is a license that’s not linked to an individual. The personal license is linked to a specific person.What that means inside a company is that if you buy a corporate license for 10 users, any 10 people can use the product at any given time.If however you buy 10 personal licenses, only the 10 specific people who are mentioned can ever use the product. Were one of them to leave the company, that license becomes useless (though they might have a means to get the license transfered to another person, you’d have to contact Jetbrains about that).허접한 영어 실력으로 해석해보자면기업용 라이센스는 몇 명의 유저가 쓸 수 있는지에 따라서 가격이 달라지는 것 같다.위에서 구매한 유저 인원수에 따라 로컬 네트워크에 동시 사용을 제한하는 것 같다.만약 조직 구성원 중 한 명이 떠나면 새로운 개발자에게 기업용 라이센스가 위임되는 것 같다.마지막으로 기업용 라이센스를 가진 개인이 집에서 작업을 할 수 있는가?라는 의문이 들었다.Can I use a commercial license purchased by my company at home?We, in our EULAs, do not prohibit using commercial licenses of your company at home.However, please inquire your employer about it as this may vary depending on your company’s policies.사용해도 된다는 소리 같은데, 두 번째 문장을 Young Gratia 님께서 친히 번역해주셨다.회사 정책에 따라 달라질 수 있으니, 사용 전에 고용주에게 문의해보라는 내용이다.&nbsp; 학생용 라이센스는 개인용 라이센스와 동일한가?이 부분에 있어서는 참 질문이 많았다.링크에 접속이 되지 않아 직접 주고받은 메일의 pdf 파일을 직접 첨부한다.질문 메일답변 메일&nbsp; 나는 대학생인데 우리 학교는 교직원을 제외하고는 이메일이 제공되지 않는다.그래서 친구의 대학 이메일을 빌려서 인증하여 사용 중인데, 이는 유효한 라이센스인가?&nbsp;You will not need a university email address, it is only necessary to upload an official document showing you are currently a student (you have an option “official document”).이메일 주소 필요없이 내가 현재 대학생이라는사실을 입증할 수 있는 공식적인 서류만 보내면 된단다.즉 현재 대학생이라 하더라도 나같이 타인의 이메일을 빌려학생 라이센스를 취득한 경우 유효하지 않다.&nbsp; 학생용 라이센스를 가지고 기업에서도 사용할 수 있는가?&nbsp;The free student license cannot be used at work for commercial purposes. It is only intended for learning, educational purposes.무료 학생용 라이센스는 상업적 목적인 작업에서는 쓰일 수 없단다.기업에서는 상업적이지 않을 수가 없으므로 즉 기업에서는 못 쓴다고 보면 된다.학생용 라이센스는 오직 학습과 교육을 위해서만 쓰여야한다.&nbsp; 학생용 라이센스 인증 기간 도중에 졸업을 하는 경우, 남은 기간동안도 유효한가?&nbsp;나의 영어 실력이 미흡하여 질문의 의도를 파악하지 못하고,졸업생들에게 할인을 해주는 제도에 대해 설명을 하였다.만약 졸업 후에 학생용 라이센스 기간이 몇 달 남았다면 집에서만 조용히 쓰도록 하자.&nbsp; 대학교 졸업 후에도 이메일이 사라지지 않는 경우, 계속 사용하는 것이 유효한가?&nbsp;이 역시 나의 영어 실력이 미흡하여 제대로된 답변을 받지 못했으나다음의 링크를 보고 답을 얻게 되었다.&nbsp;Free for students: Professional developer tools from JetBrainsIs a free Student License perpetual?No, the Student License is valid for one year and perpetual licenses are not provided. After one year you will need to renew your Student License for the next year, or purchase a license if you’re no longer a student.마지막 or 부분부터 해석하자면만약 더이상 학생이 아닌 경우에는 구매하라고 한다.즉 대학교 이메일이 졸업후에도 사라지지 않더라도 본인이 학생이 아니라면그 라이센스는 유효하지 않다.만약 사용 가능하다면 집안에서만 조용히 써야할 것이다. 다른 제품들의 라이센스에 있어서도 상술에 찌든 국내 유통 업체보다는해석하기 어렵지만 보다 정확하고 정직한 공식 사이트의 문서들을 참조해야겠다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://perfectacle.github.io/tags/IDE/"},{"name":"Editor","slug":"Editor","permalink":"http://perfectacle.github.io/tags/Editor/"},{"name":"JetBrains","slug":"JetBrains","permalink":"http://perfectacle.github.io/tags/JetBrains/"},{"name":"WebStorm","slug":"WebStorm","permalink":"http://perfectacle.github.io/tags/WebStorm/"},{"name":"PhpStorm","slug":"PhpStorm","permalink":"http://perfectacle.github.io/tags/PhpStorm/"},{"name":"IntelliJ","slug":"IntelliJ","permalink":"http://perfectacle.github.io/tags/IntelliJ/"}]},{"title":"CDN 무료 호스팅하기","slug":"CDN-Free-Hosting","date":"2016-11-28T10:54:03.000Z","updated":"2017-02-09T13:24:07.000Z","comments":true,"path":"2016/11/28/CDN-Free-Hosting/","link":"","permalink":"http://perfectacle.github.io/2016/11/28/CDN-Free-Hosting/","excerpt":"","text":"남들의 사랑과 관심이 고파서 라이브러리를 CDN 호스팅 업체에 등록하고자 며 칠 간 고생했던 내용을 적어봤다.CDN에 대해서는 구글링하면 많이 나오는데 CDN은 각 지역 별로 서버를 두는 서비스 형식으로 대충 알고있다.국내 무료 호스팅 업체에 그냥 나의 라이브러리를 업로드해도 되지만 일정 기간마다 서비스를 연장하거나 트래픽 등등의 문제가 존재하였다.그리고 제이쿼리나 부트스트랩 등등의 프레임워크&amp;라이브러리들이 외국 CDN 호스팅 업체에 등록된 걸 보면 뭔가 동경의 대상이었다.나의 라이브러리도 한 번 그렇게 만들어 보고 싶었다.뭔가 좋아보인다 싶으면 따라하는 게 나의 단점이지만 그래도 해보고 싶었다. maxCDN cdnjs jsdelivr&nbsp;혼자서 깃헙 문서를 보고 따라할 사람은 아래 링크로 들어가면 된다.https://github.com/jsdelivr/jsdelivr/blob/master/CONTRIBUTING.md&nbsp;준비사항: 라이브러리가 올라가 있는 본인의 깃헙 저장소.그리고 그 깃헙 저장소에 태그가 있어야한다.태그가 뭔지 모르는 사람은 아래 링크를 참조하자.http://www.whatwant.com/377&nbsp;그 이후에 아래 링크로 접속한다.https://github.com/jsdelivr/jsdelivr/tree/master/files 12345author = &quot;name of lib author&quot;github = &quot;https://github.com/user_id/repository&quot;homepage = &quot;없으면 그냥 깃헙 저장소 주소 입력해도 되고, npm 주소 입력해도 됨.&quot;description = &quot;설명&quot;mainfile = &quot;lib.min.js&quot; 12345678910// 패키지 매니저에는 npm이라고 입력해도 되는 것 같다.// files에는 호스팅 될 파일을 입력하면 된다.&#123; &quot;packageManager&quot;: &quot;github&quot;, &quot;name&quot;: &quot;lib-name&quot;, &quot;repo&quot;: &quot;user_id/lib-name&quot;, &quot;files&quot;: &#123; &quot;include&quot;: [&quot;lib-name.js&quot;, &quot;lib-name.min.js&quot;] &#125;&#125; 예제 작성을 위해 한글을 썼더니 ascii 케릭터로만 적으라는 오류를 뿜는다.하단의 Close pull request를 눌러서 취소 시키고, 오류를 수정한 후 다시 풀리퀘를 날리면 된다.감격의 순간이다 흑흑흑…버전 별로 호스팅이 되어있고, unminify, minify한 js 파일 모두 다 호스팅 되었다.세상 어딘가에 나의 발자취를 남긴 것 같아 굉장히 뿌듯하다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://perfectacle.github.io/tags/CDN/"},{"name":"Hosting","slug":"Hosting","permalink":"http://perfectacle.github.io/tags/Hosting/"}]},{"title":"(ES) 정규표현식 응용하기","slug":"ES-RegExp-ex","date":"2016-11-27T14:14:30.000Z","updated":"2017-02-09T13:24:07.000Z","comments":true,"path":"2016/11/27/ES-RegExp-ex/","link":"","permalink":"http://perfectacle.github.io/2016/11/27/ES-RegExp-ex/","excerpt":"","text":"이 포스트는 정규표현식에 대한 기초 사항을 설명하진 않는다.대신 다양한 케이스와 테스트 하는 방법 등등에 대해 포커스를 맞춘다.정규표현식의 기초에 대해 궁금한 사람들은 아래 링크를 참조하길 바란다.http://www.nextree.co.kr/p4327/정규표현식을 책의 목차의 제일 마지막에 있는 것을 보아 가장 어려운 내용인 줄 알았는데,안 어렵다. 쉽다.클로저, 콜백 등등의 개념을 몰라도 당장 익히는데 전혀 무리가 없다.그리고 안 써먹으면 까먹는다. 당연하다.필자도 쓸 때마다 찾아봐서 테스트하지, 그렇다 해도 시간이 절대 오래 걸리지 않는다.필요한 내용만 찾아서 쓰고 테스트하면 되고, 도움을 주는 여러가지 것들이 많으니 당장 배워보길 바란다.또한 다른 프로그래밍 언어에서도 조금씩 다른 형태로 지원하니 알아두면 좋다. 목차 정규표현식은 왜 쓸까 테스트해보기 응용하기 and의 원리 파악하기 정규표현식은 왜 쓸까?정규표현식은 문자열을 가지고 놀 때 쓴다.정규표현식을 쓰지 않아도 되지만 코드를 줄이기 위해서 사용한다.아래 코드를 봐보자.12345678910111213141516var gender = 'M';// case 1.if(gender.indexOf('m') &gt; -1 || gender.indexOf('M') &gt; -1) &#123; // 블라블라...&#125;// case 2.if(gender.toLowerCase().indexOf('m') &gt; -1) &#123; // 블라블라...&#125;// case 3.if(/m/i.test(gender)) &#123; // 블라블라...&#125; 3번 케이스가 정규표현식을 사용한 경우이다.이렇듯 정규표현식은 꼭 쓰지 않아도 되지만 코드의 길이를 확연하게 줄여주기도 한다. 테스트해보기테스트 해보려고 일일이 콘솔창에 찍는 방법이 있지만 귀찮다.정규표현식 테스트를 지원하는 에디터도 있지만, 그런 것에 구애받지 않고 테스트 하는 방법을 소개한다.아래 사이트로 접속해보자.http://regexr.com/ 설명이 필요 없을 정도로 사용 방법은 쉽다.좌측 메뉴를 적극 활용하면 자신이 원하는 케이스들을 쉽게 찾을 수 있다. 응용하기이제부터는 다양한 사례를 통해 어떻게 응용해야할지 알아보자. 끝말잇기 한방 단어 금지시키기사용 기법: not whitespace → \\S, one or more → +, character set → [슘륨녘]끝말잇기를 하다보면 한방 단어로 끝낼 때가 있다.한 판이면 상관 없지만 매번 똑같이 당하면 아주 짜증나기 마련이다.특히 륨, 늄, 슘 등등으로 끝나는 화학 원소 기호들…슘페터란 인물이 있지만, 막는 건 한 번에 불과하다.이를 위한 정규표현식을 작성해보자. 가나다 순으로 구분하기사용 기법: range → [다-딯], one or more → +알파벳과 다르게 가나다 순에서 가는 가, 갸, 거, 겨 등등 가 하나만 놓고 봐도 매우 많다.단어장을 만든다 할 때 정규표현식 없이 구분하려면 if문의 도가니에 빠지게 될 것이다.단어 뒤에 공백(스페이스바, 탭, 엔터키)가 아닌 경우에는 \\S를 쓰면 안 된다.if 문을 써서 다로 시작하는 단어, 도로 시작하는 단어, 대로 시작하는 단어, …이 모든 케이스들을 구분한다면 상당한 삽질이 예상된다. 몇 학년인지 구하기사용 기법: Digit → \\d, one or more → +, positive lookahead → (?=학년)이는 몇 학년인지, 몇 반인지, 몇 동에 사는지 등등구하려는 정보가 특정 접미어 앞에 존재할 때 유용하다. 학번 구하기사용 기법: capturing → (\\d+), Digit → \\d, one or more → +이번에는 구하려는 정보가 특정 접두어 뒤에 뒤에 존재하는 정보를 구하려 한다.어쩔 수 없이 트릭을 써야한다. 출처는 아래 링크다.Positive look behind in JavaScript regular expression테스트 하려면 사이트가 아닌 콘솔 창 등등에서 테스트해야만 한다. 123var str = '양권성 간장대학교 3학년 학번: 20120012';var regExp = /학번: (\\d+)/;console.log(str.match(regExp)[1]); // '20120012' 삼둥이 중에 둘 째 찾기사용 기법: capturing → (.+), any character except line breaks → ., one or more → +이제는 접두어와 접미어 사이에 낀 녀석을 찾아보자.어… 예제가 적절치 않은데 그냥 이런 것도 있다고 생각하고 나중에 참고하면 될 것 같다.이번에도 테스트 하려면 사이트가 아닌 콘솔 창 등등에서 테스트해야만 한다.전국에 삼둥이는 참 많다.그 중에 첫 째는 대한이, 셋 째는 만세, 둘 째는…?둘 째의 이름을 구해보자! 12345const name = `대한, 민국, 만세대한, 간장, 짱짱조선, 민국, 만세`;const regExp = /대한, (.+), 만세/;console.log(name.match(regExp)[1]); // 민국 스팸 단어 정하기사용 기법: capturing → (도박|마카오|카지노), or → |스팸 게시물은 언제나 골칫거리다.이를 약간이라도 줄이고자 필터링을 하는 방법으로 정규표현식이 많이 쓰인다. 비밀번호의 강도 높이기요즘 크래커들의 크래킹 수준은 날이 갈 수록 높아져 비밀번호에 신경을 써야한다.단순히 길다고 해서 끝나는 게 아니라 좀 더 복잡해야한다.기본적으로 알파벳, 숫자, 특수기호가 들어가면서 8자 이상 20자 이하의 비밀번호를 작성해보자.출처는 오래 전이라 까먹었다. 스택 오버플로우였는데… 1/(?=.*[a-z])(?=.*\\d)(?=.*[\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\'\\\"])[a-z\\d\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\'\\\"]&#123;8,20&#125;/ 이상한 외계어가 보인다.그냥 가져다 쓰실 분은 쓰시고, 혹시 여기서 좀 더 보안을 강화하고 싶거나호기심 충만하신 분들만 아래 내용을 보면 될 것 같다. 먼저 이걸 이해하기 전에 정규표현식의 and에 대해 알아야 한다.기본적으로 자바스크립트의 정규표현식에서는 and 연산자가 없다.아래와 같은 편법이 필요하다.regexp logic and or이해를 돕기 위해 정규표현식을 합성해서 공백을 넣었다.(?=)은 접미어 앞에 존재하는 단어를 긁어내는 연산자이다.you 라는 단어 앞에 글자가 0개 이상 있고, I 라는 단어 앞에 글자가 0개 이상 있다.풀어서 쓰면 아래와 같다.1you 앞에 글자 0개 이상 + I 앞에 글자 0개 이상(you를 포함) + 그 뒤에 글자 0개 이상(I를 포함) (?=.*word1)(?=.*word2)와 같은 기법으로 순서가 상관 없는 and를 구현할 수 있다.그리고 어떠한 글자들을 허용할 것인지 .*을 이용하여 표현하였다. 여기까지 이해했다면 이제 위 비밀번호 외계어 정규 표현식을 이해할 수 있다.하나씩 까서 보자. (?=.*[a-z])(?=.*\\d)(?=.*[{}[]\\/?.,;:|)*~`!^-_+&lt;&gt;@#$%&amp;\\\\=(\\’\\”])첫 번째 포함 키워드는 알파벳, 두 번째 포함 키워드는 숫자, 세 번째 포함 키워드는 특수기호특수기호는 입맛에 맞게 더 넣던지 빼던지 하면 된다. [a-z\\d{}[]\\/?.,;:|)*~`!^-_+&lt;&gt;@#$%&amp;\\\\=(\\’\\”]알파벳과 숫자, 특수기호의 입력을 허용 {8, 20}8자 이상 20자 이하 이를 다 조합해보면알파벳, 숫자, 특수기호를 무조건 포함해야하며, 순서는 상관 없고,알파벳, 숫자, 특수기호만 허용하고, 8자 이상 20자 이하의 패스워드가 만들어지게 된다. 그럼…알파벳, 숫자는 무조건 포함하면서 특수기호는 입력 해도 그만 안 해도 그만인 정규표현식은 어떻게 만들면 될까?댓글 유도 및 방문자 여러분에게 질문을 던져본다. and의 원리 파악하기호기심이 멈추지 않아 and를 왜 (?=.*word1)(?=.*word2)와 같이 구현한 건지 파보았다.머리가 돌아가지 않아 순전히 노가다였다. 우선 word1이라는 단어가 포함되게 하려면 위와 같이 작성하여야 한다. word1이란 단어 앞에 있는 패턴만 얻고 싶을 때 /패턴(?=word1)/을 쓴다.하지만 정규표현식을 보면 (?=word1)앞에 아무런 패턴이 없다.따라서 (?=word1)으로 얻어지는 패턴은 word1의 시작 위치이다.그 시작 위치 이후에 .*, 즉 글자가 0개 이상이므로 위와 같이 word1의 시작 지점 이후부터의 문자만 가져온다.두 번째 1word1에서 word1의 앞 부분인 1은 얻어오질 못하는 것이다. @+word1의 정보까지 얻어오려면 위와 같이 .*을 붙여줘야한다.그래야 @+word1이 시작하는 위치를 얻어와서 1word1도 정상적으로 인식한다. 이 경우에는 왜 아무것도 못 얻어오는지 보자.(?=word1)로 word1이 시작하는 위치를 얻어왔다. 저 위치에서 (?=word2)가 실행이 된다.저 위치에선 word2 앞에 있는 정보를 얻어올 수 없다.word1이 가로막고 있기 때문이다. (?=word2)를 (?=.*word2)로 바꿔줘야 (?=word1)가 반환한 위치로 가도가로막히지 않고 제대로 정보를 얻어올 수 있다. 마지막 케이스는 word1이 없으므로 반환하는 위치가 없다.처음에 .*을 붙여버리면 각 라인 별 빨간 박스로 표시해둔 .*word1의 정보까지 받아오는 것 같다. (?=.*word1)을 수행한 후에 빨간색 박스친 정보를 가지고 있다.그 이후에 (?=.*word2)를 수행하면 word2가 시작되는 파란색 화살표 위치로 이동하게 된다.그 이후에 .*이 실행되서 하늘색 결과를 얻어올 수 있다. 먼저 (?=.*word1)이 시작하는 위치와 정보를 저렇게 받아온다. 먼저 (?=.*word2)이 시작하는 위치는 (?=.*word1)이 시작하는 위치와 같다.그리고 (?=.*word2)이 얻어오는 정보는 파란색 박스와 같다.두 패턴이 얻어온 정보를 짬뽕해서 그 뒤에 .*이 실행되면서 원하는 정보를 얻어온다. 내가 이해한 게 잘 이해한 건지, 설명이 틀리지는 않았는지는 장담하지 못하겠다…넘나 어렵다…그냥 쓰기나 할 걸 괜히 파고 든 것 같다는 생각이 살짜쿵 든다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"RegExp","slug":"RegExp","permalink":"http://perfectacle.github.io/tags/RegExp/"}]},{"title":"(Markdown) 개발자스러운 뱃지","slug":"Markdown-Badge","date":"2016-11-26T14:14:30.000Z","updated":"2017-02-09T13:24:07.000Z","comments":true,"path":"2016/11/26/Markdown-Badge/","link":"","permalink":"http://perfectacle.github.io/2016/11/26/Markdown-Badge/","excerpt":"","text":"이번 포스트는 정말 별 것 없다.마크다운 문법에 대한 설명도 아니고 그냥 좀 더 개발자스러운 이미지들을 써보는 글이다. 목차 뭐가 개발자스러운 뱃지인가? 뱃지를 직접 사용해보자 커스텀 뱃지 만들기 NPM 뱃지 뭐가 개발자스러운 뱃지인가?유명한 라이브러리&amp;프레임워크를 보면 위와 같은 이미지? 스티커?들이 보인다.bower며 npm이며 build 등등의 뱃지가 보인다.이번 포스트에서 소개할 것은 위 사항들을 사용하는 방법에 대해서 배워보자. 뱃지를 직접 사용해보자.우선 http://shields.io/로 접속하자.여기서 나는 내가 npm에 올린 check-browsers라는 라이브러리의 다운로드 수와 버전을 표시하기로 했다. 나는 총 다운로드 수를 표현하고 싶어서 npm의 두 번째 이미지를 클릭하였다. npm 패키지의/dt(다운로드 토탈)/패키지 이름의 형식을 가진다.마크다운 문법에서 사용하려면 그냥 복붙하면 된다. 이번엔 내 패키지의 버전을 표시해보자. npm 패키지의/v(버전)/패키지 이름의 형식을 가진다. 깃헙에서 내 저장소가 따봉 몇 개나 받았는지도 표현할 수 있다. 유저이름/저장소 이름의 형식을 가진다. 이외에 커밋 갯수나 트위터 팔로워 뱃지 등등은 직접 찾아서 사용하면 된다.또한 뱃지는 svg, json, png 포맷을 지원한다. 커스텀 뱃지 만들기커스톰 뱃지의 형태도 나오고 직접 만들어볼 수도 있다. 다양한 파라미터를 통해 스타일, 레이블 등등을 바꿔치기 할 수 있다.이는 커스텀 뱃지나 기존에 만들어져있는 형태의 뱃지에서도 사용이 가능하다. NPM 뱃지NPM 뱃지는 NPM만을 위한 뱃지이다.백문이 불여일견, https://nodei.co/로 접속해보자. npm에 특화된 다양한 뱃지들이 존재한다. 복잡시럽게 읽기 귀찮은 사람들은 간단하게 패키지 이름만 입력하면 다양한 뱃지가 나온다. 좀 더 커스터마이징 하고 싶은 사람들은 해당 페이지를 읽으면 된다.","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"등등","slug":"기타/등등","permalink":"http://perfectacle.github.io/categories/기타/등등/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://perfectacle.github.io/tags/Markdown/"},{"name":"md","slug":"md","permalink":"http://perfectacle.github.io/tags/md/"}]},{"title":"(git) 정리 노트","slug":"git-Reference","date":"2016-11-19T07:55:28.000Z","updated":"2017-08-03T08:31:35.000Z","comments":true,"path":"2016/11/19/git-Reference/","link":"","permalink":"http://perfectacle.github.io/2016/11/19/git-Reference/","excerpt":"","text":"이 포스트는 git을 접하다 보면 마주치는 다양한 상황들에 대해 대처하기 위해 정리한 글이다.Ctrl+F 키를 눌러 원하시는 키워드를 검색하시면 다양한 케이스들을 볼 수 있다.이 문서는 계속해서 업데이트 될 예정이고, 댓글로 제보 해주면 감사할 것 같다 &gt;_&lt;혹시 문제 해결이 되지 않는다면 검색 키워드들을 조합해서 검색해보길 바란다.취소, 되돌아가기, 삭제: undo, reset, remove되돌아가기: revert, retrieve특정: specific미작동: not working .gitignore가 작동하지 않을 때검색 키워드: .gitignore not working123git rm -r --cached .git add .git commit -m &quot;fixed untracked files&quot; 커밋 메시지는 자기 입맛에 맞게 수정하면 된다. 특정 브랜치 클론하기검색 키워드: git specific branch clone1git clone -b &lt;브랜치명&gt; &lt;원격 저장소 주소&gt; &lt;폴더명&gt; 폴더명을 입력하지 않으면 원격 저장소 이름으로 폴더가 생성된다. 특정 커밋 클론하기검색 키워드: git clone specific commit123git clone &lt;원격 저장소 주소&gt; &lt;폴더명&gt;cd &lt;폴더명&gt;git reset --hard &lt;커밋 해시&gt; 한 번에 땡겨오는 명령어는 없는 것 같다. add한 파일 취소시키기검색 키워드: git undo add1git reset &lt;file&gt; 커밋을 하기 전에 add한 파일을 취소시킬 때 유용하다.add한 모든 파일을 취소 시키려면 file을 빼고 입력하면 된다.git status를 찍어보면 untracked 상태로 돌아간 걸 확인할 수 있다. 특정 커밋으로 돌아가기검색 키워드: git reset commit to master123git reset --hard &lt;커밋 해시&gt;// 아래까지 하면 리모트 저장소까지 돌림.git push --force origin master 로컬에서 가장 최근 커밋 삭제검색 키워드: git reset recent commit1git reset HEAD~ git log –oneline을 찍어보면 가장 최근 커밋이 날아간 걸 볼 수 있다. 리모트 저장소 특정 커밋까지 삭제검색 키워드: git undo remote push1git push -f &lt;리모트 저장소 이름&gt; &lt;삭제하기 직전 커밋 해시:브랜치 이름&gt; 삭제하기 직전 커밋까지만 살고 그 이후의 커밋은 날아간다. 워킹 디렉토리 깔끔하게 하기검색 키워드: git reset untracked files1git clean -f -d untracked 파일들이 날아간다.특정 커밋으로 돌아갔을 때 잡다구레한 파일들을 날릴 때 유용하다. 로컬/리모트 브랜치 삭제하기검색 키워드: git remove remote branch12git branch -d branch_namegit push origin :&lt;branch_name&gt; 순서대로 로컬/리모트 저장소에서 브랜치를 삭제하는 명령어이다. Alias123git config --global alias.unstage &quot;reset HEAD --&quot;git unstage fileAgit reset HEAD fileA 첫 번째 라인에서 alias(별칭)을 글로벌로 선언함.2, 3번 라인은 동일함. add와 commit 동시에 하기12git config --global alias.commitx &apos;!git add . &amp;&amp; git commit -a -m &apos;git commitx &quot;커밋 메시지&quot; 명령어 두 개가 혼재돼있을 때는 첫 명령어에 !을 붙여야 정상 작동한다.윈도우에서는 ‘’ 대신에 “”을 써야 작동하는 것 같다add와 commit을 매번하기 귀찮으므로 필자가 자주 쓰는 alias이다. alias 관리12git config --get-regexp aliasgit config --global --unset alias.untage 첫 번째 라인은 alias 목록을 보여주고,두 번째 라인은 alias를 삭제해주는 역할을 한다. commit 메세지에 timestamp 넣기.검색 키워드: git commit message time12git commit -m &quot;`date`&quot;git commit -m &quot;`date +\\&quot;%Y/%m/%d %H:%M:%S\\&quot;`&quot; 첫 번째 라인은 Sun Dec 4 22:12:42 KST 2016 같은 형식으로 커밋 메시지가 나오고두 번째 라인은 2016/12/04 22:25:13 같은 형식으로 커밋 메시지가 나온다. 로컬 저장소를 원격 저장소로부터 싱크 맞추기검색 키워드: git sync with remote12git fetch // 커밋 로그들만 받아옴.git reset --hard origin/&lt;your-working-branch&gt; 로컬 브랜치 이름 바꾸기검색 키워드: git branch rename12git branch -m &lt;oldname&gt; &lt;newname&gt;git branch -m &lt;newname&gt; // 현재 브랜치","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"http://perfectacle.github.io/categories/Middle-end/"},{"name":"git","slug":"Middle-end/git","permalink":"http://perfectacle.github.io/categories/Middle-end/git/"}],"tags":[{"name":"형상 관리","slug":"형상-관리","permalink":"http://perfectacle.github.io/tags/형상-관리/"},{"name":"버전 관리","slug":"버전-관리","permalink":"http://perfectacle.github.io/tags/버전-관리/"},{"name":"배포","slug":"배포","permalink":"http://perfectacle.github.io/tags/배포/"},{"name":"git","slug":"git","permalink":"http://perfectacle.github.io/tags/git/"}]},{"title":"(Webpack) 모듈? 번들링?","slug":"Module-bundling-with-Webpck","date":"2016-11-17T16:38:50.000Z","updated":"2017-07-31T12:40:31.000Z","comments":true,"path":"2016/11/18/Module-bundling-with-Webpck/","link":"","permalink":"http://perfectacle.github.io/2016/11/18/Module-bundling-with-Webpck/","excerpt":"","text":"목차 들어가기에 앞서 모듈, 너는 누구니? 웹팩을 사용해보자 웹팩에게 모듈이란…? 개발용? 배포용? 부트스트랩, 폰트어썸, 제이쿼리, 이미지 모듈을 사용해보자. 홈페이지, IE8에서도 웹팩을 써보자. 마치며… 들어가기에 앞서아주 많이 참조한 링크웹팩입문자를 위한 튜토리얼 파트1 - 웹팩 입문 ! 이 포스트에서는 Node.js, npm, ES(ECMAScript), Babel 등등에 대해서는 설명하지 않는다.해당 내용들은 구글링을 통해 직접 찾아보길 바란다. 이번 포스트에서는 모듈이 왜 필요한지, 무엇인지, 번들링이란 무엇인지 등등에 대해 다룬다.또한 홈페이지나 SPA가 여러 개 있는 다중 페이지, IE8에서도 모듈 번들링을 하는 방법까지 다뤄보자. 모듈, 너는 누구니?ES5(3)를 공부해본 사람이라면 자바스크립트의 스코프 관리는 지저분하다는 것을 알 수 있다.이를 해결하고자 아래와 같은 방법들이 있다.private module을 구현하는 코드 (전역의 공간을 더럽히지 않는 코드)대신 script 모듈에서 script2 모듈에 있는 데이터를 불러올 수 없다.12345// ES3+ (IE 8+)(function() &#123; 'use strict'; // 소스코드 끄적끄적...&#125;()); 1234// ES6 (Moden Browser)&#123; // 소스코드 끄적끄적...&#125; public module을 구현하는 코드script 모듈에서 script2 모듈에 있는 데이터를 불러올 수 있다.1234567891011121314151617// ES3+ (IE 8+), 전역 스코프에 변수가 추가된다는 단점이 존재한다.// 네임스페이스 패턴이라고 부른다.// script.js'use strict';var car = (function() &#123; var namespace = &#123;&#125;; var color = 'blue'; // 외부에 노출시키지 않음, 캡슐화. // 아래 메소드는 네임스페이스의 메소드임. namespace.getColor = function() &#123; return color; &#125;; namespace.setColor = function(_color) &#123; color = _color; &#125;; // 메소드를 달고 있는 네임스페이스 객체 리턴. return namespace;&#125;()); 123456// ES3+ (IE 8+), 전역 스코프에 car라는 변수가 추가된다는 단점이 존재한다.// script2.js'use strict';console.log(car.getColor()); // 'blue';car.setColor('red');console.log(car.getColor()); // 'red'; 123456// ES6 (현재 지원하는 브라우저 없음)// 이 방법이 베스트인데, 크롬마저도 미지원이다.// script.jslet color = 'blue';export const getColor = () =&gt; color;export const setColor = (_color) =&gt; color = _color; 1234567// ES6 (현재 지원하는 브라우저 없음)// 이 방법이 베스트인데, 크롬마저도 미지원이다.// script2.jsimport &#123;getColor, setColor&#125; from './script';console.log(getColor());setColor('red');console.log(getColor()); 이렇 듯 모듈은 변수의 스코프를 관리하는 기능을 한다.물론 이게 모듈의 전부는 아니지만, 그건 이 포스트의 주제를 벗어나므로 설명하지 않겠다.브라우저에서 ES6의 모듈이 지원되지는 않지만 모듈을 사용하는 두 가지 방법이 존재한다. 자바스크립트 파일/모듈 로더인 requireJS를 사용. 모듈 번들러인 Webpack이나 Browserify 등등을 사용. 이 중에서 나는 2번의 Webpack을 택했다.참고로 번들러는 번들링하는 놈을 지칭하고,번들링은 여러가지 파일을 모아서 하나로 만드는 것이라고 보면 된다.여러 모듈을 하나로 합쳐서 http 리퀘스트 횟수를 줄여서퍼포먼스를 향상시키는 등등의 효과를 불러일으킬 수 있다. 웹팩을 사용해보자터미널 창에서 아래와 같이 입력해보자.12$ npm i -g webpack$ npm i -D webpack babel-core babel-preset-latest babel-loader 위 명령어들을 하나 하나 헤짚어 보자. npm i -g webpack터미널에서 webpack 명령어를 사용하기 위해 글로벌로 웹팩을 설치 npm i -D webpack현재 프로젝트에서 웹팩을 사용하기 위해 설치 babel-corerequireJS 문법을 이용해도 모듈 번들링을 할 수 있지만,ES6의 import, export를 사용해보기 위해 babel을 사용하였다. babel-preset-latestbabel에는 plugin이라는 게 존재한다.이 plugin은 es6의 애로우 펑션을 지원하는 플러그인, 클래스를 지원하는 플러그인 등등이 있다.그러한 플러그인을 모아놓은 걸 preset이라고 부른다.es2015 preset은 es6의 플러그인들을 모아놓은 것이고,latest preset은 ES2015~ES2017까지의 프리셋들을 모아놓은 것이다.시간이 지나면 latest의 지원 프리셋 범위는 더 늘어날 수도 있다. babel-loader웹팩과 바벨을 연동해서 사용하기 위한 로더. 이제는 아래와 같이 디렉토리를 구성해보자. .babelrc entry-index.js index.html module-a.js module-b.js module-c.js webpack.config.js 1234567891011&lt;!-- index.html --&gt;&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"./bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ES6의 import와 export 문은 이 포스트에서 다루지 않겠다.123// module-a.jsconst a = '나는 a';export const ab = a + ', a를 외부에 노출시키지 않고 변수 a를 활용!'; 12// module-b.jsexport const a = '모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐'; 12// module-c.jsexport const b = '나도 써주랑!'; 123456// entry-index.jsimport &#123;ab&#125; from './module-a';import &#123;a&#125; from './module-b';import &#123;b&#125; from './module-c'; console.log(ab); // \"나는 a, a를 외부에 노출시키지 않고 변수 a를 활용!\"console.log(a); // \"모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐\" .babelrc 파일은 바벨의 설정 파일이다.아래와 같이 써주자.123&#123; \"presets\": [\"latest\"]&#125; webpack.config.js 파일은 웹팩의 기본 설정 파일이다.아래와 같이 써주자.12345678910111213141516171819202122const webpack = require('webpack'); module.exports = &#123; devtool: 'source-map', entry: './entry-index.js', output: &#123; filename: \"bundle.js\", &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: 'babel', exclude: /(node_modules|bower_components)/ &#125;] &#125;&#125;; 설정 파일을 하나씩 파헤쳐보자. devtool소스맵과 디버깅을 요긴하게 하기 위한 옵션이다.자세한 건 devtool 옵션 퍼포먼스를 참고하자. entryJavaScript 모듈화 도구, webpack에서는 아래와 같이 말하고 있다.서로 의존 관계에 있는 다양한 모듈을 사용하는 시작점이 되는 파일이다.Webpack 적용기 2 : 어떻게 사용하는가?에서는 다음과 같이 설명하고 있다. 번들링의 진입점에 해당하는 entry point에서부터 require으로 명시된 의존성들을 해석하며 의존성 트리(dependency tree)를 그린다. output결과물이 어느 폴더, 어떤 파일명으로 저장될지 정하는 옵션이다. pluginsjs 난독화 플러그인, 번들 파일을 html에 자동으로 삽입해주는 플러그인 등등 종류가 많다. UglifyJsPluginjs 난독화 플러그인 modules파일들에 영향을 주는 옵션들 loadersWebpack 적용기 2 : 어떻게 사용하는가?에서는 다음과 같이 설명하고 있다. 이 때 require된 모듈들은 불러들어지는 과정에서 파이프라이닝 된일련의 로더 들을 거치게 된다.로더를 하나의 정해진 역할을 수행하는, 일종의 함수라고 생각할 수 있다.로더는 직전 단계의 모듈을 입력으로 받아,다양한 변형을 가한 뒤 다음 로더의 입력으로 넘겨준다.마지막 로더는 최종적으로 적절하게 변형된 모듈을번들 자바스크립트 파일에 넣어주게 된다. 그럼 실제로 번들링을 해보자.1$ webpack -w 위 명령어를 실행하면 모듈들이 번들링되며 엔트리 포인트와 엔트리 포인트에 관련된 모듈들이변경될 때마다 다시 번들링되는 감시(watch)를 진행하게 된다.Ctrl+C 키를 누르면 빠져나올 수 있다. 그리고나서 다시 디렉토리를 보면 다음과 같은 파일이 생긴 것을 볼 수 있다. bundle.js bundle.js.map 한번 index.html 파일을 열어보고 콘솔창을 보자.디버깅하여 모듈은 어떠한 스코프를 가지는지 알아보자.6번 라인에 브레이크 포인트를 걸고 새로고침을 해보았다.module-c는 import 시켰지만 모듈의 변수를 사용하지 않았으므로불필요하게 스코프를 생성하지 않았다. 만약 모듈화가 브라우저 자체 내에서 지원된다면index.html은 아래와 같이 마크업해야하지 않을까 싶다.12345678910111213&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"module\" src=\"./module-a.js\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"./module-b.js\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"./module-c.js\"&gt;&lt;/script&gt;&lt;script src=\"./entry-index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 웹팩의 모듈 번들링 방식은 bundle.js 파일 하나만 요청해서 리퀘스트 횟수가 1회였는데,저렇게 의존하는 모듈이 많으면 많을 수록 리퀘스트 횟수가 증가하여 큰 비용을 지불하게 될 것이다.위와 같이 웹팩을 사용하면 큰 효과를 얻어낼 수 있다. 웹팩에게 모듈이란…?ES6의 관점에서 모듈과 웹팩의 관점에서 모듈은 다르다.ES6는 js 파일만 모듈이라고 한정하는데 반해 웹팩은 이미지, css 파일 등등도 모듈로 취급한다.js 모듈을 import 시키는 것은 따로 로더를 요구하지 않지만,다른 모듈들은 로더를 필요로 한다.다음 예제를 통해 css, scss 모듈을 import 시켜보자.또한 번들링 된 모듈(bundle.js)을 자동으로 추가시켜보자.위 디렉토리에서 아래 파일들을 추가하자. style.css style.scss 1234/* style.css */p &#123; user-select: none&#125; 12345/* style.scss */$color: red;h1 &#123; color: $color&#125; 그리고 index.html을 아래와 같이 수정해주자.1234567891011&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;나는 문서의 제목이얌! 내가 짱이지!&lt;/h1&gt;&lt;p&gt;IE11+에서 나는 드래그 안 될 걸?!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 이제 entry-index.js에 (s)css 모듈을 추가해보자.1234567import '../styles/style.css';import '../styles/style.scss'; import &#123;ab&#125; from './module-a';import &#123;a&#125; from './module-b';import &#123;b&#125; from './module-c'; console.log(ab); // \"나는 a, a를 외부에 노출시키지 않고 변수 a를 활용!\"console.log(a); // \"모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐\" 그리고 관련 로더들을 설치해보자.1$ npm i -D html-webpack-plugin style-loader css-loader node-sass sass-loader postcss-loader autoprefixer 하나씩 까보자. html-webpack-pluginhtml에 번들링 된 bundle.js 파일을 넣어주는 역할을 한다. style-loader css-loadercss 모듈을 import 시키기 위한 로더이다. node-sass sass-loaderscss 모듈을 import 시키기 위한 로더이다. postcss-loader autoprefixer(s)css 파일 등등에 벤더 프리픽스를 자동으로 붙이는 로더이다. webpack.config.js는 아래와 같이 고쳐보자.123456789101112131415161718192021222324252627282930313233343536373839const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const autoprefixer = require('autoprefixer'); module.exports = &#123; devtool: 'source-map', entry: './entry-index.js', output: &#123; filename: \"bundle.js\", &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new HtmlWebpackPlugin(&#123; template: './index.html', filename: './index2.html' &#125;) ], postcss: [ autoprefixer(&#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: 'babel', exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: ['style', 'css?sourceMap', 'postcss-loader'] &#125;, &#123; test: /\\.scss$/, loaders: ['style', 'css?sourceMap', 'sass?sourceMap', 'postcss-loader'] &#125;] &#125;&#125;; 추가된 옵션들을 하나씩 살펴보자. html webpack pluginhtml에 번들링 한 파일을 자동으로 삽입해준다.tmplate에 ejs 등등의 html 템플릿 엔진으로 작성한 걸 넣어주고,filename에 그 템플릿을 토대로 새롭게 만들어질 html 파일을 지정해주면 된다.자세한 내용은 플러그인 api를 참조하길 바란다. postcss스타일 시트에 벤더 프리픽스를 지정하기 위해 추가하였다.사용하고자 하는 쿼리는 Browserslist에서 확인 가능하고,쿼리문 테스트는 browserl.ist에서 확인 가능하며,데모는 Autoprefixer CSS online에서 가능하다. css-loader, sass-loadertest에는 정규표현식이 들어가고, 로더의 순서는 바뀌면 오류가 난다.아마 오른쪽에서부터 왼쪽으로 적용이 되는 게 아닐까 싶다.또한 소스맵 옵션을 제거하면 아래와 같이 난독화된 소스를 보게돼 디버깅하기가 쉽지 않다. 개발용? 배포용?뭔가 이제 그럴듯 하게 보이긴 하지만 현재 프로젝트 디렉토리를 보자. node_modules - 패키지들이 설치된 폴더로 개발할 때 수정할 일이 없는 파일. .babelrc - 바벨의 설정파일로서 개발할 때 수정할 일이 없는 파일. bundle.js - 개발할 때는 필요없는 배포용 파일 bundle.js.map - 실제 사용자가 디버깅 할 필요는 없으므로 이 파일도 개발용 파일. entry-index.js - 개발용 파일 index.html - 템플릿이 되는 파일이므로 개발용 파일 index2.html - 템플릿을 토대로 만들어진 배포용 파일 module-a.js - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 module-b.js - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 module-c.js - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 package.json - 패키지들의 의존성을 도와주는 파일로서 바벨의 설정파일로서 개발할 때 수정할 일이 없는 파일. style.css - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 styles.css - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 webpack.config.js - 번들을 하기 위한 설정 파일이므로 개발할 때 수정할 일이 없는 파일. 개발용 파일과 배포용 파일이 너무 난잡하게 섞여있다.이는 나중에 개발 &amp; 배포를 할 때 상당한 혼란을 초래한다. 또한 스타일 시트를 bundle.js 안에 번들링하면 아래와 같은 현상이 발생한다.위 현상은 스타일 시트의 규모가 커질 수록 스타일이 적용되지 않은 모습이 노출되는 시간이 길어진다.이를 해결하고자 css 파일에 소스맵을 안 붙여서 내부 스타일 시트로 배포하는 수가 있지만,bundle.js의 몸뚱아리만 키워 로딩속도를 저하시키는 요인이 되기도 한다.http 리퀘스트 횟수를 줄이라고는 하지만 기본적으로 http 리퀘스트는 4개의 병렬로 처리된다.따라서 몸뚱아리만 큰 bundle.js를 로딩시키는 것보다css 파일을 따로 빼서 bundle.js와 병렬로 로딩시키게끔 처리하는 게 훨씬 효율적이다. 그럼 개발용 파일과 배포용 파일을 분리해 보자!우선 디렉토리를 아래와 같이 바꾼다.123456789101112131415+ node_modules+ src - index.html + scripts - entry-index.js - module-a.js - module-b.js - module-c.js + styles - style.css - style.scss.babelrcpackage.jsonwebpack.config.dev.jswebpack.config.prod.js 우선 개발과 상관없는 설정 파일들은 루트 디렉토리로 빼버렸다.그리고 개발에 집중하고자 개발용 파일들을 src 폴더에 체계적으로 분류하였다.또한 웹팩의 설정 파일을 개발용과 배포용으로 나눴는데 이유는 다음과 같다. 개발용 파일은 디버깅이 주 목적이라 소스맵이 필요하다.또한 난독화시키는 것은 번들링 타임을 증가시키는 주범이므로 뺀다.그리고 HTML 파일을 핫리로드하게 만들어야 한다.핫리로드란 서버의 재시작 없이 내용이 재교체되는 것을 뜻한다.또한 브라우저에서 자동으로 새로고침이 이루어진다.그리고 스타일 시트를 외부로 빼면 HMR을 이용할 수 없으므로 따로 빼지 않는다. HMR(Hot Module Replacement)이란 서버의 재시작 없이,브라우저가 새로고침하지 않고, 수정된 부분만 바꾸는 것을 의미한다. 배포용 파일은 실 사용이 주 목적이라 용량을 경량화 시킬 난독화 작업이 진행되고,디버깅 할 필요가 없으므로 소스맵도 붙이지 않고,또한 HTML 파일은 핫리로드하게 만들 필요가 없고,HMR을 사용할 필요가 없으므로 스타일 시트를 외부로 뺀다. 이를 위해서 추가로 패키지를 설치할 필요가 있다.12$ npm i -g webpack-dev-server$ npm i -D webpack-dev-server raw-loader webpack-browser-plugin extract-text-webpack-plugin webpack-strip clean-webpack-plugin webpack-dev-server-g로 설치하는 이유는 해당 명령어를 터미널에서 쓰기 위함이고다시 한 번 -D로 설치하는 이유는 현재 프로젝트에서 해당 패키지를 쓰기 위함이다.webpack-dev-server는 실제 눈에 보이지 않는 디렉토리를 만들고 그 디렉토리에번들링을 진행하고 watch하며 테스트를 하는 웹팩 개발용 서버이다. raw-loader는 html 파일을 핫리로드하게 만드는 로더이다. webpack-browser-pluginwebpack-dev-server에서 번들링을 끝낸 후 자동으로 브라우저를 열어주는 플러그인이다.자세한 옵션은 webpack-browser-plugin을 확인하자. extract-text-webpack-plugin스타일 시트를 따로 빼기 위한 플러그인이다. webpack-stripjs 파일에서 디버깅을 위해 찍어본 로그를 삭제해준다. clean-webpack-plugin배포용 파일을 빌드하기 전에 배포용 디렉토리를 지워주는 플러그인이다. 이제 webpack.config.dev.js 부터 수정해보자.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const path = require('path');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const autoprefixer = require('autoprefixer');const WebpackBrowserPlugin = require('webpack-browser-plugin');module.exports = &#123; devtool: 'cheap-eval-source-map', entry: [ 'webpack-dev-server/client?http://localhost:8080', 'webpack/hot/dev-server', './src/scripts/entry-index.js' ], output: &#123; publicPath: 'http://127.0.0.1:8080/', filename: 'scripts/bundle.js', &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;), new WebpackBrowserPlugin() ], postcss: [ autoprefixer(&#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: 'babel', exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: ['style', 'css?sourceMap,-minimize', 'postcss-loader'] &#125;, &#123; test: /\\.scss$/, loaders: ['style', 'css?sourceMap,-minimize', 'sass?sourceMap,outputStyle=expanded', 'postcss-loader'] &#125;, &#123; test: /\\.html$/, loader: 'raw-loader' &#125;] &#125;, devServer: &#123; hot: true &#125;&#125;; 추가된 속성들을 하나씩 살펴보자. entry두 개의 새로운 엔트리포인트가 서버와 브라우저에 접속하여 HMR을 허용한다. publicPath자세히는 모르겠지만 저렇게 설정해주지 않으면, 이미지나 폰트가 제대로 붙지 않음. new webpack.HotModuleReplacementPlugin()HMR을 사용하기 위한 플러그인 new WebpackBrowserPlugin()번들링이 끝나면 자동으로 브라우저를 열어줌. css?sourceMap,-minimize, sass?sourceMap,outputStyle=expanded(s)css 파일을 압축시키지 않으면서 소스맵을 붙이고자 할 때 씀. raw-loaderHTML을 핫리로드하게 만드는 로더. devServerhot은 HMR의 활성화 여부이다. 이제는 배포용 설정 파일인 webpack.config.prod.js를 아래와 같이 바꿔보자.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const autoprefixer = require('autoprefixer');const ExtractTextPlugin = require('extract-text-webpack-plugin'); module.exports = &#123; entry: './src/scripts/entry-index.js', output: &#123; path: './dist', filename: 'scripts/bundle.js', &#125;, plugins: [ new CleanWebpackPlugin(['dist']), new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html', minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new ExtractTextPlugin('styles/bundle.css') ], postcss: [ autoprefixer(&#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loaders: ['babel', 'webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir'], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css!postcss-loader') &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass!postcss-loader') &#125;] &#125;&#125;; 추가된 속성들을 하나씩 살펴보자. new CleanWebpackPlugin([‘dist’])빌드를 시작하기 전에 먼저 배포용 디렉토리를 지워줘야한다. new webpack.DefinePlugin()process.env.NODE_ENV는 개발환경인지 배포환경인지 알고자 할 때 쓰인다.production이면 배포 모드, development이면 개발환경이다.이는 HTML을 핫리로드하게 만들지 안 만들지를 결정하기 위해 썼다. new webpack.optimize.OccurrenceOrderPlugin() 모듈을 할당하고 발생 카운트 아이디들을 발생(?chunk)시킨다.ID들은 종종 적은(짧은) id들을 얻는데 사용된다.이것은 id가 예상가능하며 파일 전체 크기를 경감시켜 추천한다. new HtmlWebpackPlugin({ minify: {}})html 난독화 옵션을 참고하자. new ExtractTextPlugin(‘styles/bundle.css’)번들링한 스타일 시트 파일을 어디에다 추출할지 정해주는 플러그인. ‘webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir’webpack-strip 로더를 사용하여 디버깅을 위해 로그에 찍었던 로그를 삭제했다. ExtractTextPlugin.extract()해당 스타일 시트를 css파일로 뽑아내는 로더이다. 또한 html을 핫리로드하게 만들어주려면 엔트리에 html 모듈을 추가해야한다.하지만 배포용에서는 핫리로드하게 만들어줄 필요가 없기 때에 조건문을 쓰면 된다.1234567891011121314// entry-index.jsif (process.env.NODE_ENV !== 'production') &#123; require('../index.html')&#125;import '../styles/style.css';import '../styles/style.scss'; import &#123;ab&#125; from './module-a';import &#123;a&#125; from './module-b';import &#123;b&#125; from './module-c'; console.log(ab);console.log(a); 웹팩의 설정 파일의 기본적인 이름은 webpack.config.js이다.그래서 webpack 이라는 명령어만 붙여도 자동으로 webpack.config.js 파일을 인식했는데,우리는 임의로 설정 파일의 이름을 바꿨기 때문에 달리 진행해야한다. 개발을 진행하기 위해서는 터미널에 아래와 같이 입력을 해야한다.1$ webpack-dev-server -d --config webpack.config.dev.js 배포를 진행하기 위해서는 아래와 같이 입력을 해야한다.1$ webpack --config webpack.config.prod.js 하지만 위와 같은 작업은 매우 귀찮다.npm의 스크립트를 이용해보자.우선 package.json에서 scripts 부분을 아래와 같이 수정해준다.12345\"scripts\": &#123; \"dev\": \"webpack-dev-server -d --config webpack.config.dev.js\", \"build\": \"webpack --config webpack.config.prod.js\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"&#125; 이제는 개발을 진행하고자 할 때는 아래와 같이 입력해주면 된다.1$ npm run dev 배포를 진행하고자 할 때는 아래과 같이 입력해주면 된다.1$ npm run build 우선 개발용 서버로 진입해서 살펴보자.js 파일에서 스타일을 렌더링하는 코드가 있기 때문에 js파일을 전부 로드한 이후에스타일 시트가 적용돼서 초반에 스타일 시트가 적용되지 않은 모습이 잠깐 보이게 된다.또한 html 파일에 넣지 않았던 번들링된 파일과 스타일 시트가 들어가있다. 그럼 style.scss 파일을 고쳐보자.12345$color: red;/*gg*/h1 &#123; color: $color&#125; 위와 같이 새로고침 없이 필요한 부분만 갱신하는 게 HMR이다. 그럼 index.html 파일을 고쳐보자.1234567891011&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;댓글을 달아주시면 짱짱맨&lt;/h1&gt;&lt;p&gt;IE11+에서 나는 드래그 안 될 걸?!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 이는 js 파일도 마찬가지인데, js 파일과 html 파일은 핫모듈이 아니기 때문에 핫리로드를 하는 것이다. 그럼 이제 실제 배포를 진행해보자.빌드를 하고 나서 배포용 디렉토리를 살펴보자.123456+ dist + scripts - bundle.js + styles - bundle.css - index.html 각각의 파일을 열어보면 파일이 1줄로 압축돼있어서 용량을 최소화하여트래픽을 줄이고 로딩 속도를 높여 퍼포먼스를 향상시켰다. 이제 index.html 파일을 브라우저에서 열어보자. 실제로 웹팩으로 모듈 번들링을 할 때는 이렇게 개발용과 배포용으로 나누어서 진행하고,개발용 서버로 개발하다 개발을 완료하면빌드를 해서 배포용 디렉토리 안의 파일만 실서버에 올리면 된다. 부트스트랩, 폰트어썸, 제이쿼리, 이미지 모듈을 사용해보자.우선 위 모듈들을 설치해야한다.12$ npm i -S jquery bootstrap font-awesome$ npm i -D url-loader file-loader font-awesome은 폰트를 쓰는 대표적인 라이브러리이다.웹팩에서는 폰트와 이미지도 하나의 모듈로 보고, 그러한 모듈을 사용하기 위해서는url-loader와 file-loader가 필요한 것이다. 이를 위해서는 개발용, 배포용 설정 파일의 모듈 로더에 다음과 같은 걸 추가해줘야한다.12345678910&#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]'&#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'file?name=fonts/[name].[ext]'&#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: 'file?name=img/[name].[ext]'&#125; 폰트와 이미지는 로더를 통해야만 정상적으로 작업이 가능하고,name 파라미터를 통해 저장될 디렉토리와 이름을 정했다. 추가적으로 extract-text-webpack-plugin의 버그 때문에 배포용 설정에서(s)css 로더 부분을 수정해주자.1234567&#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&apos;style&apos;, &apos;css!postcss-loader&apos;, &#123;publicPath: &apos;../&apos;&#125;),&#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract(&apos;style&apos;, &apos;css!sass!postcss-loader&apos;, &#123;publicPath: &apos;../&apos;&#125;)&#125; 번들된 css 파일에서 url()과 같은 경로가 꼬이길래 강제로 경로를 지정해준 것이다. 그리고 src 디렉토리 내에 img 폴더를 만들고 임의의 이미지를 넣는다.그 후에 src/index.html을 다음과 같이 수정하자.1234567891011121314&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;댓글을 달아주시면 짱짱맨&lt;/h1&gt;&lt;p&gt;IE11+에서 나는 드래그 안 될 걸?!&lt;/p&gt;&lt;span&gt;&lt;/span&gt;&lt;button id=\"btn\" class=\"btn btn-warning\"&gt;&lt;i class=\"fa fa-address-book\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/button&gt;&lt;img src=\"./img/logo.png\" alt=\"로고\" /&gt;&lt;/body&gt;&lt;/html&gt; 부트스트랩과 폰트 어썸을 썼다. src/styles/style.scss는 아래와 같이 수정해주자.123456789101112$color: blue;$square: 90px;h1 &#123; color: $color&#125;span &#123; display: inline-block; background-image: url('../img/logo.png'); width: $square; height: $square;&#125; 실제로 라이브러리&amp;프레임워크를 써보자.src/scripts/entry-index.js를 수정하자.123456789101112131415161718192021if (process.env.NODE_ENV !== 'production') &#123; require('../index.html')&#125;import 'bootstrap/dist/css/bootstrap.min.css';import 'font-awesome/css/font-awesome.min.css';import $ from 'jquery';import '../styles/style.css';import '../styles/style.scss';import &#123;ab&#125; from './module-a';import &#123;a&#125; from './module-b';import &#123;b&#125; from './module-c';console.log(ab);console.log(a);$('#btn').click(function() &#123; alert('a');&#125;); 제이쿼리, 부트스트랩, 폰트 어썸을 import 시켰고,btn 아이디를 가진 엘리먼트를 클릭하면 경고창이 뜨게 제이쿼리를 사용하였다. 이제 $ npm run dev를 치고 실제 개발용 서버에서 보자.버튼을 누르면 경고창도 뜨고, (s)css와 js의 소스맵 모두 잘 붙는다. 이제 $ npm run build를 치고 실제 배포용 파일을 보자. index.html을 브라우저에 띄워보자.디버깅 용 로그도 사라졌고, 디버깅 할 필요가 없으니 소스맵도 안 붙였다. 기본적인 외부 모듈들 사용방법은 이러하고,자신이 필요한 건 그때 그때 사용법을 익히면 된다. 홈페이지, IE8에서도 웹팩을 써보자.기본적으로 홈페이지와 SPA 사이에는 차이점을 모듈화 관점에서 바라보자.홈페이지는… 페이지가 여러 개다. 각 페이지 별로 적용되는 모듈들이 다르다. IE8을 지원해야하는 경우가 많다. 우리가 예제로 작업한 페이지는 하나였다. 그럼 다중 페이지에서 모듈화를 진행하고자 할 때를 가정하고 실습을 진행하자.우선 디렉토리를 아래와 같이 만든다.123456789101112131415161718192021+ node_modules+ src + img - 임의의 이미지 파일 + scripts - entry-index.js - entry-sub.js - module-a.js - module-b.js - module-c.js + styles - style.css - style.scss - sub.css - sub.scss - index.html - sub.html- .babelrc- package.json- webpack.config.dev.js- webpack.config.prod.js 새로 추가된 파일의 소스는 아래와 같이 바꾸자.1234567891011121314// entry-sub.jsif (process.env.NODE_ENV !== 'production') &#123; require('../sub.html')&#125;import '../styles/sub.css';import '../styles/sub.scss';import &#123;b&#125; from './module-c';const btn = document.getElementById('btn');btn.addEventListener('click', function() &#123; alert(b);&#125;); 1234/* sub.css */button &#123; width: 500px&#125; 12345678910111213/* sub.scss */$bgColor: orange;$boxSize: 500px;button &#123; background-color: $bgColor&#125;section &#123; width: $boxSize; height: $boxSize + 100px; background-color: $bgColor&#125; 123456789101112&lt;!-- sub.html --&gt;&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;section&gt;IE8에서도 제대로 보이나?&lt;/section&gt;&lt;button id=\"btn\"&gt;내가 바로 버튼이다.&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 이제 개발용 파일을 수정해보자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const autoprefixer = require('autoprefixer');const WebpackBrowserPlugin = require('webpack-browser-plugin');const dev = [ 'webpack-dev-server/client?http://localhost:8080', 'webpack/hot/dev-server'];module.exports = &#123; devtool: 'cheap-eval-source-map', entry: &#123; index: [ dev[0], dev[1], './src/scripts/entry-index.js' ], sub: [ dev[0], dev[1], './src/scripts/entry-sub.js' ] &#125;, output: &#123; publicPath: 'http://127.0.0.1:8080/', filename: 'scripts/[name].bundle.js', &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html', chunks: ['index'] &#125;), new HtmlWebpackPlugin(&#123; template: './src/sub.html', filename: 'sub.html', chunks: ['sub'] &#125;), new WebpackBrowserPlugin() ], postcss: [ autoprefixer(&#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: 'babel', exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: ['style', 'css?sourceMap,-minimize', 'postcss-loader'] &#125;, &#123; test: /\\.scss$/, loaders: ['style', 'css?sourceMap,-minimize', 'sass?sourceMap,outputStyle=expanded', 'postcss-loader'] &#125;, &#123; test: /\\.html$/, loader: 'raw' &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'file?name=fonts/[name].[ext]' &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: 'file?name=img/[name].[ext]' &#125;] &#125;, devServer: &#123; hot: true &#125;&#125;; entryentry를 객체로 만들어서 객체 프로퍼티들이 엔트리가 되게 된다.각 엔트리별로 webpack-dev-server 설정들을 붙여야해서 배열화 시켜서 넣었다. filename[name]에는 엔트리의 이름이 들어간다. new HtmlWebpackPlugin()각 엔트리별로 모듈을 각각 삽입해줘야한다.filename은 기본이 index.html이라 생략을 했고,chunks에는 원하는 엔트리들을 넣으면 된다. 이번엔 배포용 설정 파일을 수정하자.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const autoprefixer = require('autoprefixer');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: &#123; index: './src/scripts/entry-index.js', sub: './src/scripts/entry-sub.js' &#125;, output: &#123; path: './dist', filename: 'scripts/[name].bundle.js', &#125;, plugins: [ new CleanWebpackPlugin(['dist']), new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html', chunks: ['index'], minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new HtmlWebpackPlugin(&#123; template: './src/sub.html', filename: 'sub.html', chunks: ['sub'], minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new ExtractTextPlugin('style/[name].bundle.css') ], postcss: [ autoprefixer(&#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loaders: ['babel', 'webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir'], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css!postcss-loader', &#123;publicPath: '../'&#125;), &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass!postcss-loader', &#123;publicPath: '../'&#125;) &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'file?name=fonts/[name].[ext]' &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: 'file?name=img/[name].[ext]' &#125;] &#125;&#125;; new ExtractTextPlugin()에서도 [name]은 각 엔트리 별 이름이 들어간다. $ npm run dev 를 치고 한 번 확인해보자. http://127.0.0.1/8080/sub.html 으로 접속해보자. $ npm run build 를 치고 배포용 파일을 확인해보자. 하지만 IE8에서 결과를 확인하면 처참한 결과를 확인할 수 있다. 이를 위해서는 ES5 Polyfill 붙이기babel로 트랜스파일한 ES5 전용 폴리필인 babel-polyfill이 있고,이벤트 리스너 관련해서는 수동으로 추가해줘야한다.자세한 내용은 아래 링크를 참고하자.(Babel) ES6를 IE8에서도 써보자 HTML5 Sectioning Elements Polyfill 붙이기HTML5는 다양한 API가 있어서 하나의 폴리필로는 커버가 힘들다.우선 내가 쓴 section 엘리먼트를 커버하기 위해 html5shiv를 쓰겠다. CSS3 폴리필도 상당히 많으므로 본인이 원하는 걸 직접 찾아봐야한다.이는 이번 포스트에서 생략한다. 폴리필들을 설치하자.12$ npm i -S html5shiv$ npm i -D babel-plugin-transform-es3-property-literals babel-plugin-transform-es3-member-expression-literals 그리고 src/scripts 폴더 안에 eventListener.polyfill.js 파일을 만들자.123456789101112131415161718192021222324252627!window.addEventListener &amp;&amp; (function(WindowPrototype, DocumentPrototype, ElementPrototype, addEventListener, removeEventListener, dispatchEvent, registry) &#123; WindowPrototype[addEventListener] = DocumentPrototype[addEventListener] = ElementPrototype[addEventListener] = function(type, listener) &#123; var target = this; registry.unshift([target, type, listener, function(event) &#123; event.currentTarget = target; event.preventDefault = function() &#123; event.returnValue = false &#125;; event.stopPropagation = function() &#123; event.cancelBubble = true &#125;; event.target = event.srcElement || target; listener.call(target, event); &#125;]); this.attachEvent(\"on\" + type, registry[0][3]); &#125;; WindowPrototype[removeEventListener] = DocumentPrototype[removeEventListener] = ElementPrototype[removeEventListener] = function(type, listener) &#123; for(var index = 0, register; register = registry[index]; ++index) &#123; if(register[0] == this &amp;&amp; register[1] == type &amp;&amp; register[2] == listener) &#123; return this.detachEvent(\"on\" + type, registry.splice(index, 1)[0][3]); &#125; &#125; &#125;; WindowPrototype[dispatchEvent] = DocumentPrototype[dispatchEvent] = ElementPrototype[dispatchEvent] = function(eventObject) &#123; return this.fireEvent(\"on\" + eventObject.type, eventObject); &#125;;&#125;)(Window.prototype, HTMLDocument.prototype, Element.prototype, \"addEventListener\", \"removeEventListener\", \"dispatchEvent\", []); src/scripts 폴더 안에 preRender.polyfill.js 파일을 만들자.이 파일에는 렌더링 되기 이전, head에 들어가야하는 폴리필,대표적인 게 html5, css3 폴리필 등등이 해당한다.1import 'html5shiv'; 폴리필을 적용하고자하는 엔트리와 html 파일을 수정해줘야한다.sub만 건드려보자.12345678910111213141516// entry-sub.jsif (process.env.NODE_ENV !== 'production') &#123; require('../sub.html')&#125;import './eventListener.polyfill';import '../styles/sub.css';import '../styles/sub.scss';import &#123;b&#125; from './module-c';const btn = document.getElementById('btn');btn.addEventListener('click', function() &#123; alert(b);&#125;); 다른 코드가 오기 전에 폴리필을 먼저 import 시켜야한다. 1234567891011121314&lt;!-- sub.html --&gt;&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"./scripts/preRender.polyfill.bundle.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;section&gt;IE8에서도 제대로 보이나?&lt;/section&gt;&lt;button id=\"btn\"&gt;내가 바로 버튼이다.&lt;/button&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.16.0/polyfill.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; head에 폴리필을 넣어줬다.현재는 존재하지 않지만 번들링을 통해 만들 예정이다.html webpack plugin이 head와 body 동시에 다른 파일 삽입이 불가능해서부득이하게 이러한 방법을 사용했다.또한 babel-polyfill을 minify하게 되면 IE8에서 오류가 나게 된다.따라서 부득이하게 cdn을 이용하였다. .babelrc 설정도 바꿔주자.1234567&#123; \"presets\": [\"latest\"], \"plugins\": [ \"transform-es3-property-literals\", \"transform-es3-member-expression-literals\" ]&#125; 이제 웹팩 설정들을 바꿔보자.우선 개발용 파일부터 손 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const path = require('path');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const autoprefixer = require('autoprefixer');const WebpackBrowserPlugin = require('webpack-browser-plugin');const dev = 'webpack-dev-server/client?http://localhost:8080';module.exports = &#123; devtool: 'cheap-eval-source-map', entry: &#123; index: [dev, './src/scripts/entry-index.js'], sub: [dev, './src/scripts/entry-sub.js'], ['preRender.polyfill']: './src/scripts/preRender.polyfill.js' &#125;, output: &#123; publicPath: 'http://127.0.0.1:8080/', filename: 'scripts/[name].bundle.js', &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', chunks: ['index'] &#125;), new HtmlWebpackPlugin(&#123; template: './src/sub.html', filename: 'sub.html', chunks: ['sub'] &#125;), new WebpackBrowserPlugin() ], postcss: [ autoprefixer(&#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: 'babel', exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: ['style', 'css?sourceMap,-minimize', 'postcss-loader'] &#125;, &#123; test: /\\.scss$/, loaders: ['style', 'css?sourceMap,-minimize', 'sass?sourceMap,outputStyle=expanded', 'postcss-loader'] &#125;, &#123; test: /\\.html$/, loader: 'raw' &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'file?name=fonts/[name].[ext]' &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: 'file?name=img/[name].[ext]' &#125;] &#125;&#125;; 우선 IE8에서는 HMR을 못 쓴다.ES5 폴리필이 붙기 전에 HMR이 먼저 로딩돼서 오류가 난다.따라서 해당 내용을 빼버렸다. preRender.polyfill을 번들링했다. 이번에는 배포용 설정 파일을 손대자.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');const autoprefixer = require('autoprefixer');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: &#123; index: ['./src/scripts/entry-index.js'], sub: ['./src/scripts/entry-sub.js'], ['preRender.polyfill']: ['./src/scripts/preRender.polyfill.js'] &#125;, output: &#123; path: './dist', filename: 'scripts/[name].bundle.js', &#125;, plugins: [ new CleanWebpackPlugin(['dist']), new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html', chunks: ['index'], minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new HtmlWebpackPlugin(&#123; template: './src/sub.html', filename: 'sub.html', chunks: ['sub'], minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new ExtractTextPlugin('style/[name].bundle.css') ], postcss: [ autoprefixer(&#123; browsers: ['last 2 versions', '&gt; 10%', 'ie 9'] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loaders: ['babel', 'webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir'], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css!postcss-loader', &#123;publicPath: '../'&#125;), &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass!postcss-loader', &#123;publicPath: '../'&#125;) &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: 'file?name=fonts/[name].[ext]' &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: 'file?name=img/[name].[ext]' &#125;] &#125;&#125;; 크게 바뀐 건 없고, 바뀐 사항은 위에서 다 설명하였다. $ npm run build를 쳐서 빌드를 하고 dist/sub.html을 IE8에서 켜보자. 마치며…이번 글은 작성하는데 엄청난 시간이 걸렸다.또한 나의 지식이 매우 부족하여 구글링을 하여도 당췌 답이 안 나오는 게 태반이었고,지금 포스트를 쓰면서도 내가 맞게 쓰고 있는 건지도 모르겠다.방문자 분들께서 잘못된 부분을 지적해주시면 정말 감사할 것 같다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"http://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"Cross Browsing","slug":"Cross-Browsing","permalink":"http://perfectacle.github.io/tags/Cross-Browsing/"},{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack","slug":"Webpack","permalink":"http://perfectacle.github.io/tags/Webpack/"}]},{"title":"(Webpack) devtool 옵션 퍼포먼스","slug":"Webpack-devtool-option-Performance","date":"2016-11-14T13:48:48.000Z","updated":"2017-07-31T12:39:57.000Z","comments":true,"path":"2016/11/14/Webpack-devtool-option-Performance/","link":"","permalink":"http://perfectacle.github.io/2016/11/14/Webpack-devtool-option-Performance/","excerpt":"","text":"목차 들어가기에 앞서 소스맵 devtool 마치며… 들어가기에 앞서이 포스트에서는 웹팩에 대한 기초 내용을 설명하지 않는다.웹팩을 모르는 사람은 살포시 뒤로가기를 누르는 걸 권장한다. 소스맵소스맵은 원본 소스와 난독화된 소스를 매핑해주는 방법 중 하나이다.*.map 파일을 통해 제공되고, json 형태로 돼있다.사진을 통해 한번 보자. devtool웹팩에서 devtool 옵션은 개발을 용이하게 하기 위해 소스맵을 제공하는 옵션이다.하지만 devtool 옵션은 굉장히 많고, 그 중 8가지를 테스트 해봤다. eval eval-source-map cheap-eval-source-map cheap-module-eval-source-map source-map inline-source-map cheap-source-map cheap-module-source-map 또한 웹팩에는 배포용 설정과 개발용 설정이 따로 존재하고,webpack 명령어와 webpack -d 명령어가 존재하는 등 총 32가지의 테스트를 해봤다.먼저 배포용 설정 파일을 보자.아래와 같은 설정이 들어있다. ES6 to ES5, 디버깅용 로그들 삭제, js 난독화((이걸 하지 않으면 소스맵이 제대로 붙지 않음.) css 난독화 및 소스맵 적용 scss 난독화 및 소스맵 적용 html 난독화 123456789101112131415161718192021222324252627282930313233343536373839404142const path = require('path');const webpack = require('webpack');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; devtool: 'devtool 옵션 입력', entry: './src/script/entry', output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js', &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html', minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loaders: ['babel', 'webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir'], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: ['style', 'css?sourceMap'] &#125;, &#123; test: /\\.scss$/, loaders: ['style', 'css?sourceMap', 'sass?sourceMap'] &#125;] &#125;&#125;; 이제 개발용 설정 파일을 보자.아래와 같은 설정이 들어있다. ES6 to ES5, js 난독화 (이걸 하지 않으면 소스맵이 제대로 붙지 않음.) css 난독화 및 소스맵 적용 scss 난독화 및 소스맵 적용 핫 모듈 리플레이스먼트 적용(이 예제에서는 (s)css 파일만 적용됨) 핫 리로드 적용(이 예제에서는 js, html 파일만 적용됨) 12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require('path');const webpack = require('webpack');module.exports = &#123; devtool: 'devtool 옵션 입력', entry: [ 'webpack-dev-server/client?http://localhost:8080', 'webpack/hot/dev-server', './src/script/entry' ], output: &#123; path: path.join(__dirname, '_dist'), filename: 'bundle.js', &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: 'babel', exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: ['style', 'css?sourceMap'] &#125;, &#123; test: /\\.scss$/, loaders: ['style', 'css?sourceMap', 'sass?sourceMap'] &#125;, &#123; test: /\\.html$/, loader: 'raw-loader' &#125;] &#125;, devServer: &#123; contentBase: './_dist', hot: true &#125;&#125;; 마치며…배포용은 용량이 가장 작은 cheap-module-source-map 옵션을 사용하고 webpack 명령어를 사용하는 게 가장 좋다.개발용은 로그, 디버깅, 번들링 타임을 고려하면 inline-source-map 옵션을 사용하고 webpack-dev-server 명령어를 사용하는 게 가장 좋을 것 같다.뭐 거의 비슷비슷 하므로 본인의 입맛에 맞게 찾아 쓰면 되겠다.또한 devtool은 js 파일의 소스맵하고만 관련 있지, (s)css의 소스맵과는 무관하다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"http://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack","slug":"Webpack","permalink":"http://perfectacle.github.io/tags/Webpack/"},{"name":"Debugging","slug":"Debugging","permalink":"http://perfectacle.github.io/tags/Debugging/"},{"name":"Performance","slug":"Performance","permalink":"http://perfectacle.github.io/tags/Performance/"},{"name":"Source Map","slug":"Source-Map","permalink":"http://perfectacle.github.io/tags/Source-Map/"}]},{"title":"(Babel) ES6를 IE8에서도 써보자","slug":"Babel-ES6-with-IE8","date":"2016-11-11T14:09:39.000Z","updated":"2017-09-05T05:00:03.000Z","comments":true,"path":"2016/11/11/Babel-ES6-with-IE8/","link":"","permalink":"http://perfectacle.github.io/2016/11/11/Babel-ES6-with-IE8/","excerpt":"","text":"목차 들어가기에 앞서 ES6 왜 써? ES6에서 ES5로 트랜스파일하기 ES5를 IE8에서도 지원하기 바벨은 안전한가? 들어가기에 앞서아주 많이 참조한 링크지금 바로 시작하는 ES6 이 포스트에서는 Node.js, npm, ES(ECMAScript) 등등에 대해서는 설명하지 않는다.해당 내용들은 구글링을 통해 직접 찾아보길 바란다.또한 import, export로 모듈화 시키는 것은 현재 지원 브라우저도 없고,다양한 모듈 번들러 중 하나인 웹팩를 이용하거나 RequireJS를 이용하거나 등등 방법은 많지만해당 포스트에서는 다루지 않고 건너 뛴다. 해당 포스트에서는 ES6를 왜 써야하는지,어떻게 하면 Windows XP IE8 유저들에게까지우리의 우아한 코드를 전달할 수 있는지에 대해 중점을 뒀다. ES6 왜 써?백문이 불여일견. 코드로 보자. 배열의 모든 요소를 더한 후 반환하는 코드. 1234567// ES3 (IE 8+)var arr = [1, 2, 3];var sumArr = 0;for(var i = 0; i &lt; arr.length;) &#123; sumArr += arr[i++];&#125;console.log(sumArr); // 6 1234567// ES5 (IE 9+)'use strict';var arr = [1, 2, 3, 0];var sumArr = arr.reduce(function(p, c) &#123; return a+b;&#125;);console.log(sumArr); // 6 1234// ES6 (Modern Browser)const arr = [1, 2, 3, 0];const sumArr = arr.reduce((p, c) =&gt; p+c);console.log(sumArr); // 6 private module을 구현하는 코드 (전역의 공간을 더럽히지 않는 코드)대신 script 모듈에서 script2 모듈에 있는 데이터를 불러올 수 없다.12345// ES3+ (IE 8+)(function() &#123; 'use strict'; // 소스코드 끄적끄적...&#125;()); 1234// ES6 (Moden Browser)&#123; // 소스코드 끄적끄적...&#125; public module을 구현하는 코드script 모듈에서 script2 모듈에 있는 데이터를 불러올 수 있다. 12345678910111213141516// ES3+ (IE 8+), 전역 스코프에 변수가 추가된다는 단점이 존재한다.// script.js'use strict';var car = (function() &#123; var namespace = &#123;&#125;; var color = 'blue'; // 외부에 노출시키지 않음, 캡슐화. // 아래 메소드는 네임스페이스의 메소드임. namespace.getColor = function() &#123; return color; &#125;; namespace.setColor = function(_color) &#123; color = _color; &#125;; // 메소드를 달고 있는 네임스페이스 객체 리턴. return namespace;&#125;()); 123456// ES3+ (IE 8+), 전역 스코프에 car라는 변수가 추가된다는 단점이 존재한다.// script2.js'use strict';console.log(car.getColor()); // 'blue';car.setColor('red');console.log(car.getColor()); // 'red'; 12345678910// ES6 (현재 지원하는 브라우저 없음)// 바벨을 사용하면 CommonJS 모듈로 변환해주는데// Node.js는 CommonJS를 지원해주는데 반해 브라우저는 이를 미지원한다.// 이를 위해서는 모듈 번들러인 Browserify나 Webpack을 쓰거나// 브라우저에서 지원이 되는 RequireJS 모듈로 변환해주는 바벨용 플러그인을 쓴 후// RequireJS를 사용하면 된다.// script.jslet color = 'blue';export const getColor = () =&gt; color;export const setColor = (_color) =&gt; color = _color; 1234567891011// ES6 (현재 지원하는 브라우저 없음)// 바벨을 사용하면 CommonJS 모듈로 변환해주는데// Node.js는 CommonJS를 지원해주는데 반해 브라우저는 이를 미지원한다.// 이를 위해서는 모듈 번들러인 Browserify나 Webpack을 쓰거나// 브라우저에서 지원이 되는 RequireJS 모듈로 변환해주는 바벨용 플러그인을 쓴 후// RequireJS를 사용하면 된다.// script2.jsimport &#123;getColor, setColor&#125; from './script';console.log(getColor());setColor('red');console.log(getColor()); 이외에도 정말 무궁무진할 정도로 생산성을 향상시키는 코드들이 많다. ES6에서 ES5로 트랜스파일하기ES6의 호환성 보기하지만 우리에게는 방법이 있다!바로 트랜스파일러인 바벨을 이용하는 것이다.컴파일은 사람이 이해할 수 있는 하이 레벨의 코드를컴퓨터가 이해할 수 있는 로우 레벨의 기계어로 바꾸는 것을 말한다.트랜스파일이란 같은 레벨의 다른 언어로 변환하는 것을 뜻한다.브라우저별로 ES6의 지원율이 상이하기 때문에같은 레벨인 ES6를 같은 레벨의 ES5로 트랜스파일하면 되는 것이다.그럼 우선 babel을 설치해보자. 12$ npm i -g babel-cli$ npm i -D babel-cli babel-preset-latest 위 명령어를 하나씩 파헤쳐보자. babel-cli를 global로 설치하지 않으면, 터미널에서 babel이라는 명령어를 인식하지 못한다. babel-cli는 터미널에서 babel을 돌려주는 것으로써 현재 프로젝트에 또 설치를 해줘야 동작을 제대로 한다. babel에는 plugin이라는 게 존재한다.이 plugin은 es6의 애로우 펑션을 지원하는 플러그인, 클래스를 지원하는 플러그인 등등이 있다.그러한 플러그인을 모아놓은 걸 preset이라고 부른다.es2015 preset은 es6의 플러그인들을 모아놓은 것이고,latest preset은 ES2015~ES2017까지의 프리셋들을 모아놓은 것이다.시간이 지나면 latest의 지원 프리셋 범위는 더 늘어날 수도 있다. 그리고 바벨 설정 파일을 하나 만들어줘야한다..babelrc라는 파일을 만들고 아래와 같이 적어주자. 123&#123; \"presets\": [\"latest\"]&#125; 바벨의 설정파일이 바뀔 때마다 babel-cli가 watch중이라면 꺼줬다 켜야 제대로 적용된다.그리고 폴더 구조를 아래와 같이 만들어보자. (다르게 해도 상관없다.) 12345+ es6 - script.js.babelrcindex.htmlpackge.json es6 폴더에는 es6+로 작성한 코드가 담길 것이다.script.js에는 아래와 같이 코딩해보자. 123456789&#123; const A = '1'; const arr = [1, 2]; const sumArr = arr.reduce((p, c) =&gt; p+c); console.log(sumArr); // 3 const btn = document.getElementById('btn'); const evtClick = () =&gt; console.log(A); btn.addEventListener('click', evtClick);&#125; 그 이후 터미널 창에서 아래와 같이 입력한다. 1$ babel es6 -d script -w 또 하나하나 파헤쳐보자. babel: babel-cli를 쓴다는 것이다. es6: es6 디렉토리에 있는 파일을 트랜스파일 한다. -d script: 결과물을 script라는 폴더에다가 던져준다. -w: watch, 계속 주시하면서 파일이 바뀔 때마다 트랜스파일해준다.watch를 끝내려면 Ctrl+C키를 누른 후 y키를 누른 후 Enter 키를 누르면 된다. 그리고 나서 디렉토리를 보면 다음과 같다.1234567+ es6 - script.js+ script - script.js.babelrcindex.htmlpackge.json 한 번 우리의 코드가 어떻게 바뀌었는지 script/script.js를 열어보자. 12345678910111213141516'use strict'; &#123; (function () &#123; var A = '1'; var arr = [1, 2]; var sumArr = arr.reduce(function (p, c) &#123; return p + c; &#125;); console.log(sumArr); // 3 var btn = document.getElementById('btn'); var evtClick = function evtClick() &#123; return console.log(A); &#125;; btn.addEventListener('click', evtClick); &#125;)();&#125; 쓸 데 없는 블록으로 감싸고 있긴 하지만 그래도 전역을 더럽히지 않고,훌륭하게 코드를 ES5로 트랜스파일 하였다.즉 우리가 개발할 때는 es6의 디렉토리 내의 파일로 개발을 하고배포할 때는 script 디렉토리 내의 코드를 배포하면 된다.여기까지가 IE9+ 프로젝트에서 하면 되는 내용이다. ES5를 IE8에서도 지원하기우리나라는 MS 공화국이다.저기 산골짝에 가면 XP를 쓰는 사람도 있고, 아직도 공공기관에서도 XP를 쓴다는 소리가 들린다.XP가 날고 기어봤자 IE8까지 밖에 지원이 안 되고, 그러한 악의 근원들까지 커버를 쳐야할 때가 온다.또한 윈도우 7의 기본 브라우저도 IE8이기 때문에 업데이트를 안 하는 사람들이 많다.그럴 경우를 대비해 바벨에서도 Polyfill을 준비해두었다.Polyfill이란 아래와 같이 미지원 환경에서도 해당 내용을 지원하게끔 하는 것이다. 123456789if ( !Array.prototype.forEach ) &#123; // for IE8 Array.prototype.forEach = function(fn, scope) &#123; for(var i = 0, len = this.length; i &lt; len; ++i) &#123; if (i in this) &#123; fn.call(scope, this[i], i, this); &#125; &#125; &#125;;&#125; 설치하기 귀찮은 사람을 CDN을 이용하자. (이상하게 min은 오류가 나는 것 같다.) 1https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.16.0/polyfill.js 아닌 사람은 아래와 같이 입력하여 설치해보자. 1$ npm i -S babel-polyfill 그리고 index.html에 폴리필을 넣어주자. (무조건 사용자가 작성한 코드보다 위에 존재해야한다.) 12&lt;script src=\"./node_modules/babel-polyfill/dist/polyfill.js\"&gt;&lt;/script&gt;&lt;script src=\"./script/script.js\"&gt;&lt;/script&gt; 그리고 IE8에서 실행해보자.addEventListener, removeEventListener 등등의 Polyfill을 수동으로 추가해줘야한다.아래 링크로 가면 minify 버전의 소스코드도 볼 수 있다.Polyfill the EventListener interface in IE8 12345678910111213141516171819202122232425262728// eventListener.polyfill.js!window.addEventListener &amp;&amp; (function(WindowPrototype, DocumentPrototype, ElementPrototype, addEventListener, removeEventListener, dispatchEvent, registry) &#123; WindowPrototype[addEventListener] = DocumentPrototype[addEventListener] = ElementPrototype[addEventListener] = function(type, listener) &#123; var target = this; registry.unshift([target, type, listener, function(event) &#123; event.currentTarget = target; event.preventDefault = function() &#123; event.returnValue = false &#125;; event.stopPropagation = function() &#123; event.cancelBubble = true &#125;; event.target = event.srcElement || target; listener.call(target, event); &#125;]); this.attachEvent(\"on\" + type, registry[0][3]); &#125;; WindowPrototype[removeEventListener] = DocumentPrototype[removeEventListener] = ElementPrototype[removeEventListener] = function(type, listener) &#123; for(var index = 0, register; register = registry[index]; ++index) &#123; if(register[0] == this &amp;&amp; register[1] == type &amp;&amp; register[2] == listener) &#123; return this.detachEvent(\"on\" + type, registry.splice(index, 1)[0][3]); &#125; &#125; &#125;; WindowPrototype[dispatchEvent] = DocumentPrototype[dispatchEvent] = ElementPrototype[dispatchEvent] = function(eventObject) &#123; return this.fireEvent(\"on\" + eventObject.type, eventObject); &#125;;&#125;)(Window.prototype, HTMLDocument.prototype, Element.prototype, \"addEventListener\", \"removeEventListener\", \"dispatchEvent\", []); 그리고 index.html에 폴리필을 넣어주자. (무조건 사용자가 작성한 코드보다 위에 존재해야한다.) 123&lt;script src=\"./node_modules/babel-polyfill/dist/polyfill.js\"&gt;&lt;/script&gt;&lt;script src=\"./script/eventListener.polyfill.js\"&gt;&lt;/script&gt;&lt;script src=\"./script/script.js\"&gt;&lt;/script&gt; 아직 끝난 게 아니다.아래와 같은 코드를 보자. 1234const foo = &#123; catch: function () &#123;&#125;&#125;;foo.catch(); 이제 위 코드가 어떻게 트랜스파일 되는지 보자. 12345\"use strict\"; var foo = &#123; catch: function _catch() &#123;&#125;&#125;;foo.catch(); 위와 같은 코드를 IE8에서 테스트 해보자.2번 라인과 4번 라인에서 객체의 메소드와 메소드 호출로 catch를 사용하였다.IE8은 ES3를 지원하고, ES3에서는 catch 같은 키워드를 저렇게 식별자로 쓰게 되면 오류를 뿜는다.ES3를 위한 플러그인이 바벨에는 또 존재한다. 1$ npm i -D babel-plugin-transform-es3-property-literals babel-plugin-transform-es3-member-expression-literals babel-plugin-transform-es3-property-literals을 쓰면 아래와 같이 바뀐다. 123var foo = &#123; \"catch\": function _catch() &#123;&#125;&#125;; 프로퍼티에서 키워드인 catch에 쌍따옴표를 붙인 걸 볼 수 있다. babel-plugin-transform-es3-member-expression-literals을 쓰면 아래와 같이 바뀐다. 1foo[\"catch\"](); 표현식에서 키워드인 catch를 []로 감싸고, 쌍따옴표를 붙인 걸 볼 수 있다.플러그인을 쓰기 위해 .babelrc 파일을 수정하자. 1234567&#123; \"presets\": [\"latest\"], \"plugins\": [ \"transform-es3-property-literals\", \"transform-es3-member-expression-literals\" ]&#125; 여기까지 완료하면 IE8까지 ES6의 문법을 그대로 쓸 수 있다. 바벨은 안전한가?아래와 같은 ES6 코드를 보자. 12console.log(a); // Uncaught ReferenceError: a is not definedconst a = 2; 변수 a가 선언 되기도 전에 사용을 하고 있고, TDZ에 존재하는 a는 사용할 수 없는 예제이다.하지만 위 코드를 ES5로 트랜스파일하면 아래와 같다. 123\"use strict\"; console.log(a); // undefinedvar a = 2; var의 호이스팅 때문에 ES6와는 다른 값이 나오게 된다.이러한 점 말고도 더 있는지 모르겠지만 바벨이 ES5 전부를 커버할 수 있는 건 아니다.이는 바벨이 꼬지기 때문이 아니라 ES6와 ES5 사이의 언어의 설계에 대한 차이 때문에일어나는 어쩔 수 없는 현상이다.실제 배포하는 파일은 ES5 파일이기 때문에 바벨이 존재한다 하더라도 ES5까지 알아둬야개발하는데 훨씬 수월할 것이다.따라서 ES5와 ES6를 병행하여 공부하는 게 현명한 방법이 아닐까 싶다.또한 팀원들이 ES6, npm 등등에 대한 지식이 없다면 학습하는 비용까지 포함하면지금 당장은 실무에 적용하기엔 무리가 있을 것이다.하지만 다같이 스터디를 하고, 추후에 있을 프로젝트에서 사용한다고 가정했을 때생산성이 향상되는 효과를 볼 수 있지 않을까 싶다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"http://perfectacle.github.io/categories/Front-end/"},{"name":"Babel","slug":"Front-end/Babel","permalink":"http://perfectacle.github.io/categories/Front-end/Babel/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"Babel","slug":"Babel","permalink":"http://perfectacle.github.io/tags/Babel/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"Cross Browsing","slug":"Cross-Browsing","permalink":"http://perfectacle.github.io/tags/Cross-Browsing/"},{"name":"npm","slug":"npm","permalink":"http://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://perfectacle.github.io/tags/Node-js/"}]},{"title":"(ES6) Scope","slug":"ES6-Scope","date":"2016-11-10T12:18:24.000Z","updated":"2017-06-25T17:13:45.000Z","comments":true,"path":"2016/11/10/ES6-Scope/","link":"","permalink":"http://perfectacle.github.io/2016/11/10/ES6-Scope/","excerpt":"","text":"목차 들어가기에 앞서 ES5의 함수 단위의 스코프 함수 단위 스코프의 위험성 함수 단위 스코프의 극복, 모듈화 ES6의 블록 단위의 스코프 TDZ 들어가기에 앞서스코프, 콜 스택, 실행 컨텍스트가 무엇인지, ES5, ES6가 무엇인지에 대해서는 설명하지 않는다.ES5와 ES6 사이에 있어서 스코프의 차이점은ES5는 함수 단위의 스코프이고, ES6는 블록 단위의 스코프라는 점이다.ES5와 ES6를 병행하여 학습하는 방법이 필자는 좋다고 여겨 한 포스트에 몰아 넣어서 분량이 길다.따뜻한 사랑과 관심이 많이 필요하다.ES5의 스코프에 대해 충분히 숙지한 사람들은 ES6의 블록 단위의 스코프부터 읽도록 하자.그럼 스코프에 대해서 심화하여 다뤄보도록 하자. ES5의 함수 단위의 스코프우선 ES5의 함수 단위 스코프부터 살펴보자.12345678910&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"./index2.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123// index2.jsvar A = 'a';var AA = 'c'; 우선 크롬의 개발자 도구(F12)에서 소스 탭으로 들어간 후에 자바스크립트 소스 파일을 선택해준다.그리고 변수를 초기화하는 2, 3번 라인에 브레이크 포인트를 걸어준 후에 새로고침하면2번 라인을 실행하기 전에 브레이크가 걸리게 된다.콜 스택에는 전역 실행 컨텍스트만 쌓여있는 상태인데,여기서 실행 컨텍스트가 생기는 경우를 되짚어보자. 전역코드 함수를 호출한 경우 eval() 함수를 호출한 경우 위 예제는 1번에 해당한다.전역 코드의 실행 컨텍스트는 콜 스택에 Push되고,(anonymous function)이 그 실행 컨텍스트를 가리킨다.전역 실행 컨텍스트의 스코프는 Global 객체인 window 객체의 프로퍼티로 들어간 것 처럼 보인다.브라우저가 아닌 Node.js에서는 Global 객체가 window 객체가 아니라global이라는 이름을 가진 객체이므로 예제는 반드시 브라우저에서 실행하자.http://stackoverflow.com/questions/19849136/does-node-js-have-equivalent-to-window-object-in-browser또한 delete 연산자로 삭제되지 않으므로 프로퍼티가 아니니 혼동하지 말길 바란다.하지만 window.A와 같이 사용이 가능하므로 window 객체의 프로퍼티의 이름을 피해서변수 네이밍 하는 걸 추천한다.또한 코드가 실행되기도 이전에 A와 AA 변수가 선언되고 undefined라는 값을 가진 걸 볼 수 있다.ES5의 이러한 호이스팅 때문에 갖은 오류를 양산하기도 하였다. 이번에는 함수를 호출한 경우에 스코프가 어떻게 형성되는지 알아보자.12345678910&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"./index4.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112// index4.js'use strict';var A = 'A';var B = function() &#123; var A = 'B'; var C = function() &#123; console.log(A) &#125;; C();&#125;; console.log(A); // 'A'B(); // 'B' 6번 라인에서 브레이크 포인트를 걸고 콜스택을 보자. C B (anonymous function) 순으로 콜스택에 쌓여있다.이를 풀어 써보자면… 함수 C의 실행 컨텍스트 함수 B의 실행 컨텍스트 전역 실행 컨텍스트 그리고 각 컨텍스트를 한번 뒤집어 까보자!먼저 위 사진을 보면 전역 실행 컨텍스트에는 사용자가 변수로 선언한 A가 “A”라는 값을 갖고 있다.물론 내리면 변수 B에 함수가 할당된 것도 볼 수 있다. 그 다음으로 함수 B의 실행 컨텍스트를 까보자.파란색이 함수 B의 실행 컨텍스트, 빨간색이 전역 실행 컨텍스트다.함수 B의 실행 컨텍스트는 따로 Local이라는 스코프를 가지고 있다.그 안에 존재하는 변수들이 지역 변수가 되는 것이다.서로 같은 A라는 변수지만 지역 변수가 더 우선순위가 높아서함수 B 안에서는 전역 변수 A가 아닌 지역 변수 A를 갖고 놀게 된다.만약 지역 변수 A가 없는데 A를 갖고 놀려면 스코프 체인이란 걸 타고 전역까지 뒤지게 될 것이다. 마지막으로 함수 C의 실행 컨텍스트를 까보자.빨간색이 함수 B의 실행 컨텍스트, 파란색이 함수 C의 실행 컨텍스트이다.함수 C의 실행 컨텍스트의 스코프 내부에는 this 밖에 없다.하지만 함수 C에서는 A라는 변수를 갖고 놀고 있다.자신의 스코프에 해당 변수가 없으므로 스코프 체인을 타고 올라가서바로 상위 스코프인 함수 B의 실행 컨텍스트에 변수 A가 있으므로 그걸 가지고 논다.하지만 자신의 스코프가 아닌 상위 스코프를 가지고 노는 것이므로 클로저다.다시 한번 클로저의 정의를 상기시켜보자. 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수 생성 당시의 스코프에 대한 연결을 갖는 블록 함수 B의 스코프가 이미 생명 주기가 끝난 외부 함수의 변수, 생성 당시의 스코프이고,함수 C의 스코프가 참조하는 함수, 연결을 갖는 블록과 매칭이 된다.왜 그런지 궁금하면 아래 링크를 참조하고 공부하자.http://blog.javarouka.me/2012/01/closure.html 함수 단위 스코프의 위험성123456789101112&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"btn\"&gt;버튼&lt;/button&gt;&lt;script src=\"./index2.js\"&gt;&lt;/script&gt;&lt;script src=\"./index3.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678// index2.js'use strict';var A = '1';var btn = document.getElementById('btn');var evtClick = function() &#123; console.log(A);&#125;;btn.addEventListener('click', evtClick); 123// index3.js'use strict';var A = '2'; index2.js의 5, 7번 라인에서 브레이크 포인트를 걸고 현재 전역 컨텍스트의A의 값을 보면 “1”이라는 값이 들어간 것을 볼 수 있다.그리고 나서 index.html에서 버튼을 클릭해보자.index2.js의 7번 라인에서 브레이크가 걸린다.그리고 전역 컨텍스트의 A의 값을 보면 쥐도새도 모르게 “2”라는 값으로 바뀌어있다.바로 index3.js에서 바꿔치기 한 것이다.index.html의 소스를 보면 index2.js를 먼저 로드하고 그 이후에 index3.js를그 후에 로드하기 때문에 위 소스를 합쳐보면 아래와 같이 된다.1234567891011// index2.js'use strict';var A = '1';var btn = document.getElementById('btn');var evtClick = function() &#123; console.log(A); // 바꿔치기 된 애를 콘솔창에 찍음.&#125;;btn.addEventListener('click', evtClick);// index3.js'use strict';var A = '2'; // 여기서 바꿔치기 됨. 함수 단위 스코프의 극복, 모듈화위와 같이 전역 스코프가 더러워지는 것을 방지하고자자바나 C++과 같이 자바스크립트도 모듈화하려는 시도는 많았다.CommonJS와 RequireJS가 대표적이었으나 현재는 Webpack이 대세인 것 같다.위와 관련된 글들도 인터넷에 상당히 널려있으니 찾아서 공부하자.여기서 위의 내용을 다루기에는 광범위하므로 순수 ES5만으로만 구현해보자.index2.js와 index3.js의 소스를 아래와 같이 고쳐보자.12345678910// index2.js(function() &#123; 'use strict'; var A = '1'; var btn = document.getElementById('btn'); var evtClick = function() &#123; console.log(A); &#125;; btn.addEventListener('click', evtClick);&#125;()); 12345// index3.js(function() &#123; 'use strict'; var A = '2';&#125;()); 위 코드는 즉시 실행 함수(IIFE)를 이용한 패턴으로,코드를 로드하자마자 함수를 실행시켜버려서 스코프로 감싸버리는 것이다.따라서 위와 같이 하면 전역에 아무런 변수도 노출시키지 않게 된다.6, 8번 라인에 브레이크 포인트를 걸고 콜스택을 보면 아래와 같다. (anonymous function) (anonymous function) 풀어서 쓰면 아래와 같다. index.js의 실행 컨텍스트 전역 실행 컨텍스트 index.js의 실행 컨텍스트를 보면 자기 자신이 가지고 있는 변수만 가지고 있다.Global 객체를 까봐도 전혀 자신의 정보를 노출하고 있지 않다. 이제 index.html에서 버튼을 눌러서 실제로 어떻게 작동하는지 보자.색깔로 구분해서 클로저를 사용했다는 것을 쉽게 알 수 있다.그리고 모듈화를 하였으므로 다른 파일과 소통을 하지 않아 자기 자신의 값을 그대로 지키고 있다.모듈화 패턴은 IIFE말고도 위에 언급한 프레임워크를 쓴다거나 네임스페이스 패턴을 쓰거나방법은 무궁무진하므로 본인의 입맛대로 코딩하는 걸 추천한다. ES6의 블록 단위의 스코프이제부터가 본 게임의 시작이다.ES6에서는 const와 let이라는 키워드로 변수를 선언한다.레거시 환경 때문인지 여전히 var를 지원하지만 함수 단위의 스코프는위에서 말한 단점들이 존재해서 더 이상 쓰지 않는 걸 권장한다.const는 상수를 선언할 때 쓰며 선언과 동시에 할당을 무조건 해야한다.let은 var에서 블록 단위의 스코프로 바뀐 것과 TDZ 빼고는 크게 차이점은 없다.그럼 한번 다시 위의 코드를 const와 let을 써서 바꿔보자. 12345678910&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"./index2.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234// index2.jsconst A = 'a';let AA = 'c';A = 'a'; // Uncaught TypeError 참고로 ES6에서는 항상 strict 모드로 작동한다.http://stackoverflow.com/questions/31685262/not-recommended-to-write-out-use-strict-with-es6소스 코드 전체에 브레이크 포인트를 걸고 지켜봤더니 신기하게 Global 객체에 A와 AA 변수가 없다.호이스팅이 일어나지 않는 걸까…?파이어폭스에서는 호이스팅이 일어난다.크롬의 오류다. 크롬이 만능은 아니었다.1번 라인을 실행 한 후 2번 라인이 실행되기 전에 브레이크가 걸리는데이 때 스코프에 새로운 스코프가 생성된다.새로운 함수를 실행한 것이 아닌데도 Script라는 새로운 스코프가 생성되었다.const와 let을 사용하면 global 객체의 프로퍼티와 변수명이 충돌이 일어나지 않게 되어좀 더 자유로운 네이밍이 가능해졌다.2번 라인을 실행 후 3번 라인이 실행되기 전에 브레이크가 걸리고,이 때 스코프를 보면 2번 라인의 AA 변수가 Script라는 스코프에 생성된 걸 볼 수 있다.3번 라인까지 실행시키면Uncaught TypeError: Assignment to constant variable.라는 오류 메시지를 볼 수 있다.상수에 값을 할당하려고 했기 때문이다. (설령 같은 값일지라도…)ES6는 변수를 새로운 스코프에 할당하는 모양이다. 그럼 위에서 작성했던 코드를 다시 한번 고쳐보자.123456789101112&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"btn\"&gt;버튼&lt;/button&gt;&lt;script src=\"./index2.js\"&gt;&lt;/script&gt;&lt;script src=\"./index3.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567// index2.jsconst A = '1';const btn = document.getElementById('btn');const evtClick = function() &#123; console.log(A);&#125;;btn.addEventListener('click', evtClick); 12// index3.jsconst A = '2'; // Uncaught SyntaxError: Identifier 'A' has already been declared 분명 파일을 분리했는데도 A를 중복해서 선언했다고 오류를 뿜는다.테스트를 위해 index3.js의 소스를 아래와 같이 고쳐보자.123// index3.jsconst B = '2';console.log(A); // 1 이해를 돕고자 index3.js의 2번 라인에 브레이크 포인트를 걸었다.엄머나… Script라는 스코프 안에 index2.js와 index3.js의 변수가 짬뽕 리믹스 돼있다…결과적으로 ES5와 다른 점은 글로벌 객체가 아닌 별도의 스코프를 생성할 뿐, 큰 차이는 없다.사실 호이스팅이 일어나기는 하지만, TDZ라는 것을 알아야하기 때문에 마지막에 설명한다.그럼 블록이 무엇인지에 대해서 생각해보자.{ … } 이게 블록이다. 끝이다.if(bool) {…}, while(bool) {…}, for(…) {…}, function(…) {…}등등 {와 }으로 감싸진다면 다 블록이다.즉 블록 단위 스코프가 함수 단위 스코프를 포함하고 있는 관계가 된다.이제 그럼 js 파일들을 블록으로 감싸보자.디버깅하려고 로그도 찍어봤다.1234567891011// index2.js&#123; const A = '1'; console.log(1); const btn = document.getElementById('btn'); const evtClick = function() &#123; console.log(A); console.log(1); &#125;; btn.addEventListener('click', evtClick);&#125; 12345// index3.js&#123; const A = '2'; console.log(1);&#125; console.log 부분을 전부 브레이크 포인트를 걸어준다.3번에서 멈췄고 스코프를 보니 Block이라는 스코프가 새로 생겼다.이름만 들어도 블록 스코프임이 틀림 없어보인다.그 다음은 index3.js에서 브레이크가 걸린다.새로운 Block 스코프가 생겼다.블록을 만날 때마다 블록 스코프가 생기니 즉시 실행 함수와 같이지저분한 패턴을 쓰지 않아도 모듈화가 가능하다.버튼을 누르고 나서 브레이크가 찍힌 모습이다.스코프는 클릭 이벤트 리스너의 스코프만이 존재한다.함수로 감싼 게 아니기 때문에 클로저도 아니라 성능면에서도 훨씬 좋다.하지만 다른 파일에서 현재 파일의 변수의 값을 얻어오지 못한다.블록 스코프로 구현한 모듈은 반쪽짜리 모듈,자바로 치면 private class 밖에 되지 않는다.이를 해결하기 위한 문법으로 import, export 문이 ES6에 존재하지만 지원하는 브라우저가 없다.때문에 모듈화를 하고 싶다면 웹팩이란 녀석을 쓰면 된다.이것도 마찬가지로 웹서핑 하면 많이 나오므로 자세한 설명은 생략하도록 하자. TDZ드디어 대망의 마지막 챕터다.TDZ는 Temporal Dead Zone의 줄임말로 호이스팅, 스코프와 연관이 깊다.아래 코드를 보면서 얘기하자.1234567891011&lt;!doctype html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"btn\"&gt;버튼&lt;/button&gt;&lt;script src=\"./index2.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567// index2.js&#123; const A = '1'; console.log(1); console.log(btn); // Uncaught ReferenceError: btn is not defined const btn = document.getElementById('btn');&#125; 2번 라인에 브레이크 포인트를 걸고 보면 btn이 undefined라는 값을 가지고 있다.5번에 도달하기도 전이니 호이스팅이 된 것이다.하지만 4번 라인을 만나는 순간 오류를 뿜게 된다.이유는 변수 btn은 선언되기 전까지 호이스팅은 되지만 TDZ에 존재하기 때문이다.TDZ에 존재하는 변수에 접근하면 위와 같은 에러를 뿜는 것이고,선언이 되는 순간 TDZ에서 빠져나오게 된다.선언되기 전까지 임시적(Temporal)으로 죽어(Dead)있기 때문에 그런 이름이 붙지 않았나 싶다.아마 레거시 환경(var) 때문에 호이스팅을 살려둬야 했고, 그로 인한 오류를 줄이고자ES6 환경에서는 TDZ를 만들어서 두 가지 요구사항을 동시에 충족시킨 것 같다.이렇게만 보면 점점 자바스럽게 변하는 게 아닐지 모르겠지만아래 코드를 보면 생각이 달라질 것이다.1234567891011public class HelloWorld&#123; int x = 10; void print() &#123; System.out.println(x); // 10 int x = 20; &#125; public static void main(String []args)&#123; HelloWorld _class = new HelloWorld(); _class.print(); &#125;&#125; 자바의 경우 호이스팅이 일어나지 않는다.TDZ라는 것도 존재하지 않는다.하지만 ES6에서는 위 두 개념들이 존재한다.호이스팅 된 변수는 선언되기 전까지 TDZ에 존재해 접근이 불가능하다.ES6에서 위 코드를 비슷하게 구현에 포커스를 두고 코딩을 하면 아래와 같다.12345678&#123; let x = 10; let print = () =&gt; &#123; console.log(x); // Uncaught ReferenceError: x is not defined let x = 15; // 얘가 없다면 콘솔 창에 10이 찍힘. &#125;; print();&#125; 5번 라인의 x가 호이스팅 되고, 5번 라인에 다다르기 전까지는 TDZ에 존재하여 접근이 불가능해진다.하지만 4번 라인에서 접근을 하고 있으므로 에러를 뿜는 것이다.이 또한 좀 아이러니하게 설계가 된 것 같다.레거시 환경을 버릴 수 없으니 이러한 문제점을 떠안고 가는 것 같은데…그래도 이렇게 만들어진 걸 어찌하랴, 나중에 또 극복하는 방법들을 찾아보거나위와 같은 패턴으로 코딩하는 걸 피하게끔 이런 개념들을 중요시 여기고 익혀야겠다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"http://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"http://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"http://perfectacle.github.io/tags/ES2015/"},{"name":"Scope","slug":"Scope","permalink":"http://perfectacle.github.io/tags/Scope/"}]},{"title":"블로그를 시작하다","slug":"Start-Blog","date":"2016-11-09T16:38:50.000Z","updated":"2017-02-13T04:46:22.000Z","comments":true,"path":"2016/11/10/Start-Blog/","link":"","permalink":"http://perfectacle.github.io/2016/11/10/Start-Blog/","excerpt":"","text":"기존의 네이버 블로그를 포기하고 새로 블로그를 이전했다.다소 어려움들이 있었지만 제대로 해보려고 한다. 왜 블로그를 옮겼는가? 네이버 블로그는 꾸미는데 제약사항이 많다. 기존의 블로그는 너무 중구난방식이었다. 깃헙 페이지를 이용하면 뭔가 개발자스럽다. 마크다운 문법에 익숙해지고 싶다. 포트폴리오 파일들을 내 블로그에 올리는 게 가능하다. 포스트의 버전관리도 가능하다. 내가 네이버 블로그를 제대로 관리 안 한 탓도 있었지만,구글링을 하다보면 티스토리나 기타 블로그들은 정말 멋진 개발자다운 블로그였다.하지만 그런 걸 네이버 블로그로 하려면 엄두가 나지 않았다.티스토리가 유력한 후보였지만, 깃헙 페이지가 더 개발자스러워보이고,깃헙을 쓴다면 마크다운 문법에 익숙해질 필요가 있다고 판단하여 깃헙 페이지를 선정하였다.또한 블로그의 포스트를 마이그레이션 할 때도 마크다운 문법은 매우 좋다고 들었다.타 블로그들을 인라인 스타일 때문에 마이그레이션 할 때 문제가 많다지만,마크업 문법을 HTML로 바꾸는 것은 매우 쉽다고 들었기 때문이다. 아쉬운 점 테마의 디자인이 조금 옛스럽다. 테마의 디자인이 이쁘면 기능이 구지다. 블로그 개발용과 배포용 저장소를 따로 만들어야한다. 나는 블로그에 글 쓰는 것에 초점을 두고 싶었으나깃헙 페이지는 나에게 너무나 많은 것을 요구했다.일단 git은 어느정도 사용해서 문제될 게 없었으나 망할놈의 Jekyll…또한 Jekyll을 쓰려면 Ruby를 설치해야했고, Windows OS를 쓰는 나에게는 크나큰 장벽이 되었다.경로가 꼬이거나 해줘야하는 잡다한 작업들이 많아서 그냥 포기해버렸다. 해서 찾아낸 게 Hexo다.Node 위에서 돌아가기 때문에 Windows OS에서도 전혀 문제가 없다.하지만 이 역시 직접 커스터마이징 하기가 귀찮고 시간이 오래 걸려서…그렇게 해서 테마찾기의 여정 끝에 Hueman이라는 테마를 찾았다.디자인 개선하려면 무지하게 귀찮고 엄청난 삽질이 예상된다. 좋은 점 검색 기능 댓글 기능 멀티 카테고리 기능 카테고리 별 페이지네이션 태그 기능 태그 별 페이지네이션 최근 포스트 반응형 짱짱맨 여러가지 테마를 찾아본 가운데 위 사항들이 나를 매료했다.디자인이 제일 마음에 걸렸지마는…나에게는 글 쓰는 것이 메인이기 때문에, 더 이상 시간을 허비할 수 없었다.나중에 좋은 테마를 또 발견한다면 포스트만 들고 날아가면 되기 때문이다. 자, 이제 시작이다!내 꿈을!내 꿈을 펼칠 블로그의 토대가 마련되었다.당분간은 좀 더 뻘짓을 할 수도 있겠지만…일단은 기존의 블로그에서 있던 내용 조금씩 정리하며 퍼다 나르고,밀렸던 리액트며, ES6 등등의 공부를 해야겠다!!","categories":[{"name":"기타","slug":"기타","permalink":"http://perfectacle.github.io/categories/기타/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"http://perfectacle.github.io/categories/기타/잡동사니/"}],"tags":[{"name":"잡동사니","slug":"잡동사니","permalink":"http://perfectacle.github.io/tags/잡동사니/"}]}]}